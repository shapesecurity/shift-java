// Generated by ast-path.js
/**
 * Copyright 2018 Shape Security, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


package com.shapesecurity.shift.es2018.astpath;


import com.shapesecurity.functional.data.ImmutableList;
import com.shapesecurity.functional.data.Maybe;
import com.shapesecurity.shift.es2018.ast.*;

import java.util.Objects;


public abstract class ASTPath<S, T> implements ObjectPath<S, T> {
  private ASTPath() {}

  public abstract String propertyName();

  public boolean equals(Object o) {
    return this == o || o != null && getClass() == o.getClass();
  }

  public int hashCode() {
    return Objects.hash(getClass());
  }


  public static final ArrayAssignmentTarget_Elements ArrayAssignmentTarget_Elements = new ArrayAssignmentTarget_Elements();

  public static final ArrayAssignmentTarget_Rest ArrayAssignmentTarget_Rest = new ArrayAssignmentTarget_Rest();

  public static final ArrayBinding_Elements ArrayBinding_Elements = new ArrayBinding_Elements();

  public static final ArrayBinding_Rest ArrayBinding_Rest = new ArrayBinding_Rest();

  public static final ArrayExpression_Elements ArrayExpression_Elements = new ArrayExpression_Elements();

  public static final ArrowExpression_IsAsync ArrowExpression_IsAsync = new ArrowExpression_IsAsync();

  public static final ArrowExpression_Params ArrowExpression_Params = new ArrowExpression_Params();

  public static final ArrowExpression_Body ArrowExpression_Body = new ArrowExpression_Body();

  public static final AssignmentExpression_Binding AssignmentExpression_Binding = new AssignmentExpression_Binding();

  public static final AssignmentExpression_Expression AssignmentExpression_Expression = new AssignmentExpression_Expression();

  public static final AssignmentTargetIdentifier_Name AssignmentTargetIdentifier_Name = new AssignmentTargetIdentifier_Name();

  public static final AssignmentTargetPropertyIdentifier_Binding AssignmentTargetPropertyIdentifier_Binding = new AssignmentTargetPropertyIdentifier_Binding();

  public static final AssignmentTargetPropertyIdentifier_Init AssignmentTargetPropertyIdentifier_Init = new AssignmentTargetPropertyIdentifier_Init();

  public static final AssignmentTargetPropertyProperty_Name AssignmentTargetPropertyProperty_Name = new AssignmentTargetPropertyProperty_Name();

  public static final AssignmentTargetPropertyProperty_Binding AssignmentTargetPropertyProperty_Binding = new AssignmentTargetPropertyProperty_Binding();

  public static final AssignmentTargetWithDefault_Binding AssignmentTargetWithDefault_Binding = new AssignmentTargetWithDefault_Binding();

  public static final AssignmentTargetWithDefault_Init AssignmentTargetWithDefault_Init = new AssignmentTargetWithDefault_Init();

  public static final AwaitExpression_Expression AwaitExpression_Expression = new AwaitExpression_Expression();

  public static final BinaryExpression_Left BinaryExpression_Left = new BinaryExpression_Left();

  public static final BinaryExpression_Operator BinaryExpression_Operator = new BinaryExpression_Operator();

  public static final BinaryExpression_Right BinaryExpression_Right = new BinaryExpression_Right();

  public static final BindingIdentifier_Name BindingIdentifier_Name = new BindingIdentifier_Name();

  public static final BindingPropertyIdentifier_Binding BindingPropertyIdentifier_Binding = new BindingPropertyIdentifier_Binding();

  public static final BindingPropertyIdentifier_Init BindingPropertyIdentifier_Init = new BindingPropertyIdentifier_Init();

  public static final BindingPropertyProperty_Name BindingPropertyProperty_Name = new BindingPropertyProperty_Name();

  public static final BindingPropertyProperty_Binding BindingPropertyProperty_Binding = new BindingPropertyProperty_Binding();

  public static final BindingWithDefault_Binding BindingWithDefault_Binding = new BindingWithDefault_Binding();

  public static final BindingWithDefault_Init BindingWithDefault_Init = new BindingWithDefault_Init();

  public static final Block_Statements Block_Statements = new Block_Statements();

  public static final BlockStatement_Block BlockStatement_Block = new BlockStatement_Block();

  public static final BreakStatement_Label BreakStatement_Label = new BreakStatement_Label();

  public static final CallExpression_Callee CallExpression_Callee = new CallExpression_Callee();

  public static final CallExpression_Arguments CallExpression_Arguments = new CallExpression_Arguments();

  public static final CatchClause_Binding CatchClause_Binding = new CatchClause_Binding();

  public static final CatchClause_Body CatchClause_Body = new CatchClause_Body();

  public static final ClassDeclaration_Name ClassDeclaration_Name = new ClassDeclaration_Name();

  public static final ClassDeclaration_Super ClassDeclaration_Super = new ClassDeclaration_Super();

  public static final ClassDeclaration_Elements ClassDeclaration_Elements = new ClassDeclaration_Elements();

  public static final ClassElement_IsStatic ClassElement_IsStatic = new ClassElement_IsStatic();

  public static final ClassElement_Method ClassElement_Method = new ClassElement_Method();

  public static final ClassExpression_Name ClassExpression_Name = new ClassExpression_Name();

  public static final ClassExpression_Super ClassExpression_Super = new ClassExpression_Super();

  public static final ClassExpression_Elements ClassExpression_Elements = new ClassExpression_Elements();

  public static final CompoundAssignmentExpression_Binding CompoundAssignmentExpression_Binding = new CompoundAssignmentExpression_Binding();

  public static final CompoundAssignmentExpression_Operator CompoundAssignmentExpression_Operator = new CompoundAssignmentExpression_Operator();

  public static final CompoundAssignmentExpression_Expression CompoundAssignmentExpression_Expression = new CompoundAssignmentExpression_Expression();

  public static final ComputedMemberAssignmentTarget_Object ComputedMemberAssignmentTarget_Object = new ComputedMemberAssignmentTarget_Object();

  public static final ComputedMemberAssignmentTarget_Expression ComputedMemberAssignmentTarget_Expression = new ComputedMemberAssignmentTarget_Expression();

  public static final ComputedMemberExpression_Object ComputedMemberExpression_Object = new ComputedMemberExpression_Object();

  public static final ComputedMemberExpression_Expression ComputedMemberExpression_Expression = new ComputedMemberExpression_Expression();

  public static final ComputedPropertyName_Expression ComputedPropertyName_Expression = new ComputedPropertyName_Expression();

  public static final ConditionalExpression_Test ConditionalExpression_Test = new ConditionalExpression_Test();

  public static final ConditionalExpression_Consequent ConditionalExpression_Consequent = new ConditionalExpression_Consequent();

  public static final ConditionalExpression_Alternate ConditionalExpression_Alternate = new ConditionalExpression_Alternate();

  public static final ContinueStatement_Label ContinueStatement_Label = new ContinueStatement_Label();

  public static final DataProperty_Name DataProperty_Name = new DataProperty_Name();

  public static final DataProperty_Expression DataProperty_Expression = new DataProperty_Expression();

  public static final Directive_RawValue Directive_RawValue = new Directive_RawValue();

  public static final DoWhileStatement_Body DoWhileStatement_Body = new DoWhileStatement_Body();

  public static final DoWhileStatement_Test DoWhileStatement_Test = new DoWhileStatement_Test();

  public static final Export_Declaration Export_Declaration = new Export_Declaration();

  public static final ExportAllFrom_ModuleSpecifier ExportAllFrom_ModuleSpecifier = new ExportAllFrom_ModuleSpecifier();

  public static final ExportDefault_Body ExportDefault_Body = new ExportDefault_Body();

  public static final ExportFrom_NamedExports ExportFrom_NamedExports = new ExportFrom_NamedExports();

  public static final ExportFrom_ModuleSpecifier ExportFrom_ModuleSpecifier = new ExportFrom_ModuleSpecifier();

  public static final ExportFromSpecifier_Name ExportFromSpecifier_Name = new ExportFromSpecifier_Name();

  public static final ExportFromSpecifier_ExportedName ExportFromSpecifier_ExportedName = new ExportFromSpecifier_ExportedName();

  public static final ExportLocalSpecifier_Name ExportLocalSpecifier_Name = new ExportLocalSpecifier_Name();

  public static final ExportLocalSpecifier_ExportedName ExportLocalSpecifier_ExportedName = new ExportLocalSpecifier_ExportedName();

  public static final ExportLocals_NamedExports ExportLocals_NamedExports = new ExportLocals_NamedExports();

  public static final ExpressionStatement_Expression ExpressionStatement_Expression = new ExpressionStatement_Expression();

  public static final ForAwaitStatement_Left ForAwaitStatement_Left = new ForAwaitStatement_Left();

  public static final ForAwaitStatement_Right ForAwaitStatement_Right = new ForAwaitStatement_Right();

  public static final ForAwaitStatement_Body ForAwaitStatement_Body = new ForAwaitStatement_Body();

  public static final ForInStatement_Left ForInStatement_Left = new ForInStatement_Left();

  public static final ForInStatement_Right ForInStatement_Right = new ForInStatement_Right();

  public static final ForInStatement_Body ForInStatement_Body = new ForInStatement_Body();

  public static final ForOfStatement_Left ForOfStatement_Left = new ForOfStatement_Left();

  public static final ForOfStatement_Right ForOfStatement_Right = new ForOfStatement_Right();

  public static final ForOfStatement_Body ForOfStatement_Body = new ForOfStatement_Body();

  public static final ForStatement_Init ForStatement_Init = new ForStatement_Init();

  public static final ForStatement_Test ForStatement_Test = new ForStatement_Test();

  public static final ForStatement_Update ForStatement_Update = new ForStatement_Update();

  public static final ForStatement_Body ForStatement_Body = new ForStatement_Body();

  public static final FormalParameters_Items FormalParameters_Items = new FormalParameters_Items();

  public static final FormalParameters_Rest FormalParameters_Rest = new FormalParameters_Rest();

  public static final FunctionBody_Directives FunctionBody_Directives = new FunctionBody_Directives();

  public static final FunctionBody_Statements FunctionBody_Statements = new FunctionBody_Statements();

  public static final FunctionDeclaration_IsAsync FunctionDeclaration_IsAsync = new FunctionDeclaration_IsAsync();

  public static final FunctionDeclaration_IsGenerator FunctionDeclaration_IsGenerator = new FunctionDeclaration_IsGenerator();

  public static final FunctionDeclaration_Name FunctionDeclaration_Name = new FunctionDeclaration_Name();

  public static final FunctionDeclaration_Params FunctionDeclaration_Params = new FunctionDeclaration_Params();

  public static final FunctionDeclaration_Body FunctionDeclaration_Body = new FunctionDeclaration_Body();

  public static final FunctionExpression_IsAsync FunctionExpression_IsAsync = new FunctionExpression_IsAsync();

  public static final FunctionExpression_IsGenerator FunctionExpression_IsGenerator = new FunctionExpression_IsGenerator();

  public static final FunctionExpression_Name FunctionExpression_Name = new FunctionExpression_Name();

  public static final FunctionExpression_Params FunctionExpression_Params = new FunctionExpression_Params();

  public static final FunctionExpression_Body FunctionExpression_Body = new FunctionExpression_Body();

  public static final Getter_Name Getter_Name = new Getter_Name();

  public static final Getter_Body Getter_Body = new Getter_Body();

  public static final IdentifierExpression_Name IdentifierExpression_Name = new IdentifierExpression_Name();

  public static final IfStatement_Test IfStatement_Test = new IfStatement_Test();

  public static final IfStatement_Consequent IfStatement_Consequent = new IfStatement_Consequent();

  public static final IfStatement_Alternate IfStatement_Alternate = new IfStatement_Alternate();

  public static final Import_DefaultBinding Import_DefaultBinding = new Import_DefaultBinding();

  public static final Import_NamedImports Import_NamedImports = new Import_NamedImports();

  public static final Import_ModuleSpecifier Import_ModuleSpecifier = new Import_ModuleSpecifier();

  public static final ImportNamespace_DefaultBinding ImportNamespace_DefaultBinding = new ImportNamespace_DefaultBinding();

  public static final ImportNamespace_NamespaceBinding ImportNamespace_NamespaceBinding = new ImportNamespace_NamespaceBinding();

  public static final ImportNamespace_ModuleSpecifier ImportNamespace_ModuleSpecifier = new ImportNamespace_ModuleSpecifier();

  public static final ImportSpecifier_Name ImportSpecifier_Name = new ImportSpecifier_Name();

  public static final ImportSpecifier_Binding ImportSpecifier_Binding = new ImportSpecifier_Binding();

  public static final LabeledStatement_Label LabeledStatement_Label = new LabeledStatement_Label();

  public static final LabeledStatement_Body LabeledStatement_Body = new LabeledStatement_Body();

  public static final LiteralBooleanExpression_Value LiteralBooleanExpression_Value = new LiteralBooleanExpression_Value();

  public static final LiteralNumericExpression_Value LiteralNumericExpression_Value = new LiteralNumericExpression_Value();

  public static final LiteralRegExpExpression_Pattern LiteralRegExpExpression_Pattern = new LiteralRegExpExpression_Pattern();

  public static final LiteralRegExpExpression_Global LiteralRegExpExpression_Global = new LiteralRegExpExpression_Global();

  public static final LiteralRegExpExpression_IgnoreCase LiteralRegExpExpression_IgnoreCase = new LiteralRegExpExpression_IgnoreCase();

  public static final LiteralRegExpExpression_MultiLine LiteralRegExpExpression_MultiLine = new LiteralRegExpExpression_MultiLine();

  public static final LiteralRegExpExpression_DotAll LiteralRegExpExpression_DotAll = new LiteralRegExpExpression_DotAll();

  public static final LiteralRegExpExpression_Unicode LiteralRegExpExpression_Unicode = new LiteralRegExpExpression_Unicode();

  public static final LiteralRegExpExpression_Sticky LiteralRegExpExpression_Sticky = new LiteralRegExpExpression_Sticky();

  public static final LiteralStringExpression_Value LiteralStringExpression_Value = new LiteralStringExpression_Value();

  public static final Method_IsAsync Method_IsAsync = new Method_IsAsync();

  public static final Method_IsGenerator Method_IsGenerator = new Method_IsGenerator();

  public static final Method_Name Method_Name = new Method_Name();

  public static final Method_Params Method_Params = new Method_Params();

  public static final Method_Body Method_Body = new Method_Body();

  public static final Module_Directives Module_Directives = new Module_Directives();

  public static final Module_Items Module_Items = new Module_Items();

  public static final NewExpression_Callee NewExpression_Callee = new NewExpression_Callee();

  public static final NewExpression_Arguments NewExpression_Arguments = new NewExpression_Arguments();

  public static final ObjectAssignmentTarget_Properties ObjectAssignmentTarget_Properties = new ObjectAssignmentTarget_Properties();

  public static final ObjectAssignmentTarget_Rest ObjectAssignmentTarget_Rest = new ObjectAssignmentTarget_Rest();

  public static final ObjectBinding_Properties ObjectBinding_Properties = new ObjectBinding_Properties();

  public static final ObjectBinding_Rest ObjectBinding_Rest = new ObjectBinding_Rest();

  public static final ObjectExpression_Properties ObjectExpression_Properties = new ObjectExpression_Properties();

  public static final ReturnStatement_Expression ReturnStatement_Expression = new ReturnStatement_Expression();

  public static final Script_Directives Script_Directives = new Script_Directives();

  public static final Script_Statements Script_Statements = new Script_Statements();

  public static final Setter_Name Setter_Name = new Setter_Name();

  public static final Setter_Param Setter_Param = new Setter_Param();

  public static final Setter_Body Setter_Body = new Setter_Body();

  public static final ShorthandProperty_Name ShorthandProperty_Name = new ShorthandProperty_Name();

  public static final SpreadElement_Expression SpreadElement_Expression = new SpreadElement_Expression();

  public static final SpreadProperty_Expression SpreadProperty_Expression = new SpreadProperty_Expression();

  public static final StaticMemberAssignmentTarget_Object StaticMemberAssignmentTarget_Object = new StaticMemberAssignmentTarget_Object();

  public static final StaticMemberAssignmentTarget_Property StaticMemberAssignmentTarget_Property = new StaticMemberAssignmentTarget_Property();

  public static final StaticMemberExpression_Object StaticMemberExpression_Object = new StaticMemberExpression_Object();

  public static final StaticMemberExpression_Property StaticMemberExpression_Property = new StaticMemberExpression_Property();

  public static final StaticPropertyName_Value StaticPropertyName_Value = new StaticPropertyName_Value();

  public static final SwitchCase_Test SwitchCase_Test = new SwitchCase_Test();

  public static final SwitchCase_Consequent SwitchCase_Consequent = new SwitchCase_Consequent();

  public static final SwitchDefault_Consequent SwitchDefault_Consequent = new SwitchDefault_Consequent();

  public static final SwitchStatement_Discriminant SwitchStatement_Discriminant = new SwitchStatement_Discriminant();

  public static final SwitchStatement_Cases SwitchStatement_Cases = new SwitchStatement_Cases();

  public static final SwitchStatementWithDefault_Discriminant SwitchStatementWithDefault_Discriminant = new SwitchStatementWithDefault_Discriminant();

  public static final SwitchStatementWithDefault_PreDefaultCases SwitchStatementWithDefault_PreDefaultCases = new SwitchStatementWithDefault_PreDefaultCases();

  public static final SwitchStatementWithDefault_DefaultCase SwitchStatementWithDefault_DefaultCase = new SwitchStatementWithDefault_DefaultCase();

  public static final SwitchStatementWithDefault_PostDefaultCases SwitchStatementWithDefault_PostDefaultCases = new SwitchStatementWithDefault_PostDefaultCases();

  public static final TemplateElement_RawValue TemplateElement_RawValue = new TemplateElement_RawValue();

  public static final TemplateExpression_Tag TemplateExpression_Tag = new TemplateExpression_Tag();

  public static final TemplateExpression_Elements TemplateExpression_Elements = new TemplateExpression_Elements();

  public static final ThrowStatement_Expression ThrowStatement_Expression = new ThrowStatement_Expression();

  public static final TryCatchStatement_Body TryCatchStatement_Body = new TryCatchStatement_Body();

  public static final TryCatchStatement_CatchClause TryCatchStatement_CatchClause = new TryCatchStatement_CatchClause();

  public static final TryFinallyStatement_Body TryFinallyStatement_Body = new TryFinallyStatement_Body();

  public static final TryFinallyStatement_CatchClause TryFinallyStatement_CatchClause = new TryFinallyStatement_CatchClause();

  public static final TryFinallyStatement_Finalizer TryFinallyStatement_Finalizer = new TryFinallyStatement_Finalizer();

  public static final UnaryExpression_Operator UnaryExpression_Operator = new UnaryExpression_Operator();

  public static final UnaryExpression_Operand UnaryExpression_Operand = new UnaryExpression_Operand();

  public static final UpdateExpression_IsPrefix UpdateExpression_IsPrefix = new UpdateExpression_IsPrefix();

  public static final UpdateExpression_Operator UpdateExpression_Operator = new UpdateExpression_Operator();

  public static final UpdateExpression_Operand UpdateExpression_Operand = new UpdateExpression_Operand();

  public static final VariableDeclaration_Kind VariableDeclaration_Kind = new VariableDeclaration_Kind();

  public static final VariableDeclaration_Declarators VariableDeclaration_Declarators = new VariableDeclaration_Declarators();

  public static final VariableDeclarationStatement_Declaration VariableDeclarationStatement_Declaration = new VariableDeclarationStatement_Declaration();

  public static final VariableDeclarator_Binding VariableDeclarator_Binding = new VariableDeclarator_Binding();

  public static final VariableDeclarator_Init VariableDeclarator_Init = new VariableDeclarator_Init();

  public static final WhileStatement_Test WhileStatement_Test = new WhileStatement_Test();

  public static final WhileStatement_Body WhileStatement_Body = new WhileStatement_Body();

  public static final WithStatement_Object WithStatement_Object = new WithStatement_Object();

  public static final WithStatement_Body WithStatement_Body = new WithStatement_Body();

  public static final YieldExpression_Expression YieldExpression_Expression = new YieldExpression_Expression();

  public static final YieldGeneratorExpression_Expression YieldGeneratorExpression_Expression = new YieldGeneratorExpression_Expression();



  public static class ArrayAssignmentTarget_Elements extends ASTPath<ArrayAssignmentTarget, ImmutableList<Maybe<AssignmentTargetAssignmentTargetWithDefault>>> {
    private ArrayAssignmentTarget_Elements() {}

    @Override
    public Maybe<ImmutableList<Maybe<AssignmentTargetAssignmentTargetWithDefault>>> apply(Object source) {
      if (!(source instanceof ArrayAssignmentTarget)) return Maybe.empty();
      return Maybe.of(((ArrayAssignmentTarget) source).elements);
    }

    public String propertyName() {
      return "elements";
    }
  }

  public static class ArrayAssignmentTarget_Rest extends ASTPath<ArrayAssignmentTarget, Maybe<AssignmentTarget>> {
    private ArrayAssignmentTarget_Rest() {}

    @Override
    public Maybe<Maybe<AssignmentTarget>> apply(Object source) {
      if (!(source instanceof ArrayAssignmentTarget)) return Maybe.empty();
      return Maybe.of(((ArrayAssignmentTarget) source).rest);
    }

    public String propertyName() {
      return "rest";
    }
  }

  public static class ArrayBinding_Elements extends ASTPath<ArrayBinding, ImmutableList<Maybe<BindingBindingWithDefault>>> {
    private ArrayBinding_Elements() {}

    @Override
    public Maybe<ImmutableList<Maybe<BindingBindingWithDefault>>> apply(Object source) {
      if (!(source instanceof ArrayBinding)) return Maybe.empty();
      return Maybe.of(((ArrayBinding) source).elements);
    }

    public String propertyName() {
      return "elements";
    }
  }

  public static class ArrayBinding_Rest extends ASTPath<ArrayBinding, Maybe<Binding>> {
    private ArrayBinding_Rest() {}

    @Override
    public Maybe<Maybe<Binding>> apply(Object source) {
      if (!(source instanceof ArrayBinding)) return Maybe.empty();
      return Maybe.of(((ArrayBinding) source).rest);
    }

    public String propertyName() {
      return "rest";
    }
  }

  public static class ArrayExpression_Elements extends ASTPath<ArrayExpression, ImmutableList<Maybe<SpreadElementExpression>>> {
    private ArrayExpression_Elements() {}

    @Override
    public Maybe<ImmutableList<Maybe<SpreadElementExpression>>> apply(Object source) {
      if (!(source instanceof ArrayExpression)) return Maybe.empty();
      return Maybe.of(((ArrayExpression) source).elements);
    }

    public String propertyName() {
      return "elements";
    }
  }

  public static class ArrowExpression_IsAsync extends ASTPath<ArrowExpression, Boolean> {
    private ArrowExpression_IsAsync() {}

    @Override
    public Maybe<Boolean> apply(Object source) {
      if (!(source instanceof ArrowExpression)) return Maybe.empty();
      return Maybe.of(((ArrowExpression) source).isAsync);
    }

    public String propertyName() {
      return "isAsync";
    }
  }

  public static class ArrowExpression_Params extends ASTPath<ArrowExpression, FormalParameters> {
    private ArrowExpression_Params() {}

    @Override
    public Maybe<FormalParameters> apply(Object source) {
      if (!(source instanceof ArrowExpression)) return Maybe.empty();
      return Maybe.of(((ArrowExpression) source).params);
    }

    public String propertyName() {
      return "params";
    }
  }

  public static class ArrowExpression_Body extends ASTPath<ArrowExpression, FunctionBodyExpression> {
    private ArrowExpression_Body() {}

    @Override
    public Maybe<FunctionBodyExpression> apply(Object source) {
      if (!(source instanceof ArrowExpression)) return Maybe.empty();
      return Maybe.of(((ArrowExpression) source).body);
    }

    public String propertyName() {
      return "body";
    }
  }

  public static class AssignmentExpression_Binding extends ASTPath<AssignmentExpression, AssignmentTarget> {
    private AssignmentExpression_Binding() {}

    @Override
    public Maybe<AssignmentTarget> apply(Object source) {
      if (!(source instanceof AssignmentExpression)) return Maybe.empty();
      return Maybe.of(((AssignmentExpression) source).binding);
    }

    public String propertyName() {
      return "binding";
    }
  }

  public static class AssignmentExpression_Expression extends ASTPath<AssignmentExpression, Expression> {
    private AssignmentExpression_Expression() {}

    @Override
    public Maybe<Expression> apply(Object source) {
      if (!(source instanceof AssignmentExpression)) return Maybe.empty();
      return Maybe.of(((AssignmentExpression) source).expression);
    }

    public String propertyName() {
      return "expression";
    }
  }

  public static class AssignmentTargetIdentifier_Name extends ASTPath<AssignmentTargetIdentifier, String> {
    private AssignmentTargetIdentifier_Name() {}

    @Override
    public Maybe<String> apply(Object source) {
      if (!(source instanceof AssignmentTargetIdentifier)) return Maybe.empty();
      return Maybe.of(((AssignmentTargetIdentifier) source).name);
    }

    public String propertyName() {
      return "name";
    }
  }

  public static class AssignmentTargetPropertyIdentifier_Binding extends ASTPath<AssignmentTargetPropertyIdentifier, AssignmentTargetIdentifier> {
    private AssignmentTargetPropertyIdentifier_Binding() {}

    @Override
    public Maybe<AssignmentTargetIdentifier> apply(Object source) {
      if (!(source instanceof AssignmentTargetPropertyIdentifier)) return Maybe.empty();
      return Maybe.of(((AssignmentTargetPropertyIdentifier) source).binding);
    }

    public String propertyName() {
      return "binding";
    }
  }

  public static class AssignmentTargetPropertyIdentifier_Init extends ASTPath<AssignmentTargetPropertyIdentifier, Maybe<Expression>> {
    private AssignmentTargetPropertyIdentifier_Init() {}

    @Override
    public Maybe<Maybe<Expression>> apply(Object source) {
      if (!(source instanceof AssignmentTargetPropertyIdentifier)) return Maybe.empty();
      return Maybe.of(((AssignmentTargetPropertyIdentifier) source).init);
    }

    public String propertyName() {
      return "init";
    }
  }

  public static class AssignmentTargetPropertyProperty_Name extends ASTPath<AssignmentTargetPropertyProperty, PropertyName> {
    private AssignmentTargetPropertyProperty_Name() {}

    @Override
    public Maybe<PropertyName> apply(Object source) {
      if (!(source instanceof AssignmentTargetPropertyProperty)) return Maybe.empty();
      return Maybe.of(((AssignmentTargetPropertyProperty) source).name);
    }

    public String propertyName() {
      return "name";
    }
  }

  public static class AssignmentTargetPropertyProperty_Binding extends ASTPath<AssignmentTargetPropertyProperty, AssignmentTargetAssignmentTargetWithDefault> {
    private AssignmentTargetPropertyProperty_Binding() {}

    @Override
    public Maybe<AssignmentTargetAssignmentTargetWithDefault> apply(Object source) {
      if (!(source instanceof AssignmentTargetPropertyProperty)) return Maybe.empty();
      return Maybe.of(((AssignmentTargetPropertyProperty) source).binding);
    }

    public String propertyName() {
      return "binding";
    }
  }

  public static class AssignmentTargetWithDefault_Binding extends ASTPath<AssignmentTargetWithDefault, AssignmentTarget> {
    private AssignmentTargetWithDefault_Binding() {}

    @Override
    public Maybe<AssignmentTarget> apply(Object source) {
      if (!(source instanceof AssignmentTargetWithDefault)) return Maybe.empty();
      return Maybe.of(((AssignmentTargetWithDefault) source).binding);
    }

    public String propertyName() {
      return "binding";
    }
  }

  public static class AssignmentTargetWithDefault_Init extends ASTPath<AssignmentTargetWithDefault, Expression> {
    private AssignmentTargetWithDefault_Init() {}

    @Override
    public Maybe<Expression> apply(Object source) {
      if (!(source instanceof AssignmentTargetWithDefault)) return Maybe.empty();
      return Maybe.of(((AssignmentTargetWithDefault) source).init);
    }

    public String propertyName() {
      return "init";
    }
  }

  public static class AwaitExpression_Expression extends ASTPath<AwaitExpression, Expression> {
    private AwaitExpression_Expression() {}

    @Override
    public Maybe<Expression> apply(Object source) {
      if (!(source instanceof AwaitExpression)) return Maybe.empty();
      return Maybe.of(((AwaitExpression) source).expression);
    }

    public String propertyName() {
      return "expression";
    }
  }

  public static class BinaryExpression_Left extends ASTPath<BinaryExpression, Expression> {
    private BinaryExpression_Left() {}

    @Override
    public Maybe<Expression> apply(Object source) {
      if (!(source instanceof BinaryExpression)) return Maybe.empty();
      return Maybe.of(((BinaryExpression) source).left);
    }

    public String propertyName() {
      return "left";
    }
  }

  public static class BinaryExpression_Operator extends ASTPath<BinaryExpression, com.shapesecurity.shift.es2018.ast.operators.BinaryOperator> {
    private BinaryExpression_Operator() {}

    @Override
    public Maybe<com.shapesecurity.shift.es2018.ast.operators.BinaryOperator> apply(Object source) {
      if (!(source instanceof BinaryExpression)) return Maybe.empty();
      return Maybe.of(((BinaryExpression) source).operator);
    }

    public String propertyName() {
      return "operator";
    }
  }

  public static class BinaryExpression_Right extends ASTPath<BinaryExpression, Expression> {
    private BinaryExpression_Right() {}

    @Override
    public Maybe<Expression> apply(Object source) {
      if (!(source instanceof BinaryExpression)) return Maybe.empty();
      return Maybe.of(((BinaryExpression) source).right);
    }

    public String propertyName() {
      return "right";
    }
  }

  public static class BindingIdentifier_Name extends ASTPath<BindingIdentifier, String> {
    private BindingIdentifier_Name() {}

    @Override
    public Maybe<String> apply(Object source) {
      if (!(source instanceof BindingIdentifier)) return Maybe.empty();
      return Maybe.of(((BindingIdentifier) source).name);
    }

    public String propertyName() {
      return "name";
    }
  }

  public static class BindingPropertyIdentifier_Binding extends ASTPath<BindingPropertyIdentifier, BindingIdentifier> {
    private BindingPropertyIdentifier_Binding() {}

    @Override
    public Maybe<BindingIdentifier> apply(Object source) {
      if (!(source instanceof BindingPropertyIdentifier)) return Maybe.empty();
      return Maybe.of(((BindingPropertyIdentifier) source).binding);
    }

    public String propertyName() {
      return "binding";
    }
  }

  public static class BindingPropertyIdentifier_Init extends ASTPath<BindingPropertyIdentifier, Maybe<Expression>> {
    private BindingPropertyIdentifier_Init() {}

    @Override
    public Maybe<Maybe<Expression>> apply(Object source) {
      if (!(source instanceof BindingPropertyIdentifier)) return Maybe.empty();
      return Maybe.of(((BindingPropertyIdentifier) source).init);
    }

    public String propertyName() {
      return "init";
    }
  }

  public static class BindingPropertyProperty_Name extends ASTPath<BindingPropertyProperty, PropertyName> {
    private BindingPropertyProperty_Name() {}

    @Override
    public Maybe<PropertyName> apply(Object source) {
      if (!(source instanceof BindingPropertyProperty)) return Maybe.empty();
      return Maybe.of(((BindingPropertyProperty) source).name);
    }

    public String propertyName() {
      return "name";
    }
  }

  public static class BindingPropertyProperty_Binding extends ASTPath<BindingPropertyProperty, BindingBindingWithDefault> {
    private BindingPropertyProperty_Binding() {}

    @Override
    public Maybe<BindingBindingWithDefault> apply(Object source) {
      if (!(source instanceof BindingPropertyProperty)) return Maybe.empty();
      return Maybe.of(((BindingPropertyProperty) source).binding);
    }

    public String propertyName() {
      return "binding";
    }
  }

  public static class BindingWithDefault_Binding extends ASTPath<BindingWithDefault, Binding> {
    private BindingWithDefault_Binding() {}

    @Override
    public Maybe<Binding> apply(Object source) {
      if (!(source instanceof BindingWithDefault)) return Maybe.empty();
      return Maybe.of(((BindingWithDefault) source).binding);
    }

    public String propertyName() {
      return "binding";
    }
  }

  public static class BindingWithDefault_Init extends ASTPath<BindingWithDefault, Expression> {
    private BindingWithDefault_Init() {}

    @Override
    public Maybe<Expression> apply(Object source) {
      if (!(source instanceof BindingWithDefault)) return Maybe.empty();
      return Maybe.of(((BindingWithDefault) source).init);
    }

    public String propertyName() {
      return "init";
    }
  }

  public static class Block_Statements extends ASTPath<Block, ImmutableList<Statement>> {
    private Block_Statements() {}

    @Override
    public Maybe<ImmutableList<Statement>> apply(Object source) {
      if (!(source instanceof Block)) return Maybe.empty();
      return Maybe.of(((Block) source).statements);
    }

    public String propertyName() {
      return "statements";
    }
  }

  public static class BlockStatement_Block extends ASTPath<BlockStatement, Block> {
    private BlockStatement_Block() {}

    @Override
    public Maybe<Block> apply(Object source) {
      if (!(source instanceof BlockStatement)) return Maybe.empty();
      return Maybe.of(((BlockStatement) source).block);
    }

    public String propertyName() {
      return "block";
    }
  }

  public static class BreakStatement_Label extends ASTPath<BreakStatement, Maybe<String>> {
    private BreakStatement_Label() {}

    @Override
    public Maybe<Maybe<String>> apply(Object source) {
      if (!(source instanceof BreakStatement)) return Maybe.empty();
      return Maybe.of(((BreakStatement) source).label);
    }

    public String propertyName() {
      return "label";
    }
  }

  public static class CallExpression_Callee extends ASTPath<CallExpression, ExpressionSuper> {
    private CallExpression_Callee() {}

    @Override
    public Maybe<ExpressionSuper> apply(Object source) {
      if (!(source instanceof CallExpression)) return Maybe.empty();
      return Maybe.of(((CallExpression) source).callee);
    }

    public String propertyName() {
      return "callee";
    }
  }

  public static class CallExpression_Arguments extends ASTPath<CallExpression, ImmutableList<SpreadElementExpression>> {
    private CallExpression_Arguments() {}

    @Override
    public Maybe<ImmutableList<SpreadElementExpression>> apply(Object source) {
      if (!(source instanceof CallExpression)) return Maybe.empty();
      return Maybe.of(((CallExpression) source).arguments);
    }

    public String propertyName() {
      return "arguments";
    }
  }

  public static class CatchClause_Binding extends ASTPath<CatchClause, Binding> {
    private CatchClause_Binding() {}

    @Override
    public Maybe<Binding> apply(Object source) {
      if (!(source instanceof CatchClause)) return Maybe.empty();
      return Maybe.of(((CatchClause) source).binding);
    }

    public String propertyName() {
      return "binding";
    }
  }

  public static class CatchClause_Body extends ASTPath<CatchClause, Block> {
    private CatchClause_Body() {}

    @Override
    public Maybe<Block> apply(Object source) {
      if (!(source instanceof CatchClause)) return Maybe.empty();
      return Maybe.of(((CatchClause) source).body);
    }

    public String propertyName() {
      return "body";
    }
  }

  public static class ClassDeclaration_Name extends ASTPath<ClassDeclaration, BindingIdentifier> {
    private ClassDeclaration_Name() {}

    @Override
    public Maybe<BindingIdentifier> apply(Object source) {
      if (!(source instanceof ClassDeclaration)) return Maybe.empty();
      return Maybe.of(((ClassDeclaration) source).name);
    }

    public String propertyName() {
      return "name";
    }
  }

  public static class ClassDeclaration_Super extends ASTPath<ClassDeclaration, Maybe<Expression>> {
    private ClassDeclaration_Super() {}

    @Override
    public Maybe<Maybe<Expression>> apply(Object source) {
      if (!(source instanceof ClassDeclaration)) return Maybe.empty();
      return Maybe.of(((ClassDeclaration) source)._super);
    }

    public String propertyName() {
      return "super";
    }
  }

  public static class ClassDeclaration_Elements extends ASTPath<ClassDeclaration, ImmutableList<ClassElement>> {
    private ClassDeclaration_Elements() {}

    @Override
    public Maybe<ImmutableList<ClassElement>> apply(Object source) {
      if (!(source instanceof ClassDeclaration)) return Maybe.empty();
      return Maybe.of(((ClassDeclaration) source).elements);
    }

    public String propertyName() {
      return "elements";
    }
  }

  public static class ClassElement_IsStatic extends ASTPath<ClassElement, Boolean> {
    private ClassElement_IsStatic() {}

    @Override
    public Maybe<Boolean> apply(Object source) {
      if (!(source instanceof ClassElement)) return Maybe.empty();
      return Maybe.of(((ClassElement) source).isStatic);
    }

    public String propertyName() {
      return "isStatic";
    }
  }

  public static class ClassElement_Method extends ASTPath<ClassElement, MethodDefinition> {
    private ClassElement_Method() {}

    @Override
    public Maybe<MethodDefinition> apply(Object source) {
      if (!(source instanceof ClassElement)) return Maybe.empty();
      return Maybe.of(((ClassElement) source).method);
    }

    public String propertyName() {
      return "method";
    }
  }

  public static class ClassExpression_Name extends ASTPath<ClassExpression, Maybe<BindingIdentifier>> {
    private ClassExpression_Name() {}

    @Override
    public Maybe<Maybe<BindingIdentifier>> apply(Object source) {
      if (!(source instanceof ClassExpression)) return Maybe.empty();
      return Maybe.of(((ClassExpression) source).name);
    }

    public String propertyName() {
      return "name";
    }
  }

  public static class ClassExpression_Super extends ASTPath<ClassExpression, Maybe<Expression>> {
    private ClassExpression_Super() {}

    @Override
    public Maybe<Maybe<Expression>> apply(Object source) {
      if (!(source instanceof ClassExpression)) return Maybe.empty();
      return Maybe.of(((ClassExpression) source)._super);
    }

    public String propertyName() {
      return "super";
    }
  }

  public static class ClassExpression_Elements extends ASTPath<ClassExpression, ImmutableList<ClassElement>> {
    private ClassExpression_Elements() {}

    @Override
    public Maybe<ImmutableList<ClassElement>> apply(Object source) {
      if (!(source instanceof ClassExpression)) return Maybe.empty();
      return Maybe.of(((ClassExpression) source).elements);
    }

    public String propertyName() {
      return "elements";
    }
  }

  public static class CompoundAssignmentExpression_Binding extends ASTPath<CompoundAssignmentExpression, SimpleAssignmentTarget> {
    private CompoundAssignmentExpression_Binding() {}

    @Override
    public Maybe<SimpleAssignmentTarget> apply(Object source) {
      if (!(source instanceof CompoundAssignmentExpression)) return Maybe.empty();
      return Maybe.of(((CompoundAssignmentExpression) source).binding);
    }

    public String propertyName() {
      return "binding";
    }
  }

  public static class CompoundAssignmentExpression_Operator extends ASTPath<CompoundAssignmentExpression, com.shapesecurity.shift.es2018.ast.operators.CompoundAssignmentOperator> {
    private CompoundAssignmentExpression_Operator() {}

    @Override
    public Maybe<com.shapesecurity.shift.es2018.ast.operators.CompoundAssignmentOperator> apply(Object source) {
      if (!(source instanceof CompoundAssignmentExpression)) return Maybe.empty();
      return Maybe.of(((CompoundAssignmentExpression) source).operator);
    }

    public String propertyName() {
      return "operator";
    }
  }

  public static class CompoundAssignmentExpression_Expression extends ASTPath<CompoundAssignmentExpression, Expression> {
    private CompoundAssignmentExpression_Expression() {}

    @Override
    public Maybe<Expression> apply(Object source) {
      if (!(source instanceof CompoundAssignmentExpression)) return Maybe.empty();
      return Maybe.of(((CompoundAssignmentExpression) source).expression);
    }

    public String propertyName() {
      return "expression";
    }
  }

  public static class ComputedMemberAssignmentTarget_Object extends ASTPath<ComputedMemberAssignmentTarget, ExpressionSuper> {
    private ComputedMemberAssignmentTarget_Object() {}

    @Override
    public Maybe<ExpressionSuper> apply(Object source) {
      if (!(source instanceof ComputedMemberAssignmentTarget)) return Maybe.empty();
      return Maybe.of(((ComputedMemberAssignmentTarget) source).object);
    }

    public String propertyName() {
      return "object";
    }
  }

  public static class ComputedMemberAssignmentTarget_Expression extends ASTPath<ComputedMemberAssignmentTarget, Expression> {
    private ComputedMemberAssignmentTarget_Expression() {}

    @Override
    public Maybe<Expression> apply(Object source) {
      if (!(source instanceof ComputedMemberAssignmentTarget)) return Maybe.empty();
      return Maybe.of(((ComputedMemberAssignmentTarget) source).expression);
    }

    public String propertyName() {
      return "expression";
    }
  }

  public static class ComputedMemberExpression_Object extends ASTPath<ComputedMemberExpression, ExpressionSuper> {
    private ComputedMemberExpression_Object() {}

    @Override
    public Maybe<ExpressionSuper> apply(Object source) {
      if (!(source instanceof ComputedMemberExpression)) return Maybe.empty();
      return Maybe.of(((ComputedMemberExpression) source).object);
    }

    public String propertyName() {
      return "object";
    }
  }

  public static class ComputedMemberExpression_Expression extends ASTPath<ComputedMemberExpression, Expression> {
    private ComputedMemberExpression_Expression() {}

    @Override
    public Maybe<Expression> apply(Object source) {
      if (!(source instanceof ComputedMemberExpression)) return Maybe.empty();
      return Maybe.of(((ComputedMemberExpression) source).expression);
    }

    public String propertyName() {
      return "expression";
    }
  }

  public static class ComputedPropertyName_Expression extends ASTPath<ComputedPropertyName, Expression> {
    private ComputedPropertyName_Expression() {}

    @Override
    public Maybe<Expression> apply(Object source) {
      if (!(source instanceof ComputedPropertyName)) return Maybe.empty();
      return Maybe.of(((ComputedPropertyName) source).expression);
    }

    public String propertyName() {
      return "expression";
    }
  }

  public static class ConditionalExpression_Test extends ASTPath<ConditionalExpression, Expression> {
    private ConditionalExpression_Test() {}

    @Override
    public Maybe<Expression> apply(Object source) {
      if (!(source instanceof ConditionalExpression)) return Maybe.empty();
      return Maybe.of(((ConditionalExpression) source).test);
    }

    public String propertyName() {
      return "test";
    }
  }

  public static class ConditionalExpression_Consequent extends ASTPath<ConditionalExpression, Expression> {
    private ConditionalExpression_Consequent() {}

    @Override
    public Maybe<Expression> apply(Object source) {
      if (!(source instanceof ConditionalExpression)) return Maybe.empty();
      return Maybe.of(((ConditionalExpression) source).consequent);
    }

    public String propertyName() {
      return "consequent";
    }
  }

  public static class ConditionalExpression_Alternate extends ASTPath<ConditionalExpression, Expression> {
    private ConditionalExpression_Alternate() {}

    @Override
    public Maybe<Expression> apply(Object source) {
      if (!(source instanceof ConditionalExpression)) return Maybe.empty();
      return Maybe.of(((ConditionalExpression) source).alternate);
    }

    public String propertyName() {
      return "alternate";
    }
  }

  public static class ContinueStatement_Label extends ASTPath<ContinueStatement, Maybe<String>> {
    private ContinueStatement_Label() {}

    @Override
    public Maybe<Maybe<String>> apply(Object source) {
      if (!(source instanceof ContinueStatement)) return Maybe.empty();
      return Maybe.of(((ContinueStatement) source).label);
    }

    public String propertyName() {
      return "label";
    }
  }

  public static class DataProperty_Name extends ASTPath<DataProperty, PropertyName> {
    private DataProperty_Name() {}

    @Override
    public Maybe<PropertyName> apply(Object source) {
      if (!(source instanceof DataProperty)) return Maybe.empty();
      return Maybe.of(((DataProperty) source).name);
    }

    public String propertyName() {
      return "name";
    }
  }

  public static class DataProperty_Expression extends ASTPath<DataProperty, Expression> {
    private DataProperty_Expression() {}

    @Override
    public Maybe<Expression> apply(Object source) {
      if (!(source instanceof DataProperty)) return Maybe.empty();
      return Maybe.of(((DataProperty) source).expression);
    }

    public String propertyName() {
      return "expression";
    }
  }

  public static class Directive_RawValue extends ASTPath<Directive, String> {
    private Directive_RawValue() {}

    @Override
    public Maybe<String> apply(Object source) {
      if (!(source instanceof Directive)) return Maybe.empty();
      return Maybe.of(((Directive) source).rawValue);
    }

    public String propertyName() {
      return "rawValue";
    }
  }

  public static class DoWhileStatement_Body extends ASTPath<DoWhileStatement, Statement> {
    private DoWhileStatement_Body() {}

    @Override
    public Maybe<Statement> apply(Object source) {
      if (!(source instanceof DoWhileStatement)) return Maybe.empty();
      return Maybe.of(((DoWhileStatement) source).body);
    }

    public String propertyName() {
      return "body";
    }
  }

  public static class DoWhileStatement_Test extends ASTPath<DoWhileStatement, Expression> {
    private DoWhileStatement_Test() {}

    @Override
    public Maybe<Expression> apply(Object source) {
      if (!(source instanceof DoWhileStatement)) return Maybe.empty();
      return Maybe.of(((DoWhileStatement) source).test);
    }

    public String propertyName() {
      return "test";
    }
  }

  public static class Export_Declaration extends ASTPath<Export, FunctionDeclarationClassDeclarationVariableDeclaration> {
    private Export_Declaration() {}

    @Override
    public Maybe<FunctionDeclarationClassDeclarationVariableDeclaration> apply(Object source) {
      if (!(source instanceof Export)) return Maybe.empty();
      return Maybe.of(((Export) source).declaration);
    }

    public String propertyName() {
      return "declaration";
    }
  }

  public static class ExportAllFrom_ModuleSpecifier extends ASTPath<ExportAllFrom, String> {
    private ExportAllFrom_ModuleSpecifier() {}

    @Override
    public Maybe<String> apply(Object source) {
      if (!(source instanceof ExportAllFrom)) return Maybe.empty();
      return Maybe.of(((ExportAllFrom) source).moduleSpecifier);
    }

    public String propertyName() {
      return "moduleSpecifier";
    }
  }

  public static class ExportDefault_Body extends ASTPath<ExportDefault, FunctionDeclarationClassDeclarationExpression> {
    private ExportDefault_Body() {}

    @Override
    public Maybe<FunctionDeclarationClassDeclarationExpression> apply(Object source) {
      if (!(source instanceof ExportDefault)) return Maybe.empty();
      return Maybe.of(((ExportDefault) source).body);
    }

    public String propertyName() {
      return "body";
    }
  }

  public static class ExportFrom_NamedExports extends ASTPath<ExportFrom, ImmutableList<ExportFromSpecifier>> {
    private ExportFrom_NamedExports() {}

    @Override
    public Maybe<ImmutableList<ExportFromSpecifier>> apply(Object source) {
      if (!(source instanceof ExportFrom)) return Maybe.empty();
      return Maybe.of(((ExportFrom) source).namedExports);
    }

    public String propertyName() {
      return "namedExports";
    }
  }

  public static class ExportFrom_ModuleSpecifier extends ASTPath<ExportFrom, String> {
    private ExportFrom_ModuleSpecifier() {}

    @Override
    public Maybe<String> apply(Object source) {
      if (!(source instanceof ExportFrom)) return Maybe.empty();
      return Maybe.of(((ExportFrom) source).moduleSpecifier);
    }

    public String propertyName() {
      return "moduleSpecifier";
    }
  }

  public static class ExportFromSpecifier_Name extends ASTPath<ExportFromSpecifier, String> {
    private ExportFromSpecifier_Name() {}

    @Override
    public Maybe<String> apply(Object source) {
      if (!(source instanceof ExportFromSpecifier)) return Maybe.empty();
      return Maybe.of(((ExportFromSpecifier) source).name);
    }

    public String propertyName() {
      return "name";
    }
  }

  public static class ExportFromSpecifier_ExportedName extends ASTPath<ExportFromSpecifier, Maybe<String>> {
    private ExportFromSpecifier_ExportedName() {}

    @Override
    public Maybe<Maybe<String>> apply(Object source) {
      if (!(source instanceof ExportFromSpecifier)) return Maybe.empty();
      return Maybe.of(((ExportFromSpecifier) source).exportedName);
    }

    public String propertyName() {
      return "exportedName";
    }
  }

  public static class ExportLocalSpecifier_Name extends ASTPath<ExportLocalSpecifier, IdentifierExpression> {
    private ExportLocalSpecifier_Name() {}

    @Override
    public Maybe<IdentifierExpression> apply(Object source) {
      if (!(source instanceof ExportLocalSpecifier)) return Maybe.empty();
      return Maybe.of(((ExportLocalSpecifier) source).name);
    }

    public String propertyName() {
      return "name";
    }
  }

  public static class ExportLocalSpecifier_ExportedName extends ASTPath<ExportLocalSpecifier, Maybe<String>> {
    private ExportLocalSpecifier_ExportedName() {}

    @Override
    public Maybe<Maybe<String>> apply(Object source) {
      if (!(source instanceof ExportLocalSpecifier)) return Maybe.empty();
      return Maybe.of(((ExportLocalSpecifier) source).exportedName);
    }

    public String propertyName() {
      return "exportedName";
    }
  }

  public static class ExportLocals_NamedExports extends ASTPath<ExportLocals, ImmutableList<ExportLocalSpecifier>> {
    private ExportLocals_NamedExports() {}

    @Override
    public Maybe<ImmutableList<ExportLocalSpecifier>> apply(Object source) {
      if (!(source instanceof ExportLocals)) return Maybe.empty();
      return Maybe.of(((ExportLocals) source).namedExports);
    }

    public String propertyName() {
      return "namedExports";
    }
  }

  public static class ExpressionStatement_Expression extends ASTPath<ExpressionStatement, Expression> {
    private ExpressionStatement_Expression() {}

    @Override
    public Maybe<Expression> apply(Object source) {
      if (!(source instanceof ExpressionStatement)) return Maybe.empty();
      return Maybe.of(((ExpressionStatement) source).expression);
    }

    public String propertyName() {
      return "expression";
    }
  }

  public static class ForAwaitStatement_Left extends ASTPath<ForAwaitStatement, VariableDeclarationAssignmentTarget> {
    private ForAwaitStatement_Left() {}

    @Override
    public Maybe<VariableDeclarationAssignmentTarget> apply(Object source) {
      if (!(source instanceof ForAwaitStatement)) return Maybe.empty();
      return Maybe.of(((ForAwaitStatement) source).left);
    }

    public String propertyName() {
      return "left";
    }
  }

  public static class ForAwaitStatement_Right extends ASTPath<ForAwaitStatement, Expression> {
    private ForAwaitStatement_Right() {}

    @Override
    public Maybe<Expression> apply(Object source) {
      if (!(source instanceof ForAwaitStatement)) return Maybe.empty();
      return Maybe.of(((ForAwaitStatement) source).right);
    }

    public String propertyName() {
      return "right";
    }
  }

  public static class ForAwaitStatement_Body extends ASTPath<ForAwaitStatement, Statement> {
    private ForAwaitStatement_Body() {}

    @Override
    public Maybe<Statement> apply(Object source) {
      if (!(source instanceof ForAwaitStatement)) return Maybe.empty();
      return Maybe.of(((ForAwaitStatement) source).body);
    }

    public String propertyName() {
      return "body";
    }
  }

  public static class ForInStatement_Left extends ASTPath<ForInStatement, VariableDeclarationAssignmentTarget> {
    private ForInStatement_Left() {}

    @Override
    public Maybe<VariableDeclarationAssignmentTarget> apply(Object source) {
      if (!(source instanceof ForInStatement)) return Maybe.empty();
      return Maybe.of(((ForInStatement) source).left);
    }

    public String propertyName() {
      return "left";
    }
  }

  public static class ForInStatement_Right extends ASTPath<ForInStatement, Expression> {
    private ForInStatement_Right() {}

    @Override
    public Maybe<Expression> apply(Object source) {
      if (!(source instanceof ForInStatement)) return Maybe.empty();
      return Maybe.of(((ForInStatement) source).right);
    }

    public String propertyName() {
      return "right";
    }
  }

  public static class ForInStatement_Body extends ASTPath<ForInStatement, Statement> {
    private ForInStatement_Body() {}

    @Override
    public Maybe<Statement> apply(Object source) {
      if (!(source instanceof ForInStatement)) return Maybe.empty();
      return Maybe.of(((ForInStatement) source).body);
    }

    public String propertyName() {
      return "body";
    }
  }

  public static class ForOfStatement_Left extends ASTPath<ForOfStatement, VariableDeclarationAssignmentTarget> {
    private ForOfStatement_Left() {}

    @Override
    public Maybe<VariableDeclarationAssignmentTarget> apply(Object source) {
      if (!(source instanceof ForOfStatement)) return Maybe.empty();
      return Maybe.of(((ForOfStatement) source).left);
    }

    public String propertyName() {
      return "left";
    }
  }

  public static class ForOfStatement_Right extends ASTPath<ForOfStatement, Expression> {
    private ForOfStatement_Right() {}

    @Override
    public Maybe<Expression> apply(Object source) {
      if (!(source instanceof ForOfStatement)) return Maybe.empty();
      return Maybe.of(((ForOfStatement) source).right);
    }

    public String propertyName() {
      return "right";
    }
  }

  public static class ForOfStatement_Body extends ASTPath<ForOfStatement, Statement> {
    private ForOfStatement_Body() {}

    @Override
    public Maybe<Statement> apply(Object source) {
      if (!(source instanceof ForOfStatement)) return Maybe.empty();
      return Maybe.of(((ForOfStatement) source).body);
    }

    public String propertyName() {
      return "body";
    }
  }

  public static class ForStatement_Init extends ASTPath<ForStatement, Maybe<VariableDeclarationExpression>> {
    private ForStatement_Init() {}

    @Override
    public Maybe<Maybe<VariableDeclarationExpression>> apply(Object source) {
      if (!(source instanceof ForStatement)) return Maybe.empty();
      return Maybe.of(((ForStatement) source).init);
    }

    public String propertyName() {
      return "init";
    }
  }

  public static class ForStatement_Test extends ASTPath<ForStatement, Maybe<Expression>> {
    private ForStatement_Test() {}

    @Override
    public Maybe<Maybe<Expression>> apply(Object source) {
      if (!(source instanceof ForStatement)) return Maybe.empty();
      return Maybe.of(((ForStatement) source).test);
    }

    public String propertyName() {
      return "test";
    }
  }

  public static class ForStatement_Update extends ASTPath<ForStatement, Maybe<Expression>> {
    private ForStatement_Update() {}

    @Override
    public Maybe<Maybe<Expression>> apply(Object source) {
      if (!(source instanceof ForStatement)) return Maybe.empty();
      return Maybe.of(((ForStatement) source).update);
    }

    public String propertyName() {
      return "update";
    }
  }

  public static class ForStatement_Body extends ASTPath<ForStatement, Statement> {
    private ForStatement_Body() {}

    @Override
    public Maybe<Statement> apply(Object source) {
      if (!(source instanceof ForStatement)) return Maybe.empty();
      return Maybe.of(((ForStatement) source).body);
    }

    public String propertyName() {
      return "body";
    }
  }

  public static class FormalParameters_Items extends ASTPath<FormalParameters, ImmutableList<Parameter>> {
    private FormalParameters_Items() {}

    @Override
    public Maybe<ImmutableList<Parameter>> apply(Object source) {
      if (!(source instanceof FormalParameters)) return Maybe.empty();
      return Maybe.of(((FormalParameters) source).items);
    }

    public String propertyName() {
      return "items";
    }
  }

  public static class FormalParameters_Rest extends ASTPath<FormalParameters, Maybe<Binding>> {
    private FormalParameters_Rest() {}

    @Override
    public Maybe<Maybe<Binding>> apply(Object source) {
      if (!(source instanceof FormalParameters)) return Maybe.empty();
      return Maybe.of(((FormalParameters) source).rest);
    }

    public String propertyName() {
      return "rest";
    }
  }

  public static class FunctionBody_Directives extends ASTPath<FunctionBody, ImmutableList<Directive>> {
    private FunctionBody_Directives() {}

    @Override
    public Maybe<ImmutableList<Directive>> apply(Object source) {
      if (!(source instanceof FunctionBody)) return Maybe.empty();
      return Maybe.of(((FunctionBody) source).directives);
    }

    public String propertyName() {
      return "directives";
    }
  }

  public static class FunctionBody_Statements extends ASTPath<FunctionBody, ImmutableList<Statement>> {
    private FunctionBody_Statements() {}

    @Override
    public Maybe<ImmutableList<Statement>> apply(Object source) {
      if (!(source instanceof FunctionBody)) return Maybe.empty();
      return Maybe.of(((FunctionBody) source).statements);
    }

    public String propertyName() {
      return "statements";
    }
  }

  public static class FunctionDeclaration_IsAsync extends ASTPath<FunctionDeclaration, Boolean> {
    private FunctionDeclaration_IsAsync() {}

    @Override
    public Maybe<Boolean> apply(Object source) {
      if (!(source instanceof FunctionDeclaration)) return Maybe.empty();
      return Maybe.of(((FunctionDeclaration) source).isAsync);
    }

    public String propertyName() {
      return "isAsync";
    }
  }

  public static class FunctionDeclaration_IsGenerator extends ASTPath<FunctionDeclaration, Boolean> {
    private FunctionDeclaration_IsGenerator() {}

    @Override
    public Maybe<Boolean> apply(Object source) {
      if (!(source instanceof FunctionDeclaration)) return Maybe.empty();
      return Maybe.of(((FunctionDeclaration) source).isGenerator);
    }

    public String propertyName() {
      return "isGenerator";
    }
  }

  public static class FunctionDeclaration_Name extends ASTPath<FunctionDeclaration, BindingIdentifier> {
    private FunctionDeclaration_Name() {}

    @Override
    public Maybe<BindingIdentifier> apply(Object source) {
      if (!(source instanceof FunctionDeclaration)) return Maybe.empty();
      return Maybe.of(((FunctionDeclaration) source).name);
    }

    public String propertyName() {
      return "name";
    }
  }

  public static class FunctionDeclaration_Params extends ASTPath<FunctionDeclaration, FormalParameters> {
    private FunctionDeclaration_Params() {}

    @Override
    public Maybe<FormalParameters> apply(Object source) {
      if (!(source instanceof FunctionDeclaration)) return Maybe.empty();
      return Maybe.of(((FunctionDeclaration) source).params);
    }

    public String propertyName() {
      return "params";
    }
  }

  public static class FunctionDeclaration_Body extends ASTPath<FunctionDeclaration, FunctionBody> {
    private FunctionDeclaration_Body() {}

    @Override
    public Maybe<FunctionBody> apply(Object source) {
      if (!(source instanceof FunctionDeclaration)) return Maybe.empty();
      return Maybe.of(((FunctionDeclaration) source).body);
    }

    public String propertyName() {
      return "body";
    }
  }

  public static class FunctionExpression_IsAsync extends ASTPath<FunctionExpression, Boolean> {
    private FunctionExpression_IsAsync() {}

    @Override
    public Maybe<Boolean> apply(Object source) {
      if (!(source instanceof FunctionExpression)) return Maybe.empty();
      return Maybe.of(((FunctionExpression) source).isAsync);
    }

    public String propertyName() {
      return "isAsync";
    }
  }

  public static class FunctionExpression_IsGenerator extends ASTPath<FunctionExpression, Boolean> {
    private FunctionExpression_IsGenerator() {}

    @Override
    public Maybe<Boolean> apply(Object source) {
      if (!(source instanceof FunctionExpression)) return Maybe.empty();
      return Maybe.of(((FunctionExpression) source).isGenerator);
    }

    public String propertyName() {
      return "isGenerator";
    }
  }

  public static class FunctionExpression_Name extends ASTPath<FunctionExpression, Maybe<BindingIdentifier>> {
    private FunctionExpression_Name() {}

    @Override
    public Maybe<Maybe<BindingIdentifier>> apply(Object source) {
      if (!(source instanceof FunctionExpression)) return Maybe.empty();
      return Maybe.of(((FunctionExpression) source).name);
    }

    public String propertyName() {
      return "name";
    }
  }

  public static class FunctionExpression_Params extends ASTPath<FunctionExpression, FormalParameters> {
    private FunctionExpression_Params() {}

    @Override
    public Maybe<FormalParameters> apply(Object source) {
      if (!(source instanceof FunctionExpression)) return Maybe.empty();
      return Maybe.of(((FunctionExpression) source).params);
    }

    public String propertyName() {
      return "params";
    }
  }

  public static class FunctionExpression_Body extends ASTPath<FunctionExpression, FunctionBody> {
    private FunctionExpression_Body() {}

    @Override
    public Maybe<FunctionBody> apply(Object source) {
      if (!(source instanceof FunctionExpression)) return Maybe.empty();
      return Maybe.of(((FunctionExpression) source).body);
    }

    public String propertyName() {
      return "body";
    }
  }

  public static class Getter_Name extends ASTPath<Getter, PropertyName> {
    private Getter_Name() {}

    @Override
    public Maybe<PropertyName> apply(Object source) {
      if (!(source instanceof Getter)) return Maybe.empty();
      return Maybe.of(((Getter) source).name);
    }

    public String propertyName() {
      return "name";
    }
  }

  public static class Getter_Body extends ASTPath<Getter, FunctionBody> {
    private Getter_Body() {}

    @Override
    public Maybe<FunctionBody> apply(Object source) {
      if (!(source instanceof Getter)) return Maybe.empty();
      return Maybe.of(((Getter) source).body);
    }

    public String propertyName() {
      return "body";
    }
  }

  public static class IdentifierExpression_Name extends ASTPath<IdentifierExpression, String> {
    private IdentifierExpression_Name() {}

    @Override
    public Maybe<String> apply(Object source) {
      if (!(source instanceof IdentifierExpression)) return Maybe.empty();
      return Maybe.of(((IdentifierExpression) source).name);
    }

    public String propertyName() {
      return "name";
    }
  }

  public static class IfStatement_Test extends ASTPath<IfStatement, Expression> {
    private IfStatement_Test() {}

    @Override
    public Maybe<Expression> apply(Object source) {
      if (!(source instanceof IfStatement)) return Maybe.empty();
      return Maybe.of(((IfStatement) source).test);
    }

    public String propertyName() {
      return "test";
    }
  }

  public static class IfStatement_Consequent extends ASTPath<IfStatement, Statement> {
    private IfStatement_Consequent() {}

    @Override
    public Maybe<Statement> apply(Object source) {
      if (!(source instanceof IfStatement)) return Maybe.empty();
      return Maybe.of(((IfStatement) source).consequent);
    }

    public String propertyName() {
      return "consequent";
    }
  }

  public static class IfStatement_Alternate extends ASTPath<IfStatement, Maybe<Statement>> {
    private IfStatement_Alternate() {}

    @Override
    public Maybe<Maybe<Statement>> apply(Object source) {
      if (!(source instanceof IfStatement)) return Maybe.empty();
      return Maybe.of(((IfStatement) source).alternate);
    }

    public String propertyName() {
      return "alternate";
    }
  }

  public static class Import_DefaultBinding extends ASTPath<Import, Maybe<BindingIdentifier>> {
    private Import_DefaultBinding() {}

    @Override
    public Maybe<Maybe<BindingIdentifier>> apply(Object source) {
      if (!(source instanceof Import)) return Maybe.empty();
      return Maybe.of(((Import) source).defaultBinding);
    }

    public String propertyName() {
      return "defaultBinding";
    }
  }

  public static class Import_NamedImports extends ASTPath<Import, ImmutableList<ImportSpecifier>> {
    private Import_NamedImports() {}

    @Override
    public Maybe<ImmutableList<ImportSpecifier>> apply(Object source) {
      if (!(source instanceof Import)) return Maybe.empty();
      return Maybe.of(((Import) source).namedImports);
    }

    public String propertyName() {
      return "namedImports";
    }
  }

  public static class Import_ModuleSpecifier extends ASTPath<Import, String> {
    private Import_ModuleSpecifier() {}

    @Override
    public Maybe<String> apply(Object source) {
      if (!(source instanceof Import)) return Maybe.empty();
      return Maybe.of(((Import) source).moduleSpecifier);
    }

    public String propertyName() {
      return "moduleSpecifier";
    }
  }

  public static class ImportNamespace_DefaultBinding extends ASTPath<ImportNamespace, Maybe<BindingIdentifier>> {
    private ImportNamespace_DefaultBinding() {}

    @Override
    public Maybe<Maybe<BindingIdentifier>> apply(Object source) {
      if (!(source instanceof ImportNamespace)) return Maybe.empty();
      return Maybe.of(((ImportNamespace) source).defaultBinding);
    }

    public String propertyName() {
      return "defaultBinding";
    }
  }

  public static class ImportNamespace_NamespaceBinding extends ASTPath<ImportNamespace, BindingIdentifier> {
    private ImportNamespace_NamespaceBinding() {}

    @Override
    public Maybe<BindingIdentifier> apply(Object source) {
      if (!(source instanceof ImportNamespace)) return Maybe.empty();
      return Maybe.of(((ImportNamespace) source).namespaceBinding);
    }

    public String propertyName() {
      return "namespaceBinding";
    }
  }

  public static class ImportNamespace_ModuleSpecifier extends ASTPath<ImportNamespace, String> {
    private ImportNamespace_ModuleSpecifier() {}

    @Override
    public Maybe<String> apply(Object source) {
      if (!(source instanceof ImportNamespace)) return Maybe.empty();
      return Maybe.of(((ImportNamespace) source).moduleSpecifier);
    }

    public String propertyName() {
      return "moduleSpecifier";
    }
  }

  public static class ImportSpecifier_Name extends ASTPath<ImportSpecifier, Maybe<String>> {
    private ImportSpecifier_Name() {}

    @Override
    public Maybe<Maybe<String>> apply(Object source) {
      if (!(source instanceof ImportSpecifier)) return Maybe.empty();
      return Maybe.of(((ImportSpecifier) source).name);
    }

    public String propertyName() {
      return "name";
    }
  }

  public static class ImportSpecifier_Binding extends ASTPath<ImportSpecifier, BindingIdentifier> {
    private ImportSpecifier_Binding() {}

    @Override
    public Maybe<BindingIdentifier> apply(Object source) {
      if (!(source instanceof ImportSpecifier)) return Maybe.empty();
      return Maybe.of(((ImportSpecifier) source).binding);
    }

    public String propertyName() {
      return "binding";
    }
  }

  public static class LabeledStatement_Label extends ASTPath<LabeledStatement, String> {
    private LabeledStatement_Label() {}

    @Override
    public Maybe<String> apply(Object source) {
      if (!(source instanceof LabeledStatement)) return Maybe.empty();
      return Maybe.of(((LabeledStatement) source).label);
    }

    public String propertyName() {
      return "label";
    }
  }

  public static class LabeledStatement_Body extends ASTPath<LabeledStatement, Statement> {
    private LabeledStatement_Body() {}

    @Override
    public Maybe<Statement> apply(Object source) {
      if (!(source instanceof LabeledStatement)) return Maybe.empty();
      return Maybe.of(((LabeledStatement) source).body);
    }

    public String propertyName() {
      return "body";
    }
  }

  public static class LiteralBooleanExpression_Value extends ASTPath<LiteralBooleanExpression, Boolean> {
    private LiteralBooleanExpression_Value() {}

    @Override
    public Maybe<Boolean> apply(Object source) {
      if (!(source instanceof LiteralBooleanExpression)) return Maybe.empty();
      return Maybe.of(((LiteralBooleanExpression) source).value);
    }

    public String propertyName() {
      return "value";
    }
  }

  public static class LiteralNumericExpression_Value extends ASTPath<LiteralNumericExpression, Double> {
    private LiteralNumericExpression_Value() {}

    @Override
    public Maybe<Double> apply(Object source) {
      if (!(source instanceof LiteralNumericExpression)) return Maybe.empty();
      return Maybe.of(((LiteralNumericExpression) source).value);
    }

    public String propertyName() {
      return "value";
    }
  }

  public static class LiteralRegExpExpression_Pattern extends ASTPath<LiteralRegExpExpression, String> {
    private LiteralRegExpExpression_Pattern() {}

    @Override
    public Maybe<String> apply(Object source) {
      if (!(source instanceof LiteralRegExpExpression)) return Maybe.empty();
      return Maybe.of(((LiteralRegExpExpression) source).pattern);
    }

    public String propertyName() {
      return "pattern";
    }
  }

  public static class LiteralRegExpExpression_Global extends ASTPath<LiteralRegExpExpression, Boolean> {
    private LiteralRegExpExpression_Global() {}

    @Override
    public Maybe<Boolean> apply(Object source) {
      if (!(source instanceof LiteralRegExpExpression)) return Maybe.empty();
      return Maybe.of(((LiteralRegExpExpression) source).global);
    }

    public String propertyName() {
      return "global";
    }
  }

  public static class LiteralRegExpExpression_IgnoreCase extends ASTPath<LiteralRegExpExpression, Boolean> {
    private LiteralRegExpExpression_IgnoreCase() {}

    @Override
    public Maybe<Boolean> apply(Object source) {
      if (!(source instanceof LiteralRegExpExpression)) return Maybe.empty();
      return Maybe.of(((LiteralRegExpExpression) source).ignoreCase);
    }

    public String propertyName() {
      return "ignoreCase";
    }
  }

  public static class LiteralRegExpExpression_MultiLine extends ASTPath<LiteralRegExpExpression, Boolean> {
    private LiteralRegExpExpression_MultiLine() {}

    @Override
    public Maybe<Boolean> apply(Object source) {
      if (!(source instanceof LiteralRegExpExpression)) return Maybe.empty();
      return Maybe.of(((LiteralRegExpExpression) source).multiLine);
    }

    public String propertyName() {
      return "multiLine";
    }
  }

  public static class LiteralRegExpExpression_DotAll extends ASTPath<LiteralRegExpExpression, Boolean> {
    private LiteralRegExpExpression_DotAll() {}

    @Override
    public Maybe<Boolean> apply(Object source) {
      if (!(source instanceof LiteralRegExpExpression)) return Maybe.empty();
      return Maybe.of(((LiteralRegExpExpression) source).dotAll);
    }

    public String propertyName() {
      return "dotAll";
    }
  }

  public static class LiteralRegExpExpression_Unicode extends ASTPath<LiteralRegExpExpression, Boolean> {
    private LiteralRegExpExpression_Unicode() {}

    @Override
    public Maybe<Boolean> apply(Object source) {
      if (!(source instanceof LiteralRegExpExpression)) return Maybe.empty();
      return Maybe.of(((LiteralRegExpExpression) source).unicode);
    }

    public String propertyName() {
      return "unicode";
    }
  }

  public static class LiteralRegExpExpression_Sticky extends ASTPath<LiteralRegExpExpression, Boolean> {
    private LiteralRegExpExpression_Sticky() {}

    @Override
    public Maybe<Boolean> apply(Object source) {
      if (!(source instanceof LiteralRegExpExpression)) return Maybe.empty();
      return Maybe.of(((LiteralRegExpExpression) source).sticky);
    }

    public String propertyName() {
      return "sticky";
    }
  }

  public static class LiteralStringExpression_Value extends ASTPath<LiteralStringExpression, String> {
    private LiteralStringExpression_Value() {}

    @Override
    public Maybe<String> apply(Object source) {
      if (!(source instanceof LiteralStringExpression)) return Maybe.empty();
      return Maybe.of(((LiteralStringExpression) source).value);
    }

    public String propertyName() {
      return "value";
    }
  }

  public static class Method_IsAsync extends ASTPath<Method, Boolean> {
    private Method_IsAsync() {}

    @Override
    public Maybe<Boolean> apply(Object source) {
      if (!(source instanceof Method)) return Maybe.empty();
      return Maybe.of(((Method) source).isAsync);
    }

    public String propertyName() {
      return "isAsync";
    }
  }

  public static class Method_IsGenerator extends ASTPath<Method, Boolean> {
    private Method_IsGenerator() {}

    @Override
    public Maybe<Boolean> apply(Object source) {
      if (!(source instanceof Method)) return Maybe.empty();
      return Maybe.of(((Method) source).isGenerator);
    }

    public String propertyName() {
      return "isGenerator";
    }
  }

  public static class Method_Name extends ASTPath<Method, PropertyName> {
    private Method_Name() {}

    @Override
    public Maybe<PropertyName> apply(Object source) {
      if (!(source instanceof Method)) return Maybe.empty();
      return Maybe.of(((Method) source).name);
    }

    public String propertyName() {
      return "name";
    }
  }

  public static class Method_Params extends ASTPath<Method, FormalParameters> {
    private Method_Params() {}

    @Override
    public Maybe<FormalParameters> apply(Object source) {
      if (!(source instanceof Method)) return Maybe.empty();
      return Maybe.of(((Method) source).params);
    }

    public String propertyName() {
      return "params";
    }
  }

  public static class Method_Body extends ASTPath<Method, FunctionBody> {
    private Method_Body() {}

    @Override
    public Maybe<FunctionBody> apply(Object source) {
      if (!(source instanceof Method)) return Maybe.empty();
      return Maybe.of(((Method) source).body);
    }

    public String propertyName() {
      return "body";
    }
  }

  public static class Module_Directives extends ASTPath<Module, ImmutableList<Directive>> {
    private Module_Directives() {}

    @Override
    public Maybe<ImmutableList<Directive>> apply(Object source) {
      if (!(source instanceof Module)) return Maybe.empty();
      return Maybe.of(((Module) source).directives);
    }

    public String propertyName() {
      return "directives";
    }
  }

  public static class Module_Items extends ASTPath<Module, ImmutableList<ImportDeclarationExportDeclarationStatement>> {
    private Module_Items() {}

    @Override
    public Maybe<ImmutableList<ImportDeclarationExportDeclarationStatement>> apply(Object source) {
      if (!(source instanceof Module)) return Maybe.empty();
      return Maybe.of(((Module) source).items);
    }

    public String propertyName() {
      return "items";
    }
  }

  public static class NewExpression_Callee extends ASTPath<NewExpression, Expression> {
    private NewExpression_Callee() {}

    @Override
    public Maybe<Expression> apply(Object source) {
      if (!(source instanceof NewExpression)) return Maybe.empty();
      return Maybe.of(((NewExpression) source).callee);
    }

    public String propertyName() {
      return "callee";
    }
  }

  public static class NewExpression_Arguments extends ASTPath<NewExpression, ImmutableList<SpreadElementExpression>> {
    private NewExpression_Arguments() {}

    @Override
    public Maybe<ImmutableList<SpreadElementExpression>> apply(Object source) {
      if (!(source instanceof NewExpression)) return Maybe.empty();
      return Maybe.of(((NewExpression) source).arguments);
    }

    public String propertyName() {
      return "arguments";
    }
  }

  public static class ObjectAssignmentTarget_Properties extends ASTPath<ObjectAssignmentTarget, ImmutableList<AssignmentTargetProperty>> {
    private ObjectAssignmentTarget_Properties() {}

    @Override
    public Maybe<ImmutableList<AssignmentTargetProperty>> apply(Object source) {
      if (!(source instanceof ObjectAssignmentTarget)) return Maybe.empty();
      return Maybe.of(((ObjectAssignmentTarget) source).properties);
    }

    public String propertyName() {
      return "properties";
    }
  }

  public static class ObjectAssignmentTarget_Rest extends ASTPath<ObjectAssignmentTarget, Maybe<AssignmentTarget>> {
    private ObjectAssignmentTarget_Rest() {}

    @Override
    public Maybe<Maybe<AssignmentTarget>> apply(Object source) {
      if (!(source instanceof ObjectAssignmentTarget)) return Maybe.empty();
      return Maybe.of(((ObjectAssignmentTarget) source).rest);
    }

    public String propertyName() {
      return "rest";
    }
  }

  public static class ObjectBinding_Properties extends ASTPath<ObjectBinding, ImmutableList<BindingProperty>> {
    private ObjectBinding_Properties() {}

    @Override
    public Maybe<ImmutableList<BindingProperty>> apply(Object source) {
      if (!(source instanceof ObjectBinding)) return Maybe.empty();
      return Maybe.of(((ObjectBinding) source).properties);
    }

    public String propertyName() {
      return "properties";
    }
  }

  public static class ObjectBinding_Rest extends ASTPath<ObjectBinding, Maybe<Binding>> {
    private ObjectBinding_Rest() {}

    @Override
    public Maybe<Maybe<Binding>> apply(Object source) {
      if (!(source instanceof ObjectBinding)) return Maybe.empty();
      return Maybe.of(((ObjectBinding) source).rest);
    }

    public String propertyName() {
      return "rest";
    }
  }

  public static class ObjectExpression_Properties extends ASTPath<ObjectExpression, ImmutableList<ObjectProperty>> {
    private ObjectExpression_Properties() {}

    @Override
    public Maybe<ImmutableList<ObjectProperty>> apply(Object source) {
      if (!(source instanceof ObjectExpression)) return Maybe.empty();
      return Maybe.of(((ObjectExpression) source).properties);
    }

    public String propertyName() {
      return "properties";
    }
  }

  public static class ReturnStatement_Expression extends ASTPath<ReturnStatement, Maybe<Expression>> {
    private ReturnStatement_Expression() {}

    @Override
    public Maybe<Maybe<Expression>> apply(Object source) {
      if (!(source instanceof ReturnStatement)) return Maybe.empty();
      return Maybe.of(((ReturnStatement) source).expression);
    }

    public String propertyName() {
      return "expression";
    }
  }

  public static class Script_Directives extends ASTPath<Script, ImmutableList<Directive>> {
    private Script_Directives() {}

    @Override
    public Maybe<ImmutableList<Directive>> apply(Object source) {
      if (!(source instanceof Script)) return Maybe.empty();
      return Maybe.of(((Script) source).directives);
    }

    public String propertyName() {
      return "directives";
    }
  }

  public static class Script_Statements extends ASTPath<Script, ImmutableList<Statement>> {
    private Script_Statements() {}

    @Override
    public Maybe<ImmutableList<Statement>> apply(Object source) {
      if (!(source instanceof Script)) return Maybe.empty();
      return Maybe.of(((Script) source).statements);
    }

    public String propertyName() {
      return "statements";
    }
  }

  public static class Setter_Name extends ASTPath<Setter, PropertyName> {
    private Setter_Name() {}

    @Override
    public Maybe<PropertyName> apply(Object source) {
      if (!(source instanceof Setter)) return Maybe.empty();
      return Maybe.of(((Setter) source).name);
    }

    public String propertyName() {
      return "name";
    }
  }

  public static class Setter_Param extends ASTPath<Setter, Parameter> {
    private Setter_Param() {}

    @Override
    public Maybe<Parameter> apply(Object source) {
      if (!(source instanceof Setter)) return Maybe.empty();
      return Maybe.of(((Setter) source).param);
    }

    public String propertyName() {
      return "param";
    }
  }

  public static class Setter_Body extends ASTPath<Setter, FunctionBody> {
    private Setter_Body() {}

    @Override
    public Maybe<FunctionBody> apply(Object source) {
      if (!(source instanceof Setter)) return Maybe.empty();
      return Maybe.of(((Setter) source).body);
    }

    public String propertyName() {
      return "body";
    }
  }

  public static class ShorthandProperty_Name extends ASTPath<ShorthandProperty, IdentifierExpression> {
    private ShorthandProperty_Name() {}

    @Override
    public Maybe<IdentifierExpression> apply(Object source) {
      if (!(source instanceof ShorthandProperty)) return Maybe.empty();
      return Maybe.of(((ShorthandProperty) source).name);
    }

    public String propertyName() {
      return "name";
    }
  }

  public static class SpreadElement_Expression extends ASTPath<SpreadElement, Expression> {
    private SpreadElement_Expression() {}

    @Override
    public Maybe<Expression> apply(Object source) {
      if (!(source instanceof SpreadElement)) return Maybe.empty();
      return Maybe.of(((SpreadElement) source).expression);
    }

    public String propertyName() {
      return "expression";
    }
  }

  public static class SpreadProperty_Expression extends ASTPath<SpreadProperty, Expression> {
    private SpreadProperty_Expression() {}

    @Override
    public Maybe<Expression> apply(Object source) {
      if (!(source instanceof SpreadProperty)) return Maybe.empty();
      return Maybe.of(((SpreadProperty) source).expression);
    }

    public String propertyName() {
      return "expression";
    }
  }

  public static class StaticMemberAssignmentTarget_Object extends ASTPath<StaticMemberAssignmentTarget, ExpressionSuper> {
    private StaticMemberAssignmentTarget_Object() {}

    @Override
    public Maybe<ExpressionSuper> apply(Object source) {
      if (!(source instanceof StaticMemberAssignmentTarget)) return Maybe.empty();
      return Maybe.of(((StaticMemberAssignmentTarget) source).object);
    }

    public String propertyName() {
      return "object";
    }
  }

  public static class StaticMemberAssignmentTarget_Property extends ASTPath<StaticMemberAssignmentTarget, String> {
    private StaticMemberAssignmentTarget_Property() {}

    @Override
    public Maybe<String> apply(Object source) {
      if (!(source instanceof StaticMemberAssignmentTarget)) return Maybe.empty();
      return Maybe.of(((StaticMemberAssignmentTarget) source).property);
    }

    public String propertyName() {
      return "property";
    }
  }

  public static class StaticMemberExpression_Object extends ASTPath<StaticMemberExpression, ExpressionSuper> {
    private StaticMemberExpression_Object() {}

    @Override
    public Maybe<ExpressionSuper> apply(Object source) {
      if (!(source instanceof StaticMemberExpression)) return Maybe.empty();
      return Maybe.of(((StaticMemberExpression) source).object);
    }

    public String propertyName() {
      return "object";
    }
  }

  public static class StaticMemberExpression_Property extends ASTPath<StaticMemberExpression, String> {
    private StaticMemberExpression_Property() {}

    @Override
    public Maybe<String> apply(Object source) {
      if (!(source instanceof StaticMemberExpression)) return Maybe.empty();
      return Maybe.of(((StaticMemberExpression) source).property);
    }

    public String propertyName() {
      return "property";
    }
  }

  public static class StaticPropertyName_Value extends ASTPath<StaticPropertyName, String> {
    private StaticPropertyName_Value() {}

    @Override
    public Maybe<String> apply(Object source) {
      if (!(source instanceof StaticPropertyName)) return Maybe.empty();
      return Maybe.of(((StaticPropertyName) source).value);
    }

    public String propertyName() {
      return "value";
    }
  }

  public static class SwitchCase_Test extends ASTPath<SwitchCase, Expression> {
    private SwitchCase_Test() {}

    @Override
    public Maybe<Expression> apply(Object source) {
      if (!(source instanceof SwitchCase)) return Maybe.empty();
      return Maybe.of(((SwitchCase) source).test);
    }

    public String propertyName() {
      return "test";
    }
  }

  public static class SwitchCase_Consequent extends ASTPath<SwitchCase, ImmutableList<Statement>> {
    private SwitchCase_Consequent() {}

    @Override
    public Maybe<ImmutableList<Statement>> apply(Object source) {
      if (!(source instanceof SwitchCase)) return Maybe.empty();
      return Maybe.of(((SwitchCase) source).consequent);
    }

    public String propertyName() {
      return "consequent";
    }
  }

  public static class SwitchDefault_Consequent extends ASTPath<SwitchDefault, ImmutableList<Statement>> {
    private SwitchDefault_Consequent() {}

    @Override
    public Maybe<ImmutableList<Statement>> apply(Object source) {
      if (!(source instanceof SwitchDefault)) return Maybe.empty();
      return Maybe.of(((SwitchDefault) source).consequent);
    }

    public String propertyName() {
      return "consequent";
    }
  }

  public static class SwitchStatement_Discriminant extends ASTPath<SwitchStatement, Expression> {
    private SwitchStatement_Discriminant() {}

    @Override
    public Maybe<Expression> apply(Object source) {
      if (!(source instanceof SwitchStatement)) return Maybe.empty();
      return Maybe.of(((SwitchStatement) source).discriminant);
    }

    public String propertyName() {
      return "discriminant";
    }
  }

  public static class SwitchStatement_Cases extends ASTPath<SwitchStatement, ImmutableList<SwitchCase>> {
    private SwitchStatement_Cases() {}

    @Override
    public Maybe<ImmutableList<SwitchCase>> apply(Object source) {
      if (!(source instanceof SwitchStatement)) return Maybe.empty();
      return Maybe.of(((SwitchStatement) source).cases);
    }

    public String propertyName() {
      return "cases";
    }
  }

  public static class SwitchStatementWithDefault_Discriminant extends ASTPath<SwitchStatementWithDefault, Expression> {
    private SwitchStatementWithDefault_Discriminant() {}

    @Override
    public Maybe<Expression> apply(Object source) {
      if (!(source instanceof SwitchStatementWithDefault)) return Maybe.empty();
      return Maybe.of(((SwitchStatementWithDefault) source).discriminant);
    }

    public String propertyName() {
      return "discriminant";
    }
  }

  public static class SwitchStatementWithDefault_PreDefaultCases extends ASTPath<SwitchStatementWithDefault, ImmutableList<SwitchCase>> {
    private SwitchStatementWithDefault_PreDefaultCases() {}

    @Override
    public Maybe<ImmutableList<SwitchCase>> apply(Object source) {
      if (!(source instanceof SwitchStatementWithDefault)) return Maybe.empty();
      return Maybe.of(((SwitchStatementWithDefault) source).preDefaultCases);
    }

    public String propertyName() {
      return "preDefaultCases";
    }
  }

  public static class SwitchStatementWithDefault_DefaultCase extends ASTPath<SwitchStatementWithDefault, SwitchDefault> {
    private SwitchStatementWithDefault_DefaultCase() {}

    @Override
    public Maybe<SwitchDefault> apply(Object source) {
      if (!(source instanceof SwitchStatementWithDefault)) return Maybe.empty();
      return Maybe.of(((SwitchStatementWithDefault) source).defaultCase);
    }

    public String propertyName() {
      return "defaultCase";
    }
  }

  public static class SwitchStatementWithDefault_PostDefaultCases extends ASTPath<SwitchStatementWithDefault, ImmutableList<SwitchCase>> {
    private SwitchStatementWithDefault_PostDefaultCases() {}

    @Override
    public Maybe<ImmutableList<SwitchCase>> apply(Object source) {
      if (!(source instanceof SwitchStatementWithDefault)) return Maybe.empty();
      return Maybe.of(((SwitchStatementWithDefault) source).postDefaultCases);
    }

    public String propertyName() {
      return "postDefaultCases";
    }
  }

  public static class TemplateElement_RawValue extends ASTPath<TemplateElement, String> {
    private TemplateElement_RawValue() {}

    @Override
    public Maybe<String> apply(Object source) {
      if (!(source instanceof TemplateElement)) return Maybe.empty();
      return Maybe.of(((TemplateElement) source).rawValue);
    }

    public String propertyName() {
      return "rawValue";
    }
  }

  public static class TemplateExpression_Tag extends ASTPath<TemplateExpression, Maybe<Expression>> {
    private TemplateExpression_Tag() {}

    @Override
    public Maybe<Maybe<Expression>> apply(Object source) {
      if (!(source instanceof TemplateExpression)) return Maybe.empty();
      return Maybe.of(((TemplateExpression) source).tag);
    }

    public String propertyName() {
      return "tag";
    }
  }

  public static class TemplateExpression_Elements extends ASTPath<TemplateExpression, ImmutableList<ExpressionTemplateElement>> {
    private TemplateExpression_Elements() {}

    @Override
    public Maybe<ImmutableList<ExpressionTemplateElement>> apply(Object source) {
      if (!(source instanceof TemplateExpression)) return Maybe.empty();
      return Maybe.of(((TemplateExpression) source).elements);
    }

    public String propertyName() {
      return "elements";
    }
  }

  public static class ThrowStatement_Expression extends ASTPath<ThrowStatement, Expression> {
    private ThrowStatement_Expression() {}

    @Override
    public Maybe<Expression> apply(Object source) {
      if (!(source instanceof ThrowStatement)) return Maybe.empty();
      return Maybe.of(((ThrowStatement) source).expression);
    }

    public String propertyName() {
      return "expression";
    }
  }

  public static class TryCatchStatement_Body extends ASTPath<TryCatchStatement, Block> {
    private TryCatchStatement_Body() {}

    @Override
    public Maybe<Block> apply(Object source) {
      if (!(source instanceof TryCatchStatement)) return Maybe.empty();
      return Maybe.of(((TryCatchStatement) source).body);
    }

    public String propertyName() {
      return "body";
    }
  }

  public static class TryCatchStatement_CatchClause extends ASTPath<TryCatchStatement, CatchClause> {
    private TryCatchStatement_CatchClause() {}

    @Override
    public Maybe<CatchClause> apply(Object source) {
      if (!(source instanceof TryCatchStatement)) return Maybe.empty();
      return Maybe.of(((TryCatchStatement) source).catchClause);
    }

    public String propertyName() {
      return "catchClause";
    }
  }

  public static class TryFinallyStatement_Body extends ASTPath<TryFinallyStatement, Block> {
    private TryFinallyStatement_Body() {}

    @Override
    public Maybe<Block> apply(Object source) {
      if (!(source instanceof TryFinallyStatement)) return Maybe.empty();
      return Maybe.of(((TryFinallyStatement) source).body);
    }

    public String propertyName() {
      return "body";
    }
  }

  public static class TryFinallyStatement_CatchClause extends ASTPath<TryFinallyStatement, Maybe<CatchClause>> {
    private TryFinallyStatement_CatchClause() {}

    @Override
    public Maybe<Maybe<CatchClause>> apply(Object source) {
      if (!(source instanceof TryFinallyStatement)) return Maybe.empty();
      return Maybe.of(((TryFinallyStatement) source).catchClause);
    }

    public String propertyName() {
      return "catchClause";
    }
  }

  public static class TryFinallyStatement_Finalizer extends ASTPath<TryFinallyStatement, Block> {
    private TryFinallyStatement_Finalizer() {}

    @Override
    public Maybe<Block> apply(Object source) {
      if (!(source instanceof TryFinallyStatement)) return Maybe.empty();
      return Maybe.of(((TryFinallyStatement) source).finalizer);
    }

    public String propertyName() {
      return "finalizer";
    }
  }

  public static class UnaryExpression_Operator extends ASTPath<UnaryExpression, com.shapesecurity.shift.es2018.ast.operators.UnaryOperator> {
    private UnaryExpression_Operator() {}

    @Override
    public Maybe<com.shapesecurity.shift.es2018.ast.operators.UnaryOperator> apply(Object source) {
      if (!(source instanceof UnaryExpression)) return Maybe.empty();
      return Maybe.of(((UnaryExpression) source).operator);
    }

    public String propertyName() {
      return "operator";
    }
  }

  public static class UnaryExpression_Operand extends ASTPath<UnaryExpression, Expression> {
    private UnaryExpression_Operand() {}

    @Override
    public Maybe<Expression> apply(Object source) {
      if (!(source instanceof UnaryExpression)) return Maybe.empty();
      return Maybe.of(((UnaryExpression) source).operand);
    }

    public String propertyName() {
      return "operand";
    }
  }

  public static class UpdateExpression_IsPrefix extends ASTPath<UpdateExpression, Boolean> {
    private UpdateExpression_IsPrefix() {}

    @Override
    public Maybe<Boolean> apply(Object source) {
      if (!(source instanceof UpdateExpression)) return Maybe.empty();
      return Maybe.of(((UpdateExpression) source).isPrefix);
    }

    public String propertyName() {
      return "isPrefix";
    }
  }

  public static class UpdateExpression_Operator extends ASTPath<UpdateExpression, com.shapesecurity.shift.es2018.ast.operators.UpdateOperator> {
    private UpdateExpression_Operator() {}

    @Override
    public Maybe<com.shapesecurity.shift.es2018.ast.operators.UpdateOperator> apply(Object source) {
      if (!(source instanceof UpdateExpression)) return Maybe.empty();
      return Maybe.of(((UpdateExpression) source).operator);
    }

    public String propertyName() {
      return "operator";
    }
  }

  public static class UpdateExpression_Operand extends ASTPath<UpdateExpression, SimpleAssignmentTarget> {
    private UpdateExpression_Operand() {}

    @Override
    public Maybe<SimpleAssignmentTarget> apply(Object source) {
      if (!(source instanceof UpdateExpression)) return Maybe.empty();
      return Maybe.of(((UpdateExpression) source).operand);
    }

    public String propertyName() {
      return "operand";
    }
  }

  public static class VariableDeclaration_Kind extends ASTPath<VariableDeclaration, VariableDeclarationKind> {
    private VariableDeclaration_Kind() {}

    @Override
    public Maybe<VariableDeclarationKind> apply(Object source) {
      if (!(source instanceof VariableDeclaration)) return Maybe.empty();
      return Maybe.of(((VariableDeclaration) source).kind);
    }

    public String propertyName() {
      return "kind";
    }
  }

  public static class VariableDeclaration_Declarators extends ASTPath<VariableDeclaration, ImmutableList<VariableDeclarator>> {
    private VariableDeclaration_Declarators() {}

    @Override
    public Maybe<ImmutableList<VariableDeclarator>> apply(Object source) {
      if (!(source instanceof VariableDeclaration)) return Maybe.empty();
      return Maybe.of(((VariableDeclaration) source).declarators);
    }

    public String propertyName() {
      return "declarators";
    }
  }

  public static class VariableDeclarationStatement_Declaration extends ASTPath<VariableDeclarationStatement, VariableDeclaration> {
    private VariableDeclarationStatement_Declaration() {}

    @Override
    public Maybe<VariableDeclaration> apply(Object source) {
      if (!(source instanceof VariableDeclarationStatement)) return Maybe.empty();
      return Maybe.of(((VariableDeclarationStatement) source).declaration);
    }

    public String propertyName() {
      return "declaration";
    }
  }

  public static class VariableDeclarator_Binding extends ASTPath<VariableDeclarator, Binding> {
    private VariableDeclarator_Binding() {}

    @Override
    public Maybe<Binding> apply(Object source) {
      if (!(source instanceof VariableDeclarator)) return Maybe.empty();
      return Maybe.of(((VariableDeclarator) source).binding);
    }

    public String propertyName() {
      return "binding";
    }
  }

  public static class VariableDeclarator_Init extends ASTPath<VariableDeclarator, Maybe<Expression>> {
    private VariableDeclarator_Init() {}

    @Override
    public Maybe<Maybe<Expression>> apply(Object source) {
      if (!(source instanceof VariableDeclarator)) return Maybe.empty();
      return Maybe.of(((VariableDeclarator) source).init);
    }

    public String propertyName() {
      return "init";
    }
  }

  public static class WhileStatement_Test extends ASTPath<WhileStatement, Expression> {
    private WhileStatement_Test() {}

    @Override
    public Maybe<Expression> apply(Object source) {
      if (!(source instanceof WhileStatement)) return Maybe.empty();
      return Maybe.of(((WhileStatement) source).test);
    }

    public String propertyName() {
      return "test";
    }
  }

  public static class WhileStatement_Body extends ASTPath<WhileStatement, Statement> {
    private WhileStatement_Body() {}

    @Override
    public Maybe<Statement> apply(Object source) {
      if (!(source instanceof WhileStatement)) return Maybe.empty();
      return Maybe.of(((WhileStatement) source).body);
    }

    public String propertyName() {
      return "body";
    }
  }

  public static class WithStatement_Object extends ASTPath<WithStatement, Expression> {
    private WithStatement_Object() {}

    @Override
    public Maybe<Expression> apply(Object source) {
      if (!(source instanceof WithStatement)) return Maybe.empty();
      return Maybe.of(((WithStatement) source).object);
    }

    public String propertyName() {
      return "object";
    }
  }

  public static class WithStatement_Body extends ASTPath<WithStatement, Statement> {
    private WithStatement_Body() {}

    @Override
    public Maybe<Statement> apply(Object source) {
      if (!(source instanceof WithStatement)) return Maybe.empty();
      return Maybe.of(((WithStatement) source).body);
    }

    public String propertyName() {
      return "body";
    }
  }

  public static class YieldExpression_Expression extends ASTPath<YieldExpression, Maybe<Expression>> {
    private YieldExpression_Expression() {}

    @Override
    public Maybe<Maybe<Expression>> apply(Object source) {
      if (!(source instanceof YieldExpression)) return Maybe.empty();
      return Maybe.of(((YieldExpression) source).expression);
    }

    public String propertyName() {
      return "expression";
    }
  }

  public static class YieldGeneratorExpression_Expression extends ASTPath<YieldGeneratorExpression, Expression> {
    private YieldGeneratorExpression_Expression() {}

    @Override
    public Maybe<Expression> apply(Object source) {
      if (!(source instanceof YieldGeneratorExpression)) return Maybe.empty();
      return Maybe.of(((YieldGeneratorExpression) source).expression);
    }

    public String propertyName() {
      return "expression";
    }
  }
}
