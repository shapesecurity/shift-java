// Generated by ast-path.js
/**
 * Copyright 2018 Shape Security, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


package com.shapesecurity.shift.es2017.astpath;


import com.shapesecurity.functional.data.Maybe;
import com.shapesecurity.shift.es2017.ast.*;

import java.util.Objects;


public abstract class ASTPath<S, T> extends ObjectPath<S, T> {
  private ASTPath() {}

  public abstract String propertyName();

  private static abstract class TrivialPath<S, T> extends ObjectPath<S, T> {
    public boolean equals(Object o) {
      return this == o || o != null && getClass() == o.getClass();
    }

    public int hashCode() {
      return Objects.hash(getClass());
    }
  }

  private static abstract class IndexedPath<S, T> extends ObjectPath<S, T> {
    final int index;

    protected IndexedPath(int index) {
      this.index = index;
    }

    @Override
    public boolean equals(Object o) {
      if (this == o) return true;
      if (o == null || getClass() != o.getClass()) return false;
      IndexedPath<?, ?> that = (IndexedPath<?, ?>) o;
      return index == that.index;
    }

    @Override
    public int hashCode() {
      return Objects.hash(getClass(), index);
    }
  }


  public static ArrayAssignmentTarget_Elements ArrayAssignmentTarget_Elements(int index) {
    return new ArrayAssignmentTarget_Elements(index);
  }

  public static final ArrayAssignmentTarget_Rest ArrayAssignmentTarget_Rest = new ArrayAssignmentTarget_Rest();

  public static ArrayBinding_Elements ArrayBinding_Elements(int index) {
    return new ArrayBinding_Elements(index);
  }

  public static final ArrayBinding_Rest ArrayBinding_Rest = new ArrayBinding_Rest();

  public static ArrayExpression_Elements ArrayExpression_Elements(int index) {
    return new ArrayExpression_Elements(index);
  }

  public static final ArrowExpression_IsAsync ArrowExpression_IsAsync = new ArrowExpression_IsAsync();

  public static final ArrowExpression_Params ArrowExpression_Params = new ArrowExpression_Params();

  public static final ArrowExpression_Body ArrowExpression_Body = new ArrowExpression_Body();

  public static final AssignmentExpression_Binding AssignmentExpression_Binding = new AssignmentExpression_Binding();

  public static final AssignmentExpression_Expression AssignmentExpression_Expression = new AssignmentExpression_Expression();

  public static final AssignmentTargetIdentifier_Name AssignmentTargetIdentifier_Name = new AssignmentTargetIdentifier_Name();

  public static final AssignmentTargetPropertyIdentifier_Binding AssignmentTargetPropertyIdentifier_Binding = new AssignmentTargetPropertyIdentifier_Binding();

  public static final AssignmentTargetPropertyIdentifier_Init AssignmentTargetPropertyIdentifier_Init = new AssignmentTargetPropertyIdentifier_Init();

  public static final AssignmentTargetPropertyProperty_Name AssignmentTargetPropertyProperty_Name = new AssignmentTargetPropertyProperty_Name();

  public static final AssignmentTargetPropertyProperty_Binding AssignmentTargetPropertyProperty_Binding = new AssignmentTargetPropertyProperty_Binding();

  public static final AssignmentTargetWithDefault_Binding AssignmentTargetWithDefault_Binding = new AssignmentTargetWithDefault_Binding();

  public static final AssignmentTargetWithDefault_Init AssignmentTargetWithDefault_Init = new AssignmentTargetWithDefault_Init();

  public static final AwaitExpression_Expression AwaitExpression_Expression = new AwaitExpression_Expression();

  public static final BinaryExpression_Left BinaryExpression_Left = new BinaryExpression_Left();

  public static final BinaryExpression_Operator BinaryExpression_Operator = new BinaryExpression_Operator();

  public static final BinaryExpression_Right BinaryExpression_Right = new BinaryExpression_Right();

  public static final BindingIdentifier_Name BindingIdentifier_Name = new BindingIdentifier_Name();

  public static final BindingPropertyIdentifier_Binding BindingPropertyIdentifier_Binding = new BindingPropertyIdentifier_Binding();

  public static final BindingPropertyIdentifier_Init BindingPropertyIdentifier_Init = new BindingPropertyIdentifier_Init();

  public static final BindingPropertyProperty_Name BindingPropertyProperty_Name = new BindingPropertyProperty_Name();

  public static final BindingPropertyProperty_Binding BindingPropertyProperty_Binding = new BindingPropertyProperty_Binding();

  public static final BindingWithDefault_Binding BindingWithDefault_Binding = new BindingWithDefault_Binding();

  public static final BindingWithDefault_Init BindingWithDefault_Init = new BindingWithDefault_Init();

  public static Block_Statements Block_Statements(int index) {
    return new Block_Statements(index);
  }

  public static final BlockStatement_Block BlockStatement_Block = new BlockStatement_Block();

  public static final BreakStatement_Label BreakStatement_Label = new BreakStatement_Label();

  public static final CallExpression_Callee CallExpression_Callee = new CallExpression_Callee();

  public static CallExpression_Arguments CallExpression_Arguments(int index) {
    return new CallExpression_Arguments(index);
  }

  public static final CatchClause_Binding CatchClause_Binding = new CatchClause_Binding();

  public static final CatchClause_Body CatchClause_Body = new CatchClause_Body();

  public static final ClassDeclaration_Name ClassDeclaration_Name = new ClassDeclaration_Name();

  public static final ClassDeclaration_Super ClassDeclaration_Super = new ClassDeclaration_Super();

  public static ClassDeclaration_Elements ClassDeclaration_Elements(int index) {
    return new ClassDeclaration_Elements(index);
  }

  public static final ClassElement_IsStatic ClassElement_IsStatic = new ClassElement_IsStatic();

  public static final ClassElement_Method ClassElement_Method = new ClassElement_Method();

  public static final ClassExpression_Name ClassExpression_Name = new ClassExpression_Name();

  public static final ClassExpression_Super ClassExpression_Super = new ClassExpression_Super();

  public static ClassExpression_Elements ClassExpression_Elements(int index) {
    return new ClassExpression_Elements(index);
  }

  public static final CompoundAssignmentExpression_Binding CompoundAssignmentExpression_Binding = new CompoundAssignmentExpression_Binding();

  public static final CompoundAssignmentExpression_Operator CompoundAssignmentExpression_Operator = new CompoundAssignmentExpression_Operator();

  public static final CompoundAssignmentExpression_Expression CompoundAssignmentExpression_Expression = new CompoundAssignmentExpression_Expression();

  public static final ComputedMemberAssignmentTarget_Object ComputedMemberAssignmentTarget_Object = new ComputedMemberAssignmentTarget_Object();

  public static final ComputedMemberAssignmentTarget_Expression ComputedMemberAssignmentTarget_Expression = new ComputedMemberAssignmentTarget_Expression();

  public static final ComputedMemberExpression_Object ComputedMemberExpression_Object = new ComputedMemberExpression_Object();

  public static final ComputedMemberExpression_Expression ComputedMemberExpression_Expression = new ComputedMemberExpression_Expression();

  public static final ComputedPropertyName_Expression ComputedPropertyName_Expression = new ComputedPropertyName_Expression();

  public static final ConditionalExpression_Test ConditionalExpression_Test = new ConditionalExpression_Test();

  public static final ConditionalExpression_Consequent ConditionalExpression_Consequent = new ConditionalExpression_Consequent();

  public static final ConditionalExpression_Alternate ConditionalExpression_Alternate = new ConditionalExpression_Alternate();

  public static final ContinueStatement_Label ContinueStatement_Label = new ContinueStatement_Label();

  public static final DataProperty_Name DataProperty_Name = new DataProperty_Name();

  public static final DataProperty_Expression DataProperty_Expression = new DataProperty_Expression();

  public static final Directive_RawValue Directive_RawValue = new Directive_RawValue();

  public static final DoWhileStatement_Body DoWhileStatement_Body = new DoWhileStatement_Body();

  public static final DoWhileStatement_Test DoWhileStatement_Test = new DoWhileStatement_Test();

  public static final Export_Declaration Export_Declaration = new Export_Declaration();

  public static final ExportAllFrom_ModuleSpecifier ExportAllFrom_ModuleSpecifier = new ExportAllFrom_ModuleSpecifier();

  public static final ExportDefault_Body ExportDefault_Body = new ExportDefault_Body();

  public static ExportFrom_NamedExports ExportFrom_NamedExports(int index) {
    return new ExportFrom_NamedExports(index);
  }

  public static final ExportFrom_ModuleSpecifier ExportFrom_ModuleSpecifier = new ExportFrom_ModuleSpecifier();

  public static final ExportFromSpecifier_Name ExportFromSpecifier_Name = new ExportFromSpecifier_Name();

  public static final ExportFromSpecifier_ExportedName ExportFromSpecifier_ExportedName = new ExportFromSpecifier_ExportedName();

  public static final ExportLocalSpecifier_Name ExportLocalSpecifier_Name = new ExportLocalSpecifier_Name();

  public static final ExportLocalSpecifier_ExportedName ExportLocalSpecifier_ExportedName = new ExportLocalSpecifier_ExportedName();

  public static ExportLocals_NamedExports ExportLocals_NamedExports(int index) {
    return new ExportLocals_NamedExports(index);
  }

  public static final ExpressionStatement_Expression ExpressionStatement_Expression = new ExpressionStatement_Expression();

  public static final ForInStatement_Left ForInStatement_Left = new ForInStatement_Left();

  public static final ForInStatement_Right ForInStatement_Right = new ForInStatement_Right();

  public static final ForInStatement_Body ForInStatement_Body = new ForInStatement_Body();

  public static final ForOfStatement_Left ForOfStatement_Left = new ForOfStatement_Left();

  public static final ForOfStatement_Right ForOfStatement_Right = new ForOfStatement_Right();

  public static final ForOfStatement_Body ForOfStatement_Body = new ForOfStatement_Body();

  public static final ForStatement_Init ForStatement_Init = new ForStatement_Init();

  public static final ForStatement_Test ForStatement_Test = new ForStatement_Test();

  public static final ForStatement_Update ForStatement_Update = new ForStatement_Update();

  public static final ForStatement_Body ForStatement_Body = new ForStatement_Body();

  public static FormalParameters_Items FormalParameters_Items(int index) {
    return new FormalParameters_Items(index);
  }

  public static final FormalParameters_Rest FormalParameters_Rest = new FormalParameters_Rest();

  public static FunctionBody_Directives FunctionBody_Directives(int index) {
    return new FunctionBody_Directives(index);
  }

  public static FunctionBody_Statements FunctionBody_Statements(int index) {
    return new FunctionBody_Statements(index);
  }

  public static final FunctionDeclaration_IsAsync FunctionDeclaration_IsAsync = new FunctionDeclaration_IsAsync();

  public static final FunctionDeclaration_IsGenerator FunctionDeclaration_IsGenerator = new FunctionDeclaration_IsGenerator();

  public static final FunctionDeclaration_Name FunctionDeclaration_Name = new FunctionDeclaration_Name();

  public static final FunctionDeclaration_Params FunctionDeclaration_Params = new FunctionDeclaration_Params();

  public static final FunctionDeclaration_Body FunctionDeclaration_Body = new FunctionDeclaration_Body();

  public static final FunctionExpression_IsAsync FunctionExpression_IsAsync = new FunctionExpression_IsAsync();

  public static final FunctionExpression_IsGenerator FunctionExpression_IsGenerator = new FunctionExpression_IsGenerator();

  public static final FunctionExpression_Name FunctionExpression_Name = new FunctionExpression_Name();

  public static final FunctionExpression_Params FunctionExpression_Params = new FunctionExpression_Params();

  public static final FunctionExpression_Body FunctionExpression_Body = new FunctionExpression_Body();

  public static final Getter_Name Getter_Name = new Getter_Name();

  public static final Getter_Body Getter_Body = new Getter_Body();

  public static final IdentifierExpression_Name IdentifierExpression_Name = new IdentifierExpression_Name();

  public static final IfStatement_Test IfStatement_Test = new IfStatement_Test();

  public static final IfStatement_Consequent IfStatement_Consequent = new IfStatement_Consequent();

  public static final IfStatement_Alternate IfStatement_Alternate = new IfStatement_Alternate();

  public static final Import_DefaultBinding Import_DefaultBinding = new Import_DefaultBinding();

  public static Import_NamedImports Import_NamedImports(int index) {
    return new Import_NamedImports(index);
  }

  public static final Import_ModuleSpecifier Import_ModuleSpecifier = new Import_ModuleSpecifier();

  public static final ImportNamespace_DefaultBinding ImportNamespace_DefaultBinding = new ImportNamespace_DefaultBinding();

  public static final ImportNamespace_NamespaceBinding ImportNamespace_NamespaceBinding = new ImportNamespace_NamespaceBinding();

  public static final ImportNamespace_ModuleSpecifier ImportNamespace_ModuleSpecifier = new ImportNamespace_ModuleSpecifier();

  public static final ImportSpecifier_Name ImportSpecifier_Name = new ImportSpecifier_Name();

  public static final ImportSpecifier_Binding ImportSpecifier_Binding = new ImportSpecifier_Binding();

  public static final LabeledStatement_Label LabeledStatement_Label = new LabeledStatement_Label();

  public static final LabeledStatement_Body LabeledStatement_Body = new LabeledStatement_Body();

  public static final LiteralBooleanExpression_Value LiteralBooleanExpression_Value = new LiteralBooleanExpression_Value();

  public static final LiteralNumericExpression_Value LiteralNumericExpression_Value = new LiteralNumericExpression_Value();

  public static final LiteralRegExpExpression_Pattern LiteralRegExpExpression_Pattern = new LiteralRegExpExpression_Pattern();

  public static final LiteralRegExpExpression_Global LiteralRegExpExpression_Global = new LiteralRegExpExpression_Global();

  public static final LiteralRegExpExpression_IgnoreCase LiteralRegExpExpression_IgnoreCase = new LiteralRegExpExpression_IgnoreCase();

  public static final LiteralRegExpExpression_MultiLine LiteralRegExpExpression_MultiLine = new LiteralRegExpExpression_MultiLine();

  public static final LiteralRegExpExpression_Sticky LiteralRegExpExpression_Sticky = new LiteralRegExpExpression_Sticky();

  public static final LiteralRegExpExpression_Unicode LiteralRegExpExpression_Unicode = new LiteralRegExpExpression_Unicode();

  public static final LiteralStringExpression_Value LiteralStringExpression_Value = new LiteralStringExpression_Value();

  public static final Method_IsAsync Method_IsAsync = new Method_IsAsync();

  public static final Method_IsGenerator Method_IsGenerator = new Method_IsGenerator();

  public static final Method_Name Method_Name = new Method_Name();

  public static final Method_Params Method_Params = new Method_Params();

  public static final Method_Body Method_Body = new Method_Body();

  public static Module_Directives Module_Directives(int index) {
    return new Module_Directives(index);
  }

  public static Module_Items Module_Items(int index) {
    return new Module_Items(index);
  }

  public static final NewExpression_Callee NewExpression_Callee = new NewExpression_Callee();

  public static NewExpression_Arguments NewExpression_Arguments(int index) {
    return new NewExpression_Arguments(index);
  }

  public static ObjectAssignmentTarget_Properties ObjectAssignmentTarget_Properties(int index) {
    return new ObjectAssignmentTarget_Properties(index);
  }

  public static ObjectBinding_Properties ObjectBinding_Properties(int index) {
    return new ObjectBinding_Properties(index);
  }

  public static ObjectExpression_Properties ObjectExpression_Properties(int index) {
    return new ObjectExpression_Properties(index);
  }

  public static final ReturnStatement_Expression ReturnStatement_Expression = new ReturnStatement_Expression();

  public static Script_Directives Script_Directives(int index) {
    return new Script_Directives(index);
  }

  public static Script_Statements Script_Statements(int index) {
    return new Script_Statements(index);
  }

  public static final Setter_Name Setter_Name = new Setter_Name();

  public static final Setter_Param Setter_Param = new Setter_Param();

  public static final Setter_Body Setter_Body = new Setter_Body();

  public static final ShorthandProperty_Name ShorthandProperty_Name = new ShorthandProperty_Name();

  public static final SpreadElement_Expression SpreadElement_Expression = new SpreadElement_Expression();

  public static final StaticMemberAssignmentTarget_Object StaticMemberAssignmentTarget_Object = new StaticMemberAssignmentTarget_Object();

  public static final StaticMemberAssignmentTarget_Property StaticMemberAssignmentTarget_Property = new StaticMemberAssignmentTarget_Property();

  public static final StaticMemberExpression_Object StaticMemberExpression_Object = new StaticMemberExpression_Object();

  public static final StaticMemberExpression_Property StaticMemberExpression_Property = new StaticMemberExpression_Property();

  public static final StaticPropertyName_Value StaticPropertyName_Value = new StaticPropertyName_Value();

  public static final SwitchCase_Test SwitchCase_Test = new SwitchCase_Test();

  public static SwitchCase_Consequent SwitchCase_Consequent(int index) {
    return new SwitchCase_Consequent(index);
  }

  public static SwitchDefault_Consequent SwitchDefault_Consequent(int index) {
    return new SwitchDefault_Consequent(index);
  }

  public static final SwitchStatement_Discriminant SwitchStatement_Discriminant = new SwitchStatement_Discriminant();

  public static SwitchStatement_Cases SwitchStatement_Cases(int index) {
    return new SwitchStatement_Cases(index);
  }

  public static final SwitchStatementWithDefault_Discriminant SwitchStatementWithDefault_Discriminant = new SwitchStatementWithDefault_Discriminant();

  public static SwitchStatementWithDefault_PreDefaultCases SwitchStatementWithDefault_PreDefaultCases(int index) {
    return new SwitchStatementWithDefault_PreDefaultCases(index);
  }

  public static final SwitchStatementWithDefault_DefaultCase SwitchStatementWithDefault_DefaultCase = new SwitchStatementWithDefault_DefaultCase();

  public static SwitchStatementWithDefault_PostDefaultCases SwitchStatementWithDefault_PostDefaultCases(int index) {
    return new SwitchStatementWithDefault_PostDefaultCases(index);
  }

  public static final TemplateElement_RawValue TemplateElement_RawValue = new TemplateElement_RawValue();

  public static final TemplateExpression_Tag TemplateExpression_Tag = new TemplateExpression_Tag();

  public static TemplateExpression_Elements TemplateExpression_Elements(int index) {
    return new TemplateExpression_Elements(index);
  }

  public static final ThrowStatement_Expression ThrowStatement_Expression = new ThrowStatement_Expression();

  public static final TryCatchStatement_Body TryCatchStatement_Body = new TryCatchStatement_Body();

  public static final TryCatchStatement_CatchClause TryCatchStatement_CatchClause = new TryCatchStatement_CatchClause();

  public static final TryFinallyStatement_Body TryFinallyStatement_Body = new TryFinallyStatement_Body();

  public static final TryFinallyStatement_CatchClause TryFinallyStatement_CatchClause = new TryFinallyStatement_CatchClause();

  public static final TryFinallyStatement_Finalizer TryFinallyStatement_Finalizer = new TryFinallyStatement_Finalizer();

  public static final UnaryExpression_Operator UnaryExpression_Operator = new UnaryExpression_Operator();

  public static final UnaryExpression_Operand UnaryExpression_Operand = new UnaryExpression_Operand();

  public static final UpdateExpression_IsPrefix UpdateExpression_IsPrefix = new UpdateExpression_IsPrefix();

  public static final UpdateExpression_Operator UpdateExpression_Operator = new UpdateExpression_Operator();

  public static final UpdateExpression_Operand UpdateExpression_Operand = new UpdateExpression_Operand();

  public static final VariableDeclaration_Kind VariableDeclaration_Kind = new VariableDeclaration_Kind();

  public static VariableDeclaration_Declarators VariableDeclaration_Declarators(int index) {
    return new VariableDeclaration_Declarators(index);
  }

  public static final VariableDeclarationStatement_Declaration VariableDeclarationStatement_Declaration = new VariableDeclarationStatement_Declaration();

  public static final VariableDeclarator_Binding VariableDeclarator_Binding = new VariableDeclarator_Binding();

  public static final VariableDeclarator_Init VariableDeclarator_Init = new VariableDeclarator_Init();

  public static final WhileStatement_Test WhileStatement_Test = new WhileStatement_Test();

  public static final WhileStatement_Body WhileStatement_Body = new WhileStatement_Body();

  public static final WithStatement_Object WithStatement_Object = new WithStatement_Object();

  public static final WithStatement_Body WithStatement_Body = new WithStatement_Body();

  public static final YieldExpression_Expression YieldExpression_Expression = new YieldExpression_Expression();

  public static final YieldGeneratorExpression_Expression YieldGeneratorExpression_Expression = new YieldGeneratorExpression_Expression();



  public static class ArrayAssignmentTarget_Elements extends ASTPath.IndexedPath<ArrayAssignmentTarget, AssignmentTargetAssignmentTargetWithDefault> {
  protected ArrayAssignmentTarget_Elements(int index) {
      super(index);
    }

    @Override
    Maybe<AssignmentTargetAssignmentTargetWithDefault> apply(Object source) {
      if (!(source instanceof ArrayAssignmentTarget)) return Maybe.empty();
      return ((ArrayAssignmentTarget) source).elements.index(index).orJust(Maybe.empty());
    }

    public String propertyName() {
      return "elements[" + index + "]";
    }
  }

  public static class ArrayAssignmentTarget_Rest extends ASTPath.TrivialPath<ArrayAssignmentTarget, AssignmentTarget> {
    @Override
    Maybe<AssignmentTarget> apply(Object source) {
      if (!(source instanceof ArrayAssignmentTarget)) return Maybe.empty();
      return ((ArrayAssignmentTarget) source).rest;
    }

    public String propertyName() {
      return "rest";
    }
  }

  public static class ArrayBinding_Elements extends ASTPath.IndexedPath<ArrayBinding, BindingBindingWithDefault> {
  protected ArrayBinding_Elements(int index) {
      super(index);
    }

    @Override
    Maybe<BindingBindingWithDefault> apply(Object source) {
      if (!(source instanceof ArrayBinding)) return Maybe.empty();
      return ((ArrayBinding) source).elements.index(index).orJust(Maybe.empty());
    }

    public String propertyName() {
      return "elements[" + index + "]";
    }
  }

  public static class ArrayBinding_Rest extends ASTPath.TrivialPath<ArrayBinding, Binding> {
    @Override
    Maybe<Binding> apply(Object source) {
      if (!(source instanceof ArrayBinding)) return Maybe.empty();
      return ((ArrayBinding) source).rest;
    }

    public String propertyName() {
      return "rest";
    }
  }

  public static class ArrayExpression_Elements extends ASTPath.IndexedPath<ArrayExpression, SpreadElementExpression> {
  protected ArrayExpression_Elements(int index) {
      super(index);
    }

    @Override
    Maybe<SpreadElementExpression> apply(Object source) {
      if (!(source instanceof ArrayExpression)) return Maybe.empty();
      return ((ArrayExpression) source).elements.index(index).orJust(Maybe.empty());
    }

    public String propertyName() {
      return "elements[" + index + "]";
    }
  }

  public static class ArrowExpression_IsAsync extends ASTPath.TrivialPath<ArrowExpression, Boolean> {
    @Override
    Maybe<Boolean> apply(Object source) {
      if (!(source instanceof ArrowExpression)) return Maybe.empty();
      return Maybe.of(((ArrowExpression) source).isAsync);
    }

    public String propertyName() {
      return "isAsync";
    }
  }

  public static class ArrowExpression_Params extends ASTPath.TrivialPath<ArrowExpression, FormalParameters> {
    @Override
    Maybe<FormalParameters> apply(Object source) {
      if (!(source instanceof ArrowExpression)) return Maybe.empty();
      return Maybe.of(((ArrowExpression) source).params);
    }

    public String propertyName() {
      return "params";
    }
  }

  public static class ArrowExpression_Body extends ASTPath.TrivialPath<ArrowExpression, FunctionBodyExpression> {
    @Override
    Maybe<FunctionBodyExpression> apply(Object source) {
      if (!(source instanceof ArrowExpression)) return Maybe.empty();
      return Maybe.of(((ArrowExpression) source).body);
    }

    public String propertyName() {
      return "body";
    }
  }

  public static class AssignmentExpression_Binding extends ASTPath.TrivialPath<AssignmentExpression, AssignmentTarget> {
    @Override
    Maybe<AssignmentTarget> apply(Object source) {
      if (!(source instanceof AssignmentExpression)) return Maybe.empty();
      return Maybe.of(((AssignmentExpression) source).binding);
    }

    public String propertyName() {
      return "binding";
    }
  }

  public static class AssignmentExpression_Expression extends ASTPath.TrivialPath<AssignmentExpression, Expression> {
    @Override
    Maybe<Expression> apply(Object source) {
      if (!(source instanceof AssignmentExpression)) return Maybe.empty();
      return Maybe.of(((AssignmentExpression) source).expression);
    }

    public String propertyName() {
      return "expression";
    }
  }

  public static class AssignmentTargetIdentifier_Name extends ASTPath.TrivialPath<AssignmentTargetIdentifier, String> {
    @Override
    Maybe<String> apply(Object source) {
      if (!(source instanceof AssignmentTargetIdentifier)) return Maybe.empty();
      return Maybe.of(((AssignmentTargetIdentifier) source).name);
    }

    public String propertyName() {
      return "name";
    }
  }

  public static class AssignmentTargetPropertyIdentifier_Binding extends ASTPath.TrivialPath<AssignmentTargetPropertyIdentifier, AssignmentTargetIdentifier> {
    @Override
    Maybe<AssignmentTargetIdentifier> apply(Object source) {
      if (!(source instanceof AssignmentTargetPropertyIdentifier)) return Maybe.empty();
      return Maybe.of(((AssignmentTargetPropertyIdentifier) source).binding);
    }

    public String propertyName() {
      return "binding";
    }
  }

  public static class AssignmentTargetPropertyIdentifier_Init extends ASTPath.TrivialPath<AssignmentTargetPropertyIdentifier, Expression> {
    @Override
    Maybe<Expression> apply(Object source) {
      if (!(source instanceof AssignmentTargetPropertyIdentifier)) return Maybe.empty();
      return ((AssignmentTargetPropertyIdentifier) source).init;
    }

    public String propertyName() {
      return "init";
    }
  }

  public static class AssignmentTargetPropertyProperty_Name extends ASTPath.TrivialPath<AssignmentTargetPropertyProperty, PropertyName> {
    @Override
    Maybe<PropertyName> apply(Object source) {
      if (!(source instanceof AssignmentTargetPropertyProperty)) return Maybe.empty();
      return Maybe.of(((AssignmentTargetPropertyProperty) source).name);
    }

    public String propertyName() {
      return "name";
    }
  }

  public static class AssignmentTargetPropertyProperty_Binding extends ASTPath.TrivialPath<AssignmentTargetPropertyProperty, AssignmentTargetAssignmentTargetWithDefault> {
    @Override
    Maybe<AssignmentTargetAssignmentTargetWithDefault> apply(Object source) {
      if (!(source instanceof AssignmentTargetPropertyProperty)) return Maybe.empty();
      return Maybe.of(((AssignmentTargetPropertyProperty) source).binding);
    }

    public String propertyName() {
      return "binding";
    }
  }

  public static class AssignmentTargetWithDefault_Binding extends ASTPath.TrivialPath<AssignmentTargetWithDefault, AssignmentTarget> {
    @Override
    Maybe<AssignmentTarget> apply(Object source) {
      if (!(source instanceof AssignmentTargetWithDefault)) return Maybe.empty();
      return Maybe.of(((AssignmentTargetWithDefault) source).binding);
    }

    public String propertyName() {
      return "binding";
    }
  }

  public static class AssignmentTargetWithDefault_Init extends ASTPath.TrivialPath<AssignmentTargetWithDefault, Expression> {
    @Override
    Maybe<Expression> apply(Object source) {
      if (!(source instanceof AssignmentTargetWithDefault)) return Maybe.empty();
      return Maybe.of(((AssignmentTargetWithDefault) source).init);
    }

    public String propertyName() {
      return "init";
    }
  }

  public static class AwaitExpression_Expression extends ASTPath.TrivialPath<AwaitExpression, Expression> {
    @Override
    Maybe<Expression> apply(Object source) {
      if (!(source instanceof AwaitExpression)) return Maybe.empty();
      return Maybe.of(((AwaitExpression) source).expression);
    }

    public String propertyName() {
      return "expression";
    }
  }

  public static class BinaryExpression_Left extends ASTPath.TrivialPath<BinaryExpression, Expression> {
    @Override
    Maybe<Expression> apply(Object source) {
      if (!(source instanceof BinaryExpression)) return Maybe.empty();
      return Maybe.of(((BinaryExpression) source).left);
    }

    public String propertyName() {
      return "left";
    }
  }

  public static class BinaryExpression_Operator extends ASTPath.TrivialPath<BinaryExpression, com.shapesecurity.shift.es2017.ast.operators.BinaryOperator> {
    @Override
    Maybe<com.shapesecurity.shift.es2017.ast.operators.BinaryOperator> apply(Object source) {
      if (!(source instanceof BinaryExpression)) return Maybe.empty();
      return Maybe.of(((BinaryExpression) source).operator);
    }

    public String propertyName() {
      return "operator";
    }
  }

  public static class BinaryExpression_Right extends ASTPath.TrivialPath<BinaryExpression, Expression> {
    @Override
    Maybe<Expression> apply(Object source) {
      if (!(source instanceof BinaryExpression)) return Maybe.empty();
      return Maybe.of(((BinaryExpression) source).right);
    }

    public String propertyName() {
      return "right";
    }
  }

  public static class BindingIdentifier_Name extends ASTPath.TrivialPath<BindingIdentifier, String> {
    @Override
    Maybe<String> apply(Object source) {
      if (!(source instanceof BindingIdentifier)) return Maybe.empty();
      return Maybe.of(((BindingIdentifier) source).name);
    }

    public String propertyName() {
      return "name";
    }
  }

  public static class BindingPropertyIdentifier_Binding extends ASTPath.TrivialPath<BindingPropertyIdentifier, BindingIdentifier> {
    @Override
    Maybe<BindingIdentifier> apply(Object source) {
      if (!(source instanceof BindingPropertyIdentifier)) return Maybe.empty();
      return Maybe.of(((BindingPropertyIdentifier) source).binding);
    }

    public String propertyName() {
      return "binding";
    }
  }

  public static class BindingPropertyIdentifier_Init extends ASTPath.TrivialPath<BindingPropertyIdentifier, Expression> {
    @Override
    Maybe<Expression> apply(Object source) {
      if (!(source instanceof BindingPropertyIdentifier)) return Maybe.empty();
      return ((BindingPropertyIdentifier) source).init;
    }

    public String propertyName() {
      return "init";
    }
  }

  public static class BindingPropertyProperty_Name extends ASTPath.TrivialPath<BindingPropertyProperty, PropertyName> {
    @Override
    Maybe<PropertyName> apply(Object source) {
      if (!(source instanceof BindingPropertyProperty)) return Maybe.empty();
      return Maybe.of(((BindingPropertyProperty) source).name);
    }

    public String propertyName() {
      return "name";
    }
  }

  public static class BindingPropertyProperty_Binding extends ASTPath.TrivialPath<BindingPropertyProperty, BindingBindingWithDefault> {
    @Override
    Maybe<BindingBindingWithDefault> apply(Object source) {
      if (!(source instanceof BindingPropertyProperty)) return Maybe.empty();
      return Maybe.of(((BindingPropertyProperty) source).binding);
    }

    public String propertyName() {
      return "binding";
    }
  }

  public static class BindingWithDefault_Binding extends ASTPath.TrivialPath<BindingWithDefault, Binding> {
    @Override
    Maybe<Binding> apply(Object source) {
      if (!(source instanceof BindingWithDefault)) return Maybe.empty();
      return Maybe.of(((BindingWithDefault) source).binding);
    }

    public String propertyName() {
      return "binding";
    }
  }

  public static class BindingWithDefault_Init extends ASTPath.TrivialPath<BindingWithDefault, Expression> {
    @Override
    Maybe<Expression> apply(Object source) {
      if (!(source instanceof BindingWithDefault)) return Maybe.empty();
      return Maybe.of(((BindingWithDefault) source).init);
    }

    public String propertyName() {
      return "init";
    }
  }

  public static class Block_Statements extends ASTPath.IndexedPath<Block, Statement> {
    protected Block_Statements(int index) {
      super(index);
    }

    @Override
    Maybe<Statement> apply(Object source) {
      if (!(source instanceof Block)) return Maybe.empty();
      return ((Block) source).statements.index(index);
    }

    public String propertyName() {
      return "statements[" + index + "]";
    }
  }

  public static class BlockStatement_Block extends ASTPath.TrivialPath<BlockStatement, Block> {
    @Override
    Maybe<Block> apply(Object source) {
      if (!(source instanceof BlockStatement)) return Maybe.empty();
      return Maybe.of(((BlockStatement) source).block);
    }

    public String propertyName() {
      return "block";
    }
  }

  public static class BreakStatement_Label extends ASTPath.TrivialPath<BreakStatement, String> {
    @Override
    Maybe<String> apply(Object source) {
      if (!(source instanceof BreakStatement)) return Maybe.empty();
      return ((BreakStatement) source).label;
    }

    public String propertyName() {
      return "label";
    }
  }

  public static class CallExpression_Callee extends ASTPath.TrivialPath<CallExpression, ExpressionSuper> {
    @Override
    Maybe<ExpressionSuper> apply(Object source) {
      if (!(source instanceof CallExpression)) return Maybe.empty();
      return Maybe.of(((CallExpression) source).callee);
    }

    public String propertyName() {
      return "callee";
    }
  }

  public static class CallExpression_Arguments extends ASTPath.IndexedPath<CallExpression, SpreadElementExpression> {
    protected CallExpression_Arguments(int index) {
      super(index);
    }

    @Override
    Maybe<SpreadElementExpression> apply(Object source) {
      if (!(source instanceof CallExpression)) return Maybe.empty();
      return ((CallExpression) source).arguments.index(index);
    }

    public String propertyName() {
      return "arguments[" + index + "]";
    }
  }

  public static class CatchClause_Binding extends ASTPath.TrivialPath<CatchClause, Binding> {
    @Override
    Maybe<Binding> apply(Object source) {
      if (!(source instanceof CatchClause)) return Maybe.empty();
      return Maybe.of(((CatchClause) source).binding);
    }

    public String propertyName() {
      return "binding";
    }
  }

  public static class CatchClause_Body extends ASTPath.TrivialPath<CatchClause, Block> {
    @Override
    Maybe<Block> apply(Object source) {
      if (!(source instanceof CatchClause)) return Maybe.empty();
      return Maybe.of(((CatchClause) source).body);
    }

    public String propertyName() {
      return "body";
    }
  }

  public static class ClassDeclaration_Name extends ASTPath.TrivialPath<ClassDeclaration, BindingIdentifier> {
    @Override
    Maybe<BindingIdentifier> apply(Object source) {
      if (!(source instanceof ClassDeclaration)) return Maybe.empty();
      return Maybe.of(((ClassDeclaration) source).name);
    }

    public String propertyName() {
      return "name";
    }
  }

  public static class ClassDeclaration_Super extends ASTPath.TrivialPath<ClassDeclaration, Expression> {
    @Override
    Maybe<Expression> apply(Object source) {
      if (!(source instanceof ClassDeclaration)) return Maybe.empty();
      return ((ClassDeclaration) source)._super;
    }

    public String propertyName() {
      return "super";
    }
  }

  public static class ClassDeclaration_Elements extends ASTPath.IndexedPath<ClassDeclaration, ClassElement> {
    protected ClassDeclaration_Elements(int index) {
      super(index);
    }

    @Override
    Maybe<ClassElement> apply(Object source) {
      if (!(source instanceof ClassDeclaration)) return Maybe.empty();
      return ((ClassDeclaration) source).elements.index(index);
    }

    public String propertyName() {
      return "elements[" + index + "]";
    }
  }

  public static class ClassElement_IsStatic extends ASTPath.TrivialPath<ClassElement, Boolean> {
    @Override
    Maybe<Boolean> apply(Object source) {
      if (!(source instanceof ClassElement)) return Maybe.empty();
      return Maybe.of(((ClassElement) source).isStatic);
    }

    public String propertyName() {
      return "isStatic";
    }
  }

  public static class ClassElement_Method extends ASTPath.TrivialPath<ClassElement, MethodDefinition> {
    @Override
    Maybe<MethodDefinition> apply(Object source) {
      if (!(source instanceof ClassElement)) return Maybe.empty();
      return Maybe.of(((ClassElement) source).method);
    }

    public String propertyName() {
      return "method";
    }
  }

  public static class ClassExpression_Name extends ASTPath.TrivialPath<ClassExpression, BindingIdentifier> {
    @Override
    Maybe<BindingIdentifier> apply(Object source) {
      if (!(source instanceof ClassExpression)) return Maybe.empty();
      return ((ClassExpression) source).name;
    }

    public String propertyName() {
      return "name";
    }
  }

  public static class ClassExpression_Super extends ASTPath.TrivialPath<ClassExpression, Expression> {
    @Override
    Maybe<Expression> apply(Object source) {
      if (!(source instanceof ClassExpression)) return Maybe.empty();
      return ((ClassExpression) source)._super;
    }

    public String propertyName() {
      return "super";
    }
  }

  public static class ClassExpression_Elements extends ASTPath.IndexedPath<ClassExpression, ClassElement> {
    protected ClassExpression_Elements(int index) {
      super(index);
    }

    @Override
    Maybe<ClassElement> apply(Object source) {
      if (!(source instanceof ClassExpression)) return Maybe.empty();
      return ((ClassExpression) source).elements.index(index);
    }

    public String propertyName() {
      return "elements[" + index + "]";
    }
  }

  public static class CompoundAssignmentExpression_Binding extends ASTPath.TrivialPath<CompoundAssignmentExpression, SimpleAssignmentTarget> {
    @Override
    Maybe<SimpleAssignmentTarget> apply(Object source) {
      if (!(source instanceof CompoundAssignmentExpression)) return Maybe.empty();
      return Maybe.of(((CompoundAssignmentExpression) source).binding);
    }

    public String propertyName() {
      return "binding";
    }
  }

  public static class CompoundAssignmentExpression_Operator extends ASTPath.TrivialPath<CompoundAssignmentExpression, com.shapesecurity.shift.es2017.ast.operators.CompoundAssignmentOperator> {
    @Override
    Maybe<com.shapesecurity.shift.es2017.ast.operators.CompoundAssignmentOperator> apply(Object source) {
      if (!(source instanceof CompoundAssignmentExpression)) return Maybe.empty();
      return Maybe.of(((CompoundAssignmentExpression) source).operator);
    }

    public String propertyName() {
      return "operator";
    }
  }

  public static class CompoundAssignmentExpression_Expression extends ASTPath.TrivialPath<CompoundAssignmentExpression, Expression> {
    @Override
    Maybe<Expression> apply(Object source) {
      if (!(source instanceof CompoundAssignmentExpression)) return Maybe.empty();
      return Maybe.of(((CompoundAssignmentExpression) source).expression);
    }

    public String propertyName() {
      return "expression";
    }
  }

  public static class ComputedMemberAssignmentTarget_Object extends ASTPath.TrivialPath<ComputedMemberAssignmentTarget, ExpressionSuper> {
    @Override
    Maybe<ExpressionSuper> apply(Object source) {
      if (!(source instanceof ComputedMemberAssignmentTarget)) return Maybe.empty();
      return Maybe.of(((ComputedMemberAssignmentTarget) source).object);
    }

    public String propertyName() {
      return "object";
    }
  }

  public static class ComputedMemberAssignmentTarget_Expression extends ASTPath.TrivialPath<ComputedMemberAssignmentTarget, Expression> {
    @Override
    Maybe<Expression> apply(Object source) {
      if (!(source instanceof ComputedMemberAssignmentTarget)) return Maybe.empty();
      return Maybe.of(((ComputedMemberAssignmentTarget) source).expression);
    }

    public String propertyName() {
      return "expression";
    }
  }

  public static class ComputedMemberExpression_Object extends ASTPath.TrivialPath<ComputedMemberExpression, ExpressionSuper> {
    @Override
    Maybe<ExpressionSuper> apply(Object source) {
      if (!(source instanceof ComputedMemberExpression)) return Maybe.empty();
      return Maybe.of(((ComputedMemberExpression) source).object);
    }

    public String propertyName() {
      return "object";
    }
  }

  public static class ComputedMemberExpression_Expression extends ASTPath.TrivialPath<ComputedMemberExpression, Expression> {
    @Override
    Maybe<Expression> apply(Object source) {
      if (!(source instanceof ComputedMemberExpression)) return Maybe.empty();
      return Maybe.of(((ComputedMemberExpression) source).expression);
    }

    public String propertyName() {
      return "expression";
    }
  }

  public static class ComputedPropertyName_Expression extends ASTPath.TrivialPath<ComputedPropertyName, Expression> {
    @Override
    Maybe<Expression> apply(Object source) {
      if (!(source instanceof ComputedPropertyName)) return Maybe.empty();
      return Maybe.of(((ComputedPropertyName) source).expression);
    }

    public String propertyName() {
      return "expression";
    }
  }

  public static class ConditionalExpression_Test extends ASTPath.TrivialPath<ConditionalExpression, Expression> {
    @Override
    Maybe<Expression> apply(Object source) {
      if (!(source instanceof ConditionalExpression)) return Maybe.empty();
      return Maybe.of(((ConditionalExpression) source).test);
    }

    public String propertyName() {
      return "test";
    }
  }

  public static class ConditionalExpression_Consequent extends ASTPath.TrivialPath<ConditionalExpression, Expression> {
    @Override
    Maybe<Expression> apply(Object source) {
      if (!(source instanceof ConditionalExpression)) return Maybe.empty();
      return Maybe.of(((ConditionalExpression) source).consequent);
    }

    public String propertyName() {
      return "consequent";
    }
  }

  public static class ConditionalExpression_Alternate extends ASTPath.TrivialPath<ConditionalExpression, Expression> {
    @Override
    Maybe<Expression> apply(Object source) {
      if (!(source instanceof ConditionalExpression)) return Maybe.empty();
      return Maybe.of(((ConditionalExpression) source).alternate);
    }

    public String propertyName() {
      return "alternate";
    }
  }

  public static class ContinueStatement_Label extends ASTPath.TrivialPath<ContinueStatement, String> {
    @Override
    Maybe<String> apply(Object source) {
      if (!(source instanceof ContinueStatement)) return Maybe.empty();
      return ((ContinueStatement) source).label;
    }

    public String propertyName() {
      return "label";
    }
  }

  public static class DataProperty_Name extends ASTPath.TrivialPath<DataProperty, PropertyName> {
    @Override
    Maybe<PropertyName> apply(Object source) {
      if (!(source instanceof DataProperty)) return Maybe.empty();
      return Maybe.of(((DataProperty) source).name);
    }

    public String propertyName() {
      return "name";
    }
  }

  public static class DataProperty_Expression extends ASTPath.TrivialPath<DataProperty, Expression> {
    @Override
    Maybe<Expression> apply(Object source) {
      if (!(source instanceof DataProperty)) return Maybe.empty();
      return Maybe.of(((DataProperty) source).expression);
    }

    public String propertyName() {
      return "expression";
    }
  }

  public static class Directive_RawValue extends ASTPath.TrivialPath<Directive, String> {
    @Override
    Maybe<String> apply(Object source) {
      if (!(source instanceof Directive)) return Maybe.empty();
      return Maybe.of(((Directive) source).rawValue);
    }

    public String propertyName() {
      return "rawValue";
    }
  }

  public static class DoWhileStatement_Body extends ASTPath.TrivialPath<DoWhileStatement, Statement> {
    @Override
    Maybe<Statement> apply(Object source) {
      if (!(source instanceof DoWhileStatement)) return Maybe.empty();
      return Maybe.of(((DoWhileStatement) source).body);
    }

    public String propertyName() {
      return "body";
    }
  }

  public static class DoWhileStatement_Test extends ASTPath.TrivialPath<DoWhileStatement, Expression> {
    @Override
    Maybe<Expression> apply(Object source) {
      if (!(source instanceof DoWhileStatement)) return Maybe.empty();
      return Maybe.of(((DoWhileStatement) source).test);
    }

    public String propertyName() {
      return "test";
    }
  }

  public static class Export_Declaration extends ASTPath.TrivialPath<Export, FunctionDeclarationClassDeclarationVariableDeclaration> {
    @Override
    Maybe<FunctionDeclarationClassDeclarationVariableDeclaration> apply(Object source) {
      if (!(source instanceof Export)) return Maybe.empty();
      return Maybe.of(((Export) source).declaration);
    }

    public String propertyName() {
      return "declaration";
    }
  }

  public static class ExportAllFrom_ModuleSpecifier extends ASTPath.TrivialPath<ExportAllFrom, String> {
    @Override
    Maybe<String> apply(Object source) {
      if (!(source instanceof ExportAllFrom)) return Maybe.empty();
      return Maybe.of(((ExportAllFrom) source).moduleSpecifier);
    }

    public String propertyName() {
      return "moduleSpecifier";
    }
  }

  public static class ExportDefault_Body extends ASTPath.TrivialPath<ExportDefault, FunctionDeclarationClassDeclarationExpression> {
    @Override
    Maybe<FunctionDeclarationClassDeclarationExpression> apply(Object source) {
      if (!(source instanceof ExportDefault)) return Maybe.empty();
      return Maybe.of(((ExportDefault) source).body);
    }

    public String propertyName() {
      return "body";
    }
  }

  public static class ExportFrom_NamedExports extends ASTPath.IndexedPath<ExportFrom, ExportFromSpecifier> {
    protected ExportFrom_NamedExports(int index) {
      super(index);
    }

    @Override
    Maybe<ExportFromSpecifier> apply(Object source) {
      if (!(source instanceof ExportFrom)) return Maybe.empty();
      return ((ExportFrom) source).namedExports.index(index);
    }

    public String propertyName() {
      return "namedExports[" + index + "]";
    }
  }

  public static class ExportFrom_ModuleSpecifier extends ASTPath.TrivialPath<ExportFrom, String> {
    @Override
    Maybe<String> apply(Object source) {
      if (!(source instanceof ExportFrom)) return Maybe.empty();
      return Maybe.of(((ExportFrom) source).moduleSpecifier);
    }

    public String propertyName() {
      return "moduleSpecifier";
    }
  }

  public static class ExportFromSpecifier_Name extends ASTPath.TrivialPath<ExportFromSpecifier, String> {
    @Override
    Maybe<String> apply(Object source) {
      if (!(source instanceof ExportFromSpecifier)) return Maybe.empty();
      return Maybe.of(((ExportFromSpecifier) source).name);
    }

    public String propertyName() {
      return "name";
    }
  }

  public static class ExportFromSpecifier_ExportedName extends ASTPath.TrivialPath<ExportFromSpecifier, String> {
    @Override
    Maybe<String> apply(Object source) {
      if (!(source instanceof ExportFromSpecifier)) return Maybe.empty();
      return ((ExportFromSpecifier) source).exportedName;
    }

    public String propertyName() {
      return "exportedName";
    }
  }

  public static class ExportLocalSpecifier_Name extends ASTPath.TrivialPath<ExportLocalSpecifier, IdentifierExpression> {
    @Override
    Maybe<IdentifierExpression> apply(Object source) {
      if (!(source instanceof ExportLocalSpecifier)) return Maybe.empty();
      return Maybe.of(((ExportLocalSpecifier) source).name);
    }

    public String propertyName() {
      return "name";
    }
  }

  public static class ExportLocalSpecifier_ExportedName extends ASTPath.TrivialPath<ExportLocalSpecifier, String> {
    @Override
    Maybe<String> apply(Object source) {
      if (!(source instanceof ExportLocalSpecifier)) return Maybe.empty();
      return ((ExportLocalSpecifier) source).exportedName;
    }

    public String propertyName() {
      return "exportedName";
    }
  }

  public static class ExportLocals_NamedExports extends ASTPath.IndexedPath<ExportLocals, ExportLocalSpecifier> {
    protected ExportLocals_NamedExports(int index) {
      super(index);
    }

    @Override
    Maybe<ExportLocalSpecifier> apply(Object source) {
      if (!(source instanceof ExportLocals)) return Maybe.empty();
      return ((ExportLocals) source).namedExports.index(index);
    }

    public String propertyName() {
      return "namedExports[" + index + "]";
    }
  }

  public static class ExpressionStatement_Expression extends ASTPath.TrivialPath<ExpressionStatement, Expression> {
    @Override
    Maybe<Expression> apply(Object source) {
      if (!(source instanceof ExpressionStatement)) return Maybe.empty();
      return Maybe.of(((ExpressionStatement) source).expression);
    }

    public String propertyName() {
      return "expression";
    }
  }

  public static class ForInStatement_Left extends ASTPath.TrivialPath<ForInStatement, VariableDeclarationAssignmentTarget> {
    @Override
    Maybe<VariableDeclarationAssignmentTarget> apply(Object source) {
      if (!(source instanceof ForInStatement)) return Maybe.empty();
      return Maybe.of(((ForInStatement) source).left);
    }

    public String propertyName() {
      return "left";
    }
  }

  public static class ForInStatement_Right extends ASTPath.TrivialPath<ForInStatement, Expression> {
    @Override
    Maybe<Expression> apply(Object source) {
      if (!(source instanceof ForInStatement)) return Maybe.empty();
      return Maybe.of(((ForInStatement) source).right);
    }

    public String propertyName() {
      return "right";
    }
  }

  public static class ForInStatement_Body extends ASTPath.TrivialPath<ForInStatement, Statement> {
    @Override
    Maybe<Statement> apply(Object source) {
      if (!(source instanceof ForInStatement)) return Maybe.empty();
      return Maybe.of(((ForInStatement) source).body);
    }

    public String propertyName() {
      return "body";
    }
  }

  public static class ForOfStatement_Left extends ASTPath.TrivialPath<ForOfStatement, VariableDeclarationAssignmentTarget> {
    @Override
    Maybe<VariableDeclarationAssignmentTarget> apply(Object source) {
      if (!(source instanceof ForOfStatement)) return Maybe.empty();
      return Maybe.of(((ForOfStatement) source).left);
    }

    public String propertyName() {
      return "left";
    }
  }

  public static class ForOfStatement_Right extends ASTPath.TrivialPath<ForOfStatement, Expression> {
    @Override
    Maybe<Expression> apply(Object source) {
      if (!(source instanceof ForOfStatement)) return Maybe.empty();
      return Maybe.of(((ForOfStatement) source).right);
    }

    public String propertyName() {
      return "right";
    }
  }

  public static class ForOfStatement_Body extends ASTPath.TrivialPath<ForOfStatement, Statement> {
    @Override
    Maybe<Statement> apply(Object source) {
      if (!(source instanceof ForOfStatement)) return Maybe.empty();
      return Maybe.of(((ForOfStatement) source).body);
    }

    public String propertyName() {
      return "body";
    }
  }

  public static class ForStatement_Init extends ASTPath.TrivialPath<ForStatement, VariableDeclarationExpression> {
    @Override
    Maybe<VariableDeclarationExpression> apply(Object source) {
      if (!(source instanceof ForStatement)) return Maybe.empty();
      return ((ForStatement) source).init;
    }

    public String propertyName() {
      return "init";
    }
  }

  public static class ForStatement_Test extends ASTPath.TrivialPath<ForStatement, Expression> {
    @Override
    Maybe<Expression> apply(Object source) {
      if (!(source instanceof ForStatement)) return Maybe.empty();
      return ((ForStatement) source).test;
    }

    public String propertyName() {
      return "test";
    }
  }

  public static class ForStatement_Update extends ASTPath.TrivialPath<ForStatement, Expression> {
    @Override
    Maybe<Expression> apply(Object source) {
      if (!(source instanceof ForStatement)) return Maybe.empty();
      return ((ForStatement) source).update;
    }

    public String propertyName() {
      return "update";
    }
  }

  public static class ForStatement_Body extends ASTPath.TrivialPath<ForStatement, Statement> {
    @Override
    Maybe<Statement> apply(Object source) {
      if (!(source instanceof ForStatement)) return Maybe.empty();
      return Maybe.of(((ForStatement) source).body);
    }

    public String propertyName() {
      return "body";
    }
  }

  public static class FormalParameters_Items extends ASTPath.IndexedPath<FormalParameters, Parameter> {
    protected FormalParameters_Items(int index) {
      super(index);
    }

    @Override
    Maybe<Parameter> apply(Object source) {
      if (!(source instanceof FormalParameters)) return Maybe.empty();
      return ((FormalParameters) source).items.index(index);
    }

    public String propertyName() {
      return "items[" + index + "]";
    }
  }

  public static class FormalParameters_Rest extends ASTPath.TrivialPath<FormalParameters, Binding> {
    @Override
    Maybe<Binding> apply(Object source) {
      if (!(source instanceof FormalParameters)) return Maybe.empty();
      return ((FormalParameters) source).rest;
    }

    public String propertyName() {
      return "rest";
    }
  }

  public static class FunctionBody_Directives extends ASTPath.IndexedPath<FunctionBody, Directive> {
    protected FunctionBody_Directives(int index) {
      super(index);
    }

    @Override
    Maybe<Directive> apply(Object source) {
      if (!(source instanceof FunctionBody)) return Maybe.empty();
      return ((FunctionBody) source).directives.index(index);
    }

    public String propertyName() {
      return "directives[" + index + "]";
    }
  }

  public static class FunctionBody_Statements extends ASTPath.IndexedPath<FunctionBody, Statement> {
    protected FunctionBody_Statements(int index) {
      super(index);
    }

    @Override
    Maybe<Statement> apply(Object source) {
      if (!(source instanceof FunctionBody)) return Maybe.empty();
      return ((FunctionBody) source).statements.index(index);
    }

    public String propertyName() {
      return "statements[" + index + "]";
    }
  }

  public static class FunctionDeclaration_IsAsync extends ASTPath.TrivialPath<FunctionDeclaration, Boolean> {
    @Override
    Maybe<Boolean> apply(Object source) {
      if (!(source instanceof FunctionDeclaration)) return Maybe.empty();
      return Maybe.of(((FunctionDeclaration) source).isAsync);
    }

    public String propertyName() {
      return "isAsync";
    }
  }

  public static class FunctionDeclaration_IsGenerator extends ASTPath.TrivialPath<FunctionDeclaration, Boolean> {
    @Override
    Maybe<Boolean> apply(Object source) {
      if (!(source instanceof FunctionDeclaration)) return Maybe.empty();
      return Maybe.of(((FunctionDeclaration) source).isGenerator);
    }

    public String propertyName() {
      return "isGenerator";
    }
  }

  public static class FunctionDeclaration_Name extends ASTPath.TrivialPath<FunctionDeclaration, BindingIdentifier> {
    @Override
    Maybe<BindingIdentifier> apply(Object source) {
      if (!(source instanceof FunctionDeclaration)) return Maybe.empty();
      return Maybe.of(((FunctionDeclaration) source).name);
    }

    public String propertyName() {
      return "name";
    }
  }

  public static class FunctionDeclaration_Params extends ASTPath.TrivialPath<FunctionDeclaration, FormalParameters> {
    @Override
    Maybe<FormalParameters> apply(Object source) {
      if (!(source instanceof FunctionDeclaration)) return Maybe.empty();
      return Maybe.of(((FunctionDeclaration) source).params);
    }

    public String propertyName() {
      return "params";
    }
  }

  public static class FunctionDeclaration_Body extends ASTPath.TrivialPath<FunctionDeclaration, FunctionBody> {
    @Override
    Maybe<FunctionBody> apply(Object source) {
      if (!(source instanceof FunctionDeclaration)) return Maybe.empty();
      return Maybe.of(((FunctionDeclaration) source).body);
    }

    public String propertyName() {
      return "body";
    }
  }

  public static class FunctionExpression_IsAsync extends ASTPath.TrivialPath<FunctionExpression, Boolean> {
    @Override
    Maybe<Boolean> apply(Object source) {
      if (!(source instanceof FunctionExpression)) return Maybe.empty();
      return Maybe.of(((FunctionExpression) source).isAsync);
    }

    public String propertyName() {
      return "isAsync";
    }
  }

  public static class FunctionExpression_IsGenerator extends ASTPath.TrivialPath<FunctionExpression, Boolean> {
    @Override
    Maybe<Boolean> apply(Object source) {
      if (!(source instanceof FunctionExpression)) return Maybe.empty();
      return Maybe.of(((FunctionExpression) source).isGenerator);
    }

    public String propertyName() {
      return "isGenerator";
    }
  }

  public static class FunctionExpression_Name extends ASTPath.TrivialPath<FunctionExpression, BindingIdentifier> {
    @Override
    Maybe<BindingIdentifier> apply(Object source) {
      if (!(source instanceof FunctionExpression)) return Maybe.empty();
      return ((FunctionExpression) source).name;
    }

    public String propertyName() {
      return "name";
    }
  }

  public static class FunctionExpression_Params extends ASTPath.TrivialPath<FunctionExpression, FormalParameters> {
    @Override
    Maybe<FormalParameters> apply(Object source) {
      if (!(source instanceof FunctionExpression)) return Maybe.empty();
      return Maybe.of(((FunctionExpression) source).params);
    }

    public String propertyName() {
      return "params";
    }
  }

  public static class FunctionExpression_Body extends ASTPath.TrivialPath<FunctionExpression, FunctionBody> {
    @Override
    Maybe<FunctionBody> apply(Object source) {
      if (!(source instanceof FunctionExpression)) return Maybe.empty();
      return Maybe.of(((FunctionExpression) source).body);
    }

    public String propertyName() {
      return "body";
    }
  }

  public static class Getter_Name extends ASTPath.TrivialPath<Getter, PropertyName> {
    @Override
    Maybe<PropertyName> apply(Object source) {
      if (!(source instanceof Getter)) return Maybe.empty();
      return Maybe.of(((Getter) source).name);
    }

    public String propertyName() {
      return "name";
    }
  }

  public static class Getter_Body extends ASTPath.TrivialPath<Getter, FunctionBody> {
    @Override
    Maybe<FunctionBody> apply(Object source) {
      if (!(source instanceof Getter)) return Maybe.empty();
      return Maybe.of(((Getter) source).body);
    }

    public String propertyName() {
      return "body";
    }
  }

  public static class IdentifierExpression_Name extends ASTPath.TrivialPath<IdentifierExpression, String> {
    @Override
    Maybe<String> apply(Object source) {
      if (!(source instanceof IdentifierExpression)) return Maybe.empty();
      return Maybe.of(((IdentifierExpression) source).name);
    }

    public String propertyName() {
      return "name";
    }
  }

  public static class IfStatement_Test extends ASTPath.TrivialPath<IfStatement, Expression> {
    @Override
    Maybe<Expression> apply(Object source) {
      if (!(source instanceof IfStatement)) return Maybe.empty();
      return Maybe.of(((IfStatement) source).test);
    }

    public String propertyName() {
      return "test";
    }
  }

  public static class IfStatement_Consequent extends ASTPath.TrivialPath<IfStatement, Statement> {
    @Override
    Maybe<Statement> apply(Object source) {
      if (!(source instanceof IfStatement)) return Maybe.empty();
      return Maybe.of(((IfStatement) source).consequent);
    }

    public String propertyName() {
      return "consequent";
    }
  }

  public static class IfStatement_Alternate extends ASTPath.TrivialPath<IfStatement, Statement> {
    @Override
    Maybe<Statement> apply(Object source) {
      if (!(source instanceof IfStatement)) return Maybe.empty();
      return ((IfStatement) source).alternate;
    }

    public String propertyName() {
      return "alternate";
    }
  }

  public static class Import_DefaultBinding extends ASTPath.TrivialPath<Import, BindingIdentifier> {
    @Override
    Maybe<BindingIdentifier> apply(Object source) {
      if (!(source instanceof Import)) return Maybe.empty();
      return ((Import) source).defaultBinding;
    }

    public String propertyName() {
      return "defaultBinding";
    }
  }

  public static class Import_NamedImports extends ASTPath.IndexedPath<Import, ImportSpecifier> {
    protected Import_NamedImports(int index) {
      super(index);
    }

    @Override
    Maybe<ImportSpecifier> apply(Object source) {
      if (!(source instanceof Import)) return Maybe.empty();
      return ((Import) source).namedImports.index(index);
    }

    public String propertyName() {
      return "namedImports[" + index + "]";
    }
  }

  public static class Import_ModuleSpecifier extends ASTPath.TrivialPath<Import, String> {
    @Override
    Maybe<String> apply(Object source) {
      if (!(source instanceof Import)) return Maybe.empty();
      return Maybe.of(((Import) source).moduleSpecifier);
    }

    public String propertyName() {
      return "moduleSpecifier";
    }
  }

  public static class ImportNamespace_DefaultBinding extends ASTPath.TrivialPath<ImportNamespace, BindingIdentifier> {
    @Override
    Maybe<BindingIdentifier> apply(Object source) {
      if (!(source instanceof ImportNamespace)) return Maybe.empty();
      return ((ImportNamespace) source).defaultBinding;
    }

    public String propertyName() {
      return "defaultBinding";
    }
  }

  public static class ImportNamespace_NamespaceBinding extends ASTPath.TrivialPath<ImportNamespace, BindingIdentifier> {
    @Override
    Maybe<BindingIdentifier> apply(Object source) {
      if (!(source instanceof ImportNamespace)) return Maybe.empty();
      return Maybe.of(((ImportNamespace) source).namespaceBinding);
    }

    public String propertyName() {
      return "namespaceBinding";
    }
  }

  public static class ImportNamespace_ModuleSpecifier extends ASTPath.TrivialPath<ImportNamespace, String> {
    @Override
    Maybe<String> apply(Object source) {
      if (!(source instanceof ImportNamespace)) return Maybe.empty();
      return Maybe.of(((ImportNamespace) source).moduleSpecifier);
    }

    public String propertyName() {
      return "moduleSpecifier";
    }
  }

  public static class ImportSpecifier_Name extends ASTPath.TrivialPath<ImportSpecifier, String> {
    @Override
    Maybe<String> apply(Object source) {
      if (!(source instanceof ImportSpecifier)) return Maybe.empty();
      return ((ImportSpecifier) source).name;
    }

    public String propertyName() {
      return "name";
    }
  }

  public static class ImportSpecifier_Binding extends ASTPath.TrivialPath<ImportSpecifier, BindingIdentifier> {
    @Override
    Maybe<BindingIdentifier> apply(Object source) {
      if (!(source instanceof ImportSpecifier)) return Maybe.empty();
      return Maybe.of(((ImportSpecifier) source).binding);
    }

    public String propertyName() {
      return "binding";
    }
  }

  public static class LabeledStatement_Label extends ASTPath.TrivialPath<LabeledStatement, String> {
    @Override
    Maybe<String> apply(Object source) {
      if (!(source instanceof LabeledStatement)) return Maybe.empty();
      return Maybe.of(((LabeledStatement) source).label);
    }

    public String propertyName() {
      return "label";
    }
  }

  public static class LabeledStatement_Body extends ASTPath.TrivialPath<LabeledStatement, Statement> {
    @Override
    Maybe<Statement> apply(Object source) {
      if (!(source instanceof LabeledStatement)) return Maybe.empty();
      return Maybe.of(((LabeledStatement) source).body);
    }

    public String propertyName() {
      return "body";
    }
  }

  public static class LiteralBooleanExpression_Value extends ASTPath.TrivialPath<LiteralBooleanExpression, Boolean> {
    @Override
    Maybe<Boolean> apply(Object source) {
      if (!(source instanceof LiteralBooleanExpression)) return Maybe.empty();
      return Maybe.of(((LiteralBooleanExpression) source).value);
    }

    public String propertyName() {
      return "value";
    }
  }

  public static class LiteralNumericExpression_Value extends ASTPath.TrivialPath<LiteralNumericExpression, Double> {
    @Override
    Maybe<Double> apply(Object source) {
      if (!(source instanceof LiteralNumericExpression)) return Maybe.empty();
      return Maybe.of(((LiteralNumericExpression) source).value);
    }

    public String propertyName() {
      return "value";
    }
  }

  public static class LiteralRegExpExpression_Pattern extends ASTPath.TrivialPath<LiteralRegExpExpression, String> {
    @Override
    Maybe<String> apply(Object source) {
      if (!(source instanceof LiteralRegExpExpression)) return Maybe.empty();
      return Maybe.of(((LiteralRegExpExpression) source).pattern);
    }

    public String propertyName() {
      return "pattern";
    }
  }

  public static class LiteralRegExpExpression_Global extends ASTPath.TrivialPath<LiteralRegExpExpression, Boolean> {
    @Override
    Maybe<Boolean> apply(Object source) {
      if (!(source instanceof LiteralRegExpExpression)) return Maybe.empty();
      return Maybe.of(((LiteralRegExpExpression) source).global);
    }

    public String propertyName() {
      return "global";
    }
  }

  public static class LiteralRegExpExpression_IgnoreCase extends ASTPath.TrivialPath<LiteralRegExpExpression, Boolean> {
    @Override
    Maybe<Boolean> apply(Object source) {
      if (!(source instanceof LiteralRegExpExpression)) return Maybe.empty();
      return Maybe.of(((LiteralRegExpExpression) source).ignoreCase);
    }

    public String propertyName() {
      return "ignoreCase";
    }
  }

  public static class LiteralRegExpExpression_MultiLine extends ASTPath.TrivialPath<LiteralRegExpExpression, Boolean> {
    @Override
    Maybe<Boolean> apply(Object source) {
      if (!(source instanceof LiteralRegExpExpression)) return Maybe.empty();
      return Maybe.of(((LiteralRegExpExpression) source).multiLine);
    }

    public String propertyName() {
      return "multiLine";
    }
  }

  public static class LiteralRegExpExpression_Sticky extends ASTPath.TrivialPath<LiteralRegExpExpression, Boolean> {
    @Override
    Maybe<Boolean> apply(Object source) {
      if (!(source instanceof LiteralRegExpExpression)) return Maybe.empty();
      return Maybe.of(((LiteralRegExpExpression) source).sticky);
    }

    public String propertyName() {
      return "sticky";
    }
  }

  public static class LiteralRegExpExpression_Unicode extends ASTPath.TrivialPath<LiteralRegExpExpression, Boolean> {
    @Override
    Maybe<Boolean> apply(Object source) {
      if (!(source instanceof LiteralRegExpExpression)) return Maybe.empty();
      return Maybe.of(((LiteralRegExpExpression) source).unicode);
    }

    public String propertyName() {
      return "unicode";
    }
  }

  public static class LiteralStringExpression_Value extends ASTPath.TrivialPath<LiteralStringExpression, String> {
    @Override
    Maybe<String> apply(Object source) {
      if (!(source instanceof LiteralStringExpression)) return Maybe.empty();
      return Maybe.of(((LiteralStringExpression) source).value);
    }

    public String propertyName() {
      return "value";
    }
  }

  public static class Method_IsAsync extends ASTPath.TrivialPath<Method, Boolean> {
    @Override
    Maybe<Boolean> apply(Object source) {
      if (!(source instanceof Method)) return Maybe.empty();
      return Maybe.of(((Method) source).isAsync);
    }

    public String propertyName() {
      return "isAsync";
    }
  }

  public static class Method_IsGenerator extends ASTPath.TrivialPath<Method, Boolean> {
    @Override
    Maybe<Boolean> apply(Object source) {
      if (!(source instanceof Method)) return Maybe.empty();
      return Maybe.of(((Method) source).isGenerator);
    }

    public String propertyName() {
      return "isGenerator";
    }
  }

  public static class Method_Name extends ASTPath.TrivialPath<Method, PropertyName> {
    @Override
    Maybe<PropertyName> apply(Object source) {
      if (!(source instanceof Method)) return Maybe.empty();
      return Maybe.of(((Method) source).name);
    }

    public String propertyName() {
      return "name";
    }
  }

  public static class Method_Params extends ASTPath.TrivialPath<Method, FormalParameters> {
    @Override
    Maybe<FormalParameters> apply(Object source) {
      if (!(source instanceof Method)) return Maybe.empty();
      return Maybe.of(((Method) source).params);
    }

    public String propertyName() {
      return "params";
    }
  }

  public static class Method_Body extends ASTPath.TrivialPath<Method, FunctionBody> {
    @Override
    Maybe<FunctionBody> apply(Object source) {
      if (!(source instanceof Method)) return Maybe.empty();
      return Maybe.of(((Method) source).body);
    }

    public String propertyName() {
      return "body";
    }
  }

  public static class Module_Directives extends ASTPath.IndexedPath<Module, Directive> {
    protected Module_Directives(int index) {
      super(index);
    }

    @Override
    Maybe<Directive> apply(Object source) {
      if (!(source instanceof Module)) return Maybe.empty();
      return ((Module) source).directives.index(index);
    }

    public String propertyName() {
      return "directives[" + index + "]";
    }
  }

  public static class Module_Items extends ASTPath.IndexedPath<Module, ImportDeclarationExportDeclarationStatement> {
    protected Module_Items(int index) {
      super(index);
    }

    @Override
    Maybe<ImportDeclarationExportDeclarationStatement> apply(Object source) {
      if (!(source instanceof Module)) return Maybe.empty();
      return ((Module) source).items.index(index);
    }

    public String propertyName() {
      return "items[" + index + "]";
    }
  }

  public static class NewExpression_Callee extends ASTPath.TrivialPath<NewExpression, Expression> {
    @Override
    Maybe<Expression> apply(Object source) {
      if (!(source instanceof NewExpression)) return Maybe.empty();
      return Maybe.of(((NewExpression) source).callee);
    }

    public String propertyName() {
      return "callee";
    }
  }

  public static class NewExpression_Arguments extends ASTPath.IndexedPath<NewExpression, SpreadElementExpression> {
    protected NewExpression_Arguments(int index) {
      super(index);
    }

    @Override
    Maybe<SpreadElementExpression> apply(Object source) {
      if (!(source instanceof NewExpression)) return Maybe.empty();
      return ((NewExpression) source).arguments.index(index);
    }

    public String propertyName() {
      return "arguments[" + index + "]";
    }
  }

  public static class ObjectAssignmentTarget_Properties extends ASTPath.IndexedPath<ObjectAssignmentTarget, AssignmentTargetProperty> {
    protected ObjectAssignmentTarget_Properties(int index) {
      super(index);
    }

    @Override
    Maybe<AssignmentTargetProperty> apply(Object source) {
      if (!(source instanceof ObjectAssignmentTarget)) return Maybe.empty();
      return ((ObjectAssignmentTarget) source).properties.index(index);
    }

    public String propertyName() {
      return "properties[" + index + "]";
    }
  }

  public static class ObjectBinding_Properties extends ASTPath.IndexedPath<ObjectBinding, BindingProperty> {
    protected ObjectBinding_Properties(int index) {
      super(index);
    }

    @Override
    Maybe<BindingProperty> apply(Object source) {
      if (!(source instanceof ObjectBinding)) return Maybe.empty();
      return ((ObjectBinding) source).properties.index(index);
    }

    public String propertyName() {
      return "properties[" + index + "]";
    }
  }

  public static class ObjectExpression_Properties extends ASTPath.IndexedPath<ObjectExpression, ObjectProperty> {
    protected ObjectExpression_Properties(int index) {
      super(index);
    }

    @Override
    Maybe<ObjectProperty> apply(Object source) {
      if (!(source instanceof ObjectExpression)) return Maybe.empty();
      return ((ObjectExpression) source).properties.index(index);
    }

    public String propertyName() {
      return "properties[" + index + "]";
    }
  }

  public static class ReturnStatement_Expression extends ASTPath.TrivialPath<ReturnStatement, Expression> {
    @Override
    Maybe<Expression> apply(Object source) {
      if (!(source instanceof ReturnStatement)) return Maybe.empty();
      return ((ReturnStatement) source).expression;
    }

    public String propertyName() {
      return "expression";
    }
  }

  public static class Script_Directives extends ASTPath.IndexedPath<Script, Directive> {
    protected Script_Directives(int index) {
      super(index);
    }

    @Override
    Maybe<Directive> apply(Object source) {
      if (!(source instanceof Script)) return Maybe.empty();
      return ((Script) source).directives.index(index);
    }

    public String propertyName() {
      return "directives[" + index + "]";
    }
  }

  public static class Script_Statements extends ASTPath.IndexedPath<Script, Statement> {
    protected Script_Statements(int index) {
      super(index);
    }

    @Override
    Maybe<Statement> apply(Object source) {
      if (!(source instanceof Script)) return Maybe.empty();
      return ((Script) source).statements.index(index);
    }

    public String propertyName() {
      return "statements[" + index + "]";
    }
  }

  public static class Setter_Name extends ASTPath.TrivialPath<Setter, PropertyName> {
    @Override
    Maybe<PropertyName> apply(Object source) {
      if (!(source instanceof Setter)) return Maybe.empty();
      return Maybe.of(((Setter) source).name);
    }

    public String propertyName() {
      return "name";
    }
  }

  public static class Setter_Param extends ASTPath.TrivialPath<Setter, Parameter> {
    @Override
    Maybe<Parameter> apply(Object source) {
      if (!(source instanceof Setter)) return Maybe.empty();
      return Maybe.of(((Setter) source).param);
    }

    public String propertyName() {
      return "param";
    }
  }

  public static class Setter_Body extends ASTPath.TrivialPath<Setter, FunctionBody> {
    @Override
    Maybe<FunctionBody> apply(Object source) {
      if (!(source instanceof Setter)) return Maybe.empty();
      return Maybe.of(((Setter) source).body);
    }

    public String propertyName() {
      return "body";
    }
  }

  public static class ShorthandProperty_Name extends ASTPath.TrivialPath<ShorthandProperty, IdentifierExpression> {
    @Override
    Maybe<IdentifierExpression> apply(Object source) {
      if (!(source instanceof ShorthandProperty)) return Maybe.empty();
      return Maybe.of(((ShorthandProperty) source).name);
    }

    public String propertyName() {
      return "name";
    }
  }

  public static class SpreadElement_Expression extends ASTPath.TrivialPath<SpreadElement, Expression> {
    @Override
    Maybe<Expression> apply(Object source) {
      if (!(source instanceof SpreadElement)) return Maybe.empty();
      return Maybe.of(((SpreadElement) source).expression);
    }

    public String propertyName() {
      return "expression";
    }
  }

  public static class StaticMemberAssignmentTarget_Object extends ASTPath.TrivialPath<StaticMemberAssignmentTarget, ExpressionSuper> {
    @Override
    Maybe<ExpressionSuper> apply(Object source) {
      if (!(source instanceof StaticMemberAssignmentTarget)) return Maybe.empty();
      return Maybe.of(((StaticMemberAssignmentTarget) source).object);
    }

    public String propertyName() {
      return "object";
    }
  }

  public static class StaticMemberAssignmentTarget_Property extends ASTPath.TrivialPath<StaticMemberAssignmentTarget, String> {
    @Override
    Maybe<String> apply(Object source) {
      if (!(source instanceof StaticMemberAssignmentTarget)) return Maybe.empty();
      return Maybe.of(((StaticMemberAssignmentTarget) source).property);
    }

    public String propertyName() {
      return "property";
    }
  }

  public static class StaticMemberExpression_Object extends ASTPath.TrivialPath<StaticMemberExpression, ExpressionSuper> {
    @Override
    Maybe<ExpressionSuper> apply(Object source) {
      if (!(source instanceof StaticMemberExpression)) return Maybe.empty();
      return Maybe.of(((StaticMemberExpression) source).object);
    }

    public String propertyName() {
      return "object";
    }
  }

  public static class StaticMemberExpression_Property extends ASTPath.TrivialPath<StaticMemberExpression, String> {
    @Override
    Maybe<String> apply(Object source) {
      if (!(source instanceof StaticMemberExpression)) return Maybe.empty();
      return Maybe.of(((StaticMemberExpression) source).property);
    }

    public String propertyName() {
      return "property";
    }
  }

  public static class StaticPropertyName_Value extends ASTPath.TrivialPath<StaticPropertyName, String> {
    @Override
    Maybe<String> apply(Object source) {
      if (!(source instanceof StaticPropertyName)) return Maybe.empty();
      return Maybe.of(((StaticPropertyName) source).value);
    }

    public String propertyName() {
      return "value";
    }
  }

  public static class SwitchCase_Test extends ASTPath.TrivialPath<SwitchCase, Expression> {
    @Override
    Maybe<Expression> apply(Object source) {
      if (!(source instanceof SwitchCase)) return Maybe.empty();
      return Maybe.of(((SwitchCase) source).test);
    }

    public String propertyName() {
      return "test";
    }
  }

  public static class SwitchCase_Consequent extends ASTPath.IndexedPath<SwitchCase, Statement> {
    protected SwitchCase_Consequent(int index) {
      super(index);
    }

    @Override
    Maybe<Statement> apply(Object source) {
      if (!(source instanceof SwitchCase)) return Maybe.empty();
      return ((SwitchCase) source).consequent.index(index);
    }

    public String propertyName() {
      return "consequent[" + index + "]";
    }
  }

  public static class SwitchDefault_Consequent extends ASTPath.IndexedPath<SwitchDefault, Statement> {
    protected SwitchDefault_Consequent(int index) {
      super(index);
    }

    @Override
    Maybe<Statement> apply(Object source) {
      if (!(source instanceof SwitchDefault)) return Maybe.empty();
      return ((SwitchDefault) source).consequent.index(index);
    }

    public String propertyName() {
      return "consequent[" + index + "]";
    }
  }

  public static class SwitchStatement_Discriminant extends ASTPath.TrivialPath<SwitchStatement, Expression> {
    @Override
    Maybe<Expression> apply(Object source) {
      if (!(source instanceof SwitchStatement)) return Maybe.empty();
      return Maybe.of(((SwitchStatement) source).discriminant);
    }

    public String propertyName() {
      return "discriminant";
    }
  }

  public static class SwitchStatement_Cases extends ASTPath.IndexedPath<SwitchStatement, SwitchCase> {
    protected SwitchStatement_Cases(int index) {
      super(index);
    }

    @Override
    Maybe<SwitchCase> apply(Object source) {
      if (!(source instanceof SwitchStatement)) return Maybe.empty();
      return ((SwitchStatement) source).cases.index(index);
    }

    public String propertyName() {
      return "cases[" + index + "]";
    }
  }

  public static class SwitchStatementWithDefault_Discriminant extends ASTPath.TrivialPath<SwitchStatementWithDefault, Expression> {
    @Override
    Maybe<Expression> apply(Object source) {
      if (!(source instanceof SwitchStatementWithDefault)) return Maybe.empty();
      return Maybe.of(((SwitchStatementWithDefault) source).discriminant);
    }

    public String propertyName() {
      return "discriminant";
    }
  }

  public static class SwitchStatementWithDefault_PreDefaultCases extends ASTPath.IndexedPath<SwitchStatementWithDefault, SwitchCase> {
    protected SwitchStatementWithDefault_PreDefaultCases(int index) {
      super(index);
    }

    @Override
    Maybe<SwitchCase> apply(Object source) {
      if (!(source instanceof SwitchStatementWithDefault)) return Maybe.empty();
      return ((SwitchStatementWithDefault) source).preDefaultCases.index(index);
    }

    public String propertyName() {
      return "preDefaultCases[" + index + "]";
    }
  }

  public static class SwitchStatementWithDefault_DefaultCase extends ASTPath.TrivialPath<SwitchStatementWithDefault, SwitchDefault> {
    @Override
    Maybe<SwitchDefault> apply(Object source) {
      if (!(source instanceof SwitchStatementWithDefault)) return Maybe.empty();
      return Maybe.of(((SwitchStatementWithDefault) source).defaultCase);
    }

    public String propertyName() {
      return "defaultCase";
    }
  }

  public static class SwitchStatementWithDefault_PostDefaultCases extends ASTPath.IndexedPath<SwitchStatementWithDefault, SwitchCase> {
    protected SwitchStatementWithDefault_PostDefaultCases(int index) {
      super(index);
    }

    @Override
    Maybe<SwitchCase> apply(Object source) {
      if (!(source instanceof SwitchStatementWithDefault)) return Maybe.empty();
      return ((SwitchStatementWithDefault) source).postDefaultCases.index(index);
    }

    public String propertyName() {
      return "postDefaultCases[" + index + "]";
    }
  }

  public static class TemplateElement_RawValue extends ASTPath.TrivialPath<TemplateElement, String> {
    @Override
    Maybe<String> apply(Object source) {
      if (!(source instanceof TemplateElement)) return Maybe.empty();
      return Maybe.of(((TemplateElement) source).rawValue);
    }

    public String propertyName() {
      return "rawValue";
    }
  }

  public static class TemplateExpression_Tag extends ASTPath.TrivialPath<TemplateExpression, Expression> {
    @Override
    Maybe<Expression> apply(Object source) {
      if (!(source instanceof TemplateExpression)) return Maybe.empty();
      return ((TemplateExpression) source).tag;
    }

    public String propertyName() {
      return "tag";
    }
  }

  public static class TemplateExpression_Elements extends ASTPath.IndexedPath<TemplateExpression, ExpressionTemplateElement> {
    protected TemplateExpression_Elements(int index) {
      super(index);
    }

    @Override
    Maybe<ExpressionTemplateElement> apply(Object source) {
      if (!(source instanceof TemplateExpression)) return Maybe.empty();
      return ((TemplateExpression) source).elements.index(index);
    }

    public String propertyName() {
      return "elements[" + index + "]";
    }
  }

  public static class ThrowStatement_Expression extends ASTPath.TrivialPath<ThrowStatement, Expression> {
    @Override
    Maybe<Expression> apply(Object source) {
      if (!(source instanceof ThrowStatement)) return Maybe.empty();
      return Maybe.of(((ThrowStatement) source).expression);
    }

    public String propertyName() {
      return "expression";
    }
  }

  public static class TryCatchStatement_Body extends ASTPath.TrivialPath<TryCatchStatement, Block> {
    @Override
    Maybe<Block> apply(Object source) {
      if (!(source instanceof TryCatchStatement)) return Maybe.empty();
      return Maybe.of(((TryCatchStatement) source).body);
    }

    public String propertyName() {
      return "body";
    }
  }

  public static class TryCatchStatement_CatchClause extends ASTPath.TrivialPath<TryCatchStatement, CatchClause> {
    @Override
    Maybe<CatchClause> apply(Object source) {
      if (!(source instanceof TryCatchStatement)) return Maybe.empty();
      return Maybe.of(((TryCatchStatement) source).catchClause);
    }

    public String propertyName() {
      return "catchClause";
    }
  }

  public static class TryFinallyStatement_Body extends ASTPath.TrivialPath<TryFinallyStatement, Block> {
    @Override
    Maybe<Block> apply(Object source) {
      if (!(source instanceof TryFinallyStatement)) return Maybe.empty();
      return Maybe.of(((TryFinallyStatement) source).body);
    }

    public String propertyName() {
      return "body";
    }
  }

  public static class TryFinallyStatement_CatchClause extends ASTPath.TrivialPath<TryFinallyStatement, CatchClause> {
    @Override
    Maybe<CatchClause> apply(Object source) {
      if (!(source instanceof TryFinallyStatement)) return Maybe.empty();
      return ((TryFinallyStatement) source).catchClause;
    }

    public String propertyName() {
      return "catchClause";
    }
  }

  public static class TryFinallyStatement_Finalizer extends ASTPath.TrivialPath<TryFinallyStatement, Block> {
    @Override
    Maybe<Block> apply(Object source) {
      if (!(source instanceof TryFinallyStatement)) return Maybe.empty();
      return Maybe.of(((TryFinallyStatement) source).finalizer);
    }

    public String propertyName() {
      return "finalizer";
    }
  }

  public static class UnaryExpression_Operator extends ASTPath.TrivialPath<UnaryExpression, com.shapesecurity.shift.es2017.ast.operators.UnaryOperator> {
    @Override
    Maybe<com.shapesecurity.shift.es2017.ast.operators.UnaryOperator> apply(Object source) {
      if (!(source instanceof UnaryExpression)) return Maybe.empty();
      return Maybe.of(((UnaryExpression) source).operator);
    }

    public String propertyName() {
      return "operator";
    }
  }

  public static class UnaryExpression_Operand extends ASTPath.TrivialPath<UnaryExpression, Expression> {
    @Override
    Maybe<Expression> apply(Object source) {
      if (!(source instanceof UnaryExpression)) return Maybe.empty();
      return Maybe.of(((UnaryExpression) source).operand);
    }

    public String propertyName() {
      return "operand";
    }
  }

  public static class UpdateExpression_IsPrefix extends ASTPath.TrivialPath<UpdateExpression, Boolean> {
    @Override
    Maybe<Boolean> apply(Object source) {
      if (!(source instanceof UpdateExpression)) return Maybe.empty();
      return Maybe.of(((UpdateExpression) source).isPrefix);
    }

    public String propertyName() {
      return "isPrefix";
    }
  }

  public static class UpdateExpression_Operator extends ASTPath.TrivialPath<UpdateExpression, com.shapesecurity.shift.es2017.ast.operators.UpdateOperator> {
    @Override
    Maybe<com.shapesecurity.shift.es2017.ast.operators.UpdateOperator> apply(Object source) {
      if (!(source instanceof UpdateExpression)) return Maybe.empty();
      return Maybe.of(((UpdateExpression) source).operator);
    }

    public String propertyName() {
      return "operator";
    }
  }

  public static class UpdateExpression_Operand extends ASTPath.TrivialPath<UpdateExpression, SimpleAssignmentTarget> {
    @Override
    Maybe<SimpleAssignmentTarget> apply(Object source) {
      if (!(source instanceof UpdateExpression)) return Maybe.empty();
      return Maybe.of(((UpdateExpression) source).operand);
    }

    public String propertyName() {
      return "operand";
    }
  }

  public static class VariableDeclaration_Kind extends ASTPath.TrivialPath<VariableDeclaration, VariableDeclarationKind> {
    @Override
    Maybe<VariableDeclarationKind> apply(Object source) {
      if (!(source instanceof VariableDeclaration)) return Maybe.empty();
      return Maybe.of(((VariableDeclaration) source).kind);
    }

    public String propertyName() {
      return "kind";
    }
  }

  public static class VariableDeclaration_Declarators extends ASTPath.IndexedPath<VariableDeclaration, VariableDeclarator> {
    protected VariableDeclaration_Declarators(int index) {
      super(index);
    }

    @Override
    Maybe<VariableDeclarator> apply(Object source) {
      if (!(source instanceof VariableDeclaration)) return Maybe.empty();
      return ((VariableDeclaration) source).declarators.index(index);
    }

    public String propertyName() {
      return "declarators[" + index + "]";
    }
  }

  public static class VariableDeclarationStatement_Declaration extends ASTPath.TrivialPath<VariableDeclarationStatement, VariableDeclaration> {
    @Override
    Maybe<VariableDeclaration> apply(Object source) {
      if (!(source instanceof VariableDeclarationStatement)) return Maybe.empty();
      return Maybe.of(((VariableDeclarationStatement) source).declaration);
    }

    public String propertyName() {
      return "declaration";
    }
  }

  public static class VariableDeclarator_Binding extends ASTPath.TrivialPath<VariableDeclarator, Binding> {
    @Override
    Maybe<Binding> apply(Object source) {
      if (!(source instanceof VariableDeclarator)) return Maybe.empty();
      return Maybe.of(((VariableDeclarator) source).binding);
    }

    public String propertyName() {
      return "binding";
    }
  }

  public static class VariableDeclarator_Init extends ASTPath.TrivialPath<VariableDeclarator, Expression> {
    @Override
    Maybe<Expression> apply(Object source) {
      if (!(source instanceof VariableDeclarator)) return Maybe.empty();
      return ((VariableDeclarator) source).init;
    }

    public String propertyName() {
      return "init";
    }
  }

  public static class WhileStatement_Test extends ASTPath.TrivialPath<WhileStatement, Expression> {
    @Override
    Maybe<Expression> apply(Object source) {
      if (!(source instanceof WhileStatement)) return Maybe.empty();
      return Maybe.of(((WhileStatement) source).test);
    }

    public String propertyName() {
      return "test";
    }
  }

  public static class WhileStatement_Body extends ASTPath.TrivialPath<WhileStatement, Statement> {
    @Override
    Maybe<Statement> apply(Object source) {
      if (!(source instanceof WhileStatement)) return Maybe.empty();
      return Maybe.of(((WhileStatement) source).body);
    }

    public String propertyName() {
      return "body";
    }
  }

  public static class WithStatement_Object extends ASTPath.TrivialPath<WithStatement, Expression> {
    @Override
    Maybe<Expression> apply(Object source) {
      if (!(source instanceof WithStatement)) return Maybe.empty();
      return Maybe.of(((WithStatement) source).object);
    }

    public String propertyName() {
      return "object";
    }
  }

  public static class WithStatement_Body extends ASTPath.TrivialPath<WithStatement, Statement> {
    @Override
    Maybe<Statement> apply(Object source) {
      if (!(source instanceof WithStatement)) return Maybe.empty();
      return Maybe.of(((WithStatement) source).body);
    }

    public String propertyName() {
      return "body";
    }
  }

  public static class YieldExpression_Expression extends ASTPath.TrivialPath<YieldExpression, Expression> {
    @Override
    Maybe<Expression> apply(Object source) {
      if (!(source instanceof YieldExpression)) return Maybe.empty();
      return ((YieldExpression) source).expression;
    }

    public String propertyName() {
      return "expression";
    }
  }

  public static class YieldGeneratorExpression_Expression extends ASTPath.TrivialPath<YieldGeneratorExpression, Expression> {
    @Override
    Maybe<Expression> apply(Object source) {
      if (!(source instanceof YieldGeneratorExpression)) return Maybe.empty();
      return Maybe.of(((YieldGeneratorExpression) source).expression);
    }

    public String propertyName() {
      return "expression";
    }
  }
}
