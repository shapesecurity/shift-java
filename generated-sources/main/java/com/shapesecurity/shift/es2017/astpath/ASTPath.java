// Generated by ast-path.js
/**
 * Copyright 2018 Shape Security, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


package com.shapesecurity.shift.es2017.astpath;


import com.shapesecurity.functional.data.Maybe;
import com.shapesecurity.shift.es2017.ast.*;

import java.util.Objects;


public abstract class ASTPath<S, T> extends ObjectPath<S, T> {
  private ASTPath() {}

  public abstract String propertyName();

  private static abstract class TrivialPath<S, T> extends ObjectPath<S, T> {
    public boolean equals(Object o) {
      return this == o || o != null && getClass() == o.getClass();
    }

    public int hashCode() {
      return Objects.hash(getClass());
    }
  }

  private static abstract class IndexedPath<S, T> extends ObjectPath<S, T> {
    final int index;

    protected IndexedPath(int index) {
      this.index = index;
    }

    @Override
    public boolean equals(Object o) {
      if (this == o) return true;
      if (o == null || getClass() != o.getClass()) return false;
      IndexedPath<?, ?> that = (IndexedPath<?, ?>) o;
      return index == that.index;
    }

    @Override
    public int hashCode() {
      return Objects.hash(getClass(), index);
    }
  }


  public static ArrayAssignmentTarget_Elements ArrayAssignmentTarget_Elements(int index) {
    return new ArrayAssignmentTarget_Elements(index);
  }

  public static ArrayAssignmentTarget_Rest ArrayAssignmentTarget_Rest() {
    return new ArrayAssignmentTarget_Rest();
  }

  public static ArrayBinding_Elements ArrayBinding_Elements(int index) {
    return new ArrayBinding_Elements(index);
  }

  public static ArrayBinding_Rest ArrayBinding_Rest() {
    return new ArrayBinding_Rest();
  }

  public static ArrayExpression_Elements ArrayExpression_Elements(int index) {
    return new ArrayExpression_Elements(index);
  }

  public static ArrowExpression_IsAsync ArrowExpression_IsAsync() {
    return new ArrowExpression_IsAsync();
  }

  public static ArrowExpression_Params ArrowExpression_Params() {
    return new ArrowExpression_Params();
  }

  public static ArrowExpression_Body ArrowExpression_Body() {
    return new ArrowExpression_Body();
  }

  public static AssignmentExpression_Binding AssignmentExpression_Binding() {
    return new AssignmentExpression_Binding();
  }

  public static AssignmentExpression_Expression AssignmentExpression_Expression() {
    return new AssignmentExpression_Expression();
  }

  public static AssignmentTargetIdentifier_Name AssignmentTargetIdentifier_Name() {
    return new AssignmentTargetIdentifier_Name();
  }

  public static AssignmentTargetPropertyIdentifier_Binding AssignmentTargetPropertyIdentifier_Binding() {
    return new AssignmentTargetPropertyIdentifier_Binding();
  }

  public static AssignmentTargetPropertyIdentifier_Init AssignmentTargetPropertyIdentifier_Init() {
    return new AssignmentTargetPropertyIdentifier_Init();
  }

  public static AssignmentTargetPropertyProperty_Name AssignmentTargetPropertyProperty_Name() {
    return new AssignmentTargetPropertyProperty_Name();
  }

  public static AssignmentTargetPropertyProperty_Binding AssignmentTargetPropertyProperty_Binding() {
    return new AssignmentTargetPropertyProperty_Binding();
  }

  public static AssignmentTargetWithDefault_Binding AssignmentTargetWithDefault_Binding() {
    return new AssignmentTargetWithDefault_Binding();
  }

  public static AssignmentTargetWithDefault_Init AssignmentTargetWithDefault_Init() {
    return new AssignmentTargetWithDefault_Init();
  }

  public static AwaitExpression_Expression AwaitExpression_Expression() {
    return new AwaitExpression_Expression();
  }

  public static BinaryExpression_Left BinaryExpression_Left() {
    return new BinaryExpression_Left();
  }

  public static BinaryExpression_Operator BinaryExpression_Operator() {
    return new BinaryExpression_Operator();
  }

  public static BinaryExpression_Right BinaryExpression_Right() {
    return new BinaryExpression_Right();
  }

  public static BindingIdentifier_Name BindingIdentifier_Name() {
    return new BindingIdentifier_Name();
  }

  public static BindingPropertyIdentifier_Binding BindingPropertyIdentifier_Binding() {
    return new BindingPropertyIdentifier_Binding();
  }

  public static BindingPropertyIdentifier_Init BindingPropertyIdentifier_Init() {
    return new BindingPropertyIdentifier_Init();
  }

  public static BindingPropertyProperty_Name BindingPropertyProperty_Name() {
    return new BindingPropertyProperty_Name();
  }

  public static BindingPropertyProperty_Binding BindingPropertyProperty_Binding() {
    return new BindingPropertyProperty_Binding();
  }

  public static BindingWithDefault_Binding BindingWithDefault_Binding() {
    return new BindingWithDefault_Binding();
  }

  public static BindingWithDefault_Init BindingWithDefault_Init() {
    return new BindingWithDefault_Init();
  }

  public static Block_Statements Block_Statements(int index) {
    return new Block_Statements(index);
  }

  public static BlockStatement_Block BlockStatement_Block() {
    return new BlockStatement_Block();
  }

  public static BreakStatement_Label BreakStatement_Label() {
    return new BreakStatement_Label();
  }

  public static CallExpression_Callee CallExpression_Callee() {
    return new CallExpression_Callee();
  }

  public static CallExpression_Arguments CallExpression_Arguments(int index) {
    return new CallExpression_Arguments(index);
  }

  public static CatchClause_Binding CatchClause_Binding() {
    return new CatchClause_Binding();
  }

  public static CatchClause_Body CatchClause_Body() {
    return new CatchClause_Body();
  }

  public static ClassDeclaration_Name ClassDeclaration_Name() {
    return new ClassDeclaration_Name();
  }

  public static ClassDeclaration_Super ClassDeclaration_Super() {
    return new ClassDeclaration_Super();
  }

  public static ClassDeclaration_Elements ClassDeclaration_Elements(int index) {
    return new ClassDeclaration_Elements(index);
  }

  public static ClassElement_IsStatic ClassElement_IsStatic() {
    return new ClassElement_IsStatic();
  }

  public static ClassElement_Method ClassElement_Method() {
    return new ClassElement_Method();
  }

  public static ClassExpression_Name ClassExpression_Name() {
    return new ClassExpression_Name();
  }

  public static ClassExpression_Super ClassExpression_Super() {
    return new ClassExpression_Super();
  }

  public static ClassExpression_Elements ClassExpression_Elements(int index) {
    return new ClassExpression_Elements(index);
  }

  public static CompoundAssignmentExpression_Binding CompoundAssignmentExpression_Binding() {
    return new CompoundAssignmentExpression_Binding();
  }

  public static CompoundAssignmentExpression_Operator CompoundAssignmentExpression_Operator() {
    return new CompoundAssignmentExpression_Operator();
  }

  public static CompoundAssignmentExpression_Expression CompoundAssignmentExpression_Expression() {
    return new CompoundAssignmentExpression_Expression();
  }

  public static ComputedMemberAssignmentTarget_Object ComputedMemberAssignmentTarget_Object() {
    return new ComputedMemberAssignmentTarget_Object();
  }

  public static ComputedMemberAssignmentTarget_Expression ComputedMemberAssignmentTarget_Expression() {
    return new ComputedMemberAssignmentTarget_Expression();
  }

  public static ComputedMemberExpression_Object ComputedMemberExpression_Object() {
    return new ComputedMemberExpression_Object();
  }

  public static ComputedMemberExpression_Expression ComputedMemberExpression_Expression() {
    return new ComputedMemberExpression_Expression();
  }

  public static ComputedPropertyName_Expression ComputedPropertyName_Expression() {
    return new ComputedPropertyName_Expression();
  }

  public static ConditionalExpression_Test ConditionalExpression_Test() {
    return new ConditionalExpression_Test();
  }

  public static ConditionalExpression_Consequent ConditionalExpression_Consequent() {
    return new ConditionalExpression_Consequent();
  }

  public static ConditionalExpression_Alternate ConditionalExpression_Alternate() {
    return new ConditionalExpression_Alternate();
  }

  public static ContinueStatement_Label ContinueStatement_Label() {
    return new ContinueStatement_Label();
  }

  public static DataProperty_Name DataProperty_Name() {
    return new DataProperty_Name();
  }

  public static DataProperty_Expression DataProperty_Expression() {
    return new DataProperty_Expression();
  }

  public static Directive_RawValue Directive_RawValue() {
    return new Directive_RawValue();
  }

  public static DoWhileStatement_Body DoWhileStatement_Body() {
    return new DoWhileStatement_Body();
  }

  public static DoWhileStatement_Test DoWhileStatement_Test() {
    return new DoWhileStatement_Test();
  }

  public static Export_Declaration Export_Declaration() {
    return new Export_Declaration();
  }

  public static ExportAllFrom_ModuleSpecifier ExportAllFrom_ModuleSpecifier() {
    return new ExportAllFrom_ModuleSpecifier();
  }

  public static ExportDefault_Body ExportDefault_Body() {
    return new ExportDefault_Body();
  }

  public static ExportFrom_NamedExports ExportFrom_NamedExports(int index) {
    return new ExportFrom_NamedExports(index);
  }

  public static ExportFrom_ModuleSpecifier ExportFrom_ModuleSpecifier() {
    return new ExportFrom_ModuleSpecifier();
  }

  public static ExportFromSpecifier_Name ExportFromSpecifier_Name() {
    return new ExportFromSpecifier_Name();
  }

  public static ExportFromSpecifier_ExportedName ExportFromSpecifier_ExportedName() {
    return new ExportFromSpecifier_ExportedName();
  }

  public static ExportLocalSpecifier_Name ExportLocalSpecifier_Name() {
    return new ExportLocalSpecifier_Name();
  }

  public static ExportLocalSpecifier_ExportedName ExportLocalSpecifier_ExportedName() {
    return new ExportLocalSpecifier_ExportedName();
  }

  public static ExportLocals_NamedExports ExportLocals_NamedExports(int index) {
    return new ExportLocals_NamedExports(index);
  }

  public static ExpressionStatement_Expression ExpressionStatement_Expression() {
    return new ExpressionStatement_Expression();
  }

  public static ForInStatement_Left ForInStatement_Left() {
    return new ForInStatement_Left();
  }

  public static ForInStatement_Right ForInStatement_Right() {
    return new ForInStatement_Right();
  }

  public static ForInStatement_Body ForInStatement_Body() {
    return new ForInStatement_Body();
  }

  public static ForOfStatement_Left ForOfStatement_Left() {
    return new ForOfStatement_Left();
  }

  public static ForOfStatement_Right ForOfStatement_Right() {
    return new ForOfStatement_Right();
  }

  public static ForOfStatement_Body ForOfStatement_Body() {
    return new ForOfStatement_Body();
  }

  public static ForStatement_Init ForStatement_Init() {
    return new ForStatement_Init();
  }

  public static ForStatement_Test ForStatement_Test() {
    return new ForStatement_Test();
  }

  public static ForStatement_Update ForStatement_Update() {
    return new ForStatement_Update();
  }

  public static ForStatement_Body ForStatement_Body() {
    return new ForStatement_Body();
  }

  public static FormalParameters_Items FormalParameters_Items(int index) {
    return new FormalParameters_Items(index);
  }

  public static FormalParameters_Rest FormalParameters_Rest() {
    return new FormalParameters_Rest();
  }

  public static FunctionBody_Directives FunctionBody_Directives(int index) {
    return new FunctionBody_Directives(index);
  }

  public static FunctionBody_Statements FunctionBody_Statements(int index) {
    return new FunctionBody_Statements(index);
  }

  public static FunctionDeclaration_IsAsync FunctionDeclaration_IsAsync() {
    return new FunctionDeclaration_IsAsync();
  }

  public static FunctionDeclaration_IsGenerator FunctionDeclaration_IsGenerator() {
    return new FunctionDeclaration_IsGenerator();
  }

  public static FunctionDeclaration_Name FunctionDeclaration_Name() {
    return new FunctionDeclaration_Name();
  }

  public static FunctionDeclaration_Params FunctionDeclaration_Params() {
    return new FunctionDeclaration_Params();
  }

  public static FunctionDeclaration_Body FunctionDeclaration_Body() {
    return new FunctionDeclaration_Body();
  }

  public static FunctionExpression_IsAsync FunctionExpression_IsAsync() {
    return new FunctionExpression_IsAsync();
  }

  public static FunctionExpression_IsGenerator FunctionExpression_IsGenerator() {
    return new FunctionExpression_IsGenerator();
  }

  public static FunctionExpression_Name FunctionExpression_Name() {
    return new FunctionExpression_Name();
  }

  public static FunctionExpression_Params FunctionExpression_Params() {
    return new FunctionExpression_Params();
  }

  public static FunctionExpression_Body FunctionExpression_Body() {
    return new FunctionExpression_Body();
  }

  public static Getter_Name Getter_Name() {
    return new Getter_Name();
  }

  public static Getter_Body Getter_Body() {
    return new Getter_Body();
  }

  public static IdentifierExpression_Name IdentifierExpression_Name() {
    return new IdentifierExpression_Name();
  }

  public static IfStatement_Test IfStatement_Test() {
    return new IfStatement_Test();
  }

  public static IfStatement_Consequent IfStatement_Consequent() {
    return new IfStatement_Consequent();
  }

  public static IfStatement_Alternate IfStatement_Alternate() {
    return new IfStatement_Alternate();
  }

  public static Import_DefaultBinding Import_DefaultBinding() {
    return new Import_DefaultBinding();
  }

  public static Import_NamedImports Import_NamedImports(int index) {
    return new Import_NamedImports(index);
  }

  public static Import_ModuleSpecifier Import_ModuleSpecifier() {
    return new Import_ModuleSpecifier();
  }

  public static ImportNamespace_DefaultBinding ImportNamespace_DefaultBinding() {
    return new ImportNamespace_DefaultBinding();
  }

  public static ImportNamespace_NamespaceBinding ImportNamespace_NamespaceBinding() {
    return new ImportNamespace_NamespaceBinding();
  }

  public static ImportNamespace_ModuleSpecifier ImportNamespace_ModuleSpecifier() {
    return new ImportNamespace_ModuleSpecifier();
  }

  public static ImportSpecifier_Name ImportSpecifier_Name() {
    return new ImportSpecifier_Name();
  }

  public static ImportSpecifier_Binding ImportSpecifier_Binding() {
    return new ImportSpecifier_Binding();
  }

  public static LabeledStatement_Label LabeledStatement_Label() {
    return new LabeledStatement_Label();
  }

  public static LabeledStatement_Body LabeledStatement_Body() {
    return new LabeledStatement_Body();
  }

  public static LiteralBooleanExpression_Value LiteralBooleanExpression_Value() {
    return new LiteralBooleanExpression_Value();
  }

  public static LiteralNumericExpression_Value LiteralNumericExpression_Value() {
    return new LiteralNumericExpression_Value();
  }

  public static LiteralRegExpExpression_Pattern LiteralRegExpExpression_Pattern() {
    return new LiteralRegExpExpression_Pattern();
  }

  public static LiteralRegExpExpression_Global LiteralRegExpExpression_Global() {
    return new LiteralRegExpExpression_Global();
  }

  public static LiteralRegExpExpression_IgnoreCase LiteralRegExpExpression_IgnoreCase() {
    return new LiteralRegExpExpression_IgnoreCase();
  }

  public static LiteralRegExpExpression_MultiLine LiteralRegExpExpression_MultiLine() {
    return new LiteralRegExpExpression_MultiLine();
  }

  public static LiteralRegExpExpression_Sticky LiteralRegExpExpression_Sticky() {
    return new LiteralRegExpExpression_Sticky();
  }

  public static LiteralRegExpExpression_Unicode LiteralRegExpExpression_Unicode() {
    return new LiteralRegExpExpression_Unicode();
  }

  public static LiteralStringExpression_Value LiteralStringExpression_Value() {
    return new LiteralStringExpression_Value();
  }

  public static Method_IsAsync Method_IsAsync() {
    return new Method_IsAsync();
  }

  public static Method_IsGenerator Method_IsGenerator() {
    return new Method_IsGenerator();
  }

  public static Method_Name Method_Name() {
    return new Method_Name();
  }

  public static Method_Params Method_Params() {
    return new Method_Params();
  }

  public static Method_Body Method_Body() {
    return new Method_Body();
  }

  public static Module_Directives Module_Directives(int index) {
    return new Module_Directives(index);
  }

  public static Module_Items Module_Items(int index) {
    return new Module_Items(index);
  }

  public static NewExpression_Callee NewExpression_Callee() {
    return new NewExpression_Callee();
  }

  public static NewExpression_Arguments NewExpression_Arguments(int index) {
    return new NewExpression_Arguments(index);
  }

  public static ObjectAssignmentTarget_Properties ObjectAssignmentTarget_Properties(int index) {
    return new ObjectAssignmentTarget_Properties(index);
  }

  public static ObjectBinding_Properties ObjectBinding_Properties(int index) {
    return new ObjectBinding_Properties(index);
  }

  public static ObjectExpression_Properties ObjectExpression_Properties(int index) {
    return new ObjectExpression_Properties(index);
  }

  public static ReturnStatement_Expression ReturnStatement_Expression() {
    return new ReturnStatement_Expression();
  }

  public static Script_Directives Script_Directives(int index) {
    return new Script_Directives(index);
  }

  public static Script_Statements Script_Statements(int index) {
    return new Script_Statements(index);
  }

  public static Setter_Name Setter_Name() {
    return new Setter_Name();
  }

  public static Setter_Param Setter_Param() {
    return new Setter_Param();
  }

  public static Setter_Body Setter_Body() {
    return new Setter_Body();
  }

  public static ShorthandProperty_Name ShorthandProperty_Name() {
    return new ShorthandProperty_Name();
  }

  public static SpreadElement_Expression SpreadElement_Expression() {
    return new SpreadElement_Expression();
  }

  public static StaticMemberAssignmentTarget_Object StaticMemberAssignmentTarget_Object() {
    return new StaticMemberAssignmentTarget_Object();
  }

  public static StaticMemberAssignmentTarget_Property StaticMemberAssignmentTarget_Property() {
    return new StaticMemberAssignmentTarget_Property();
  }

  public static StaticMemberExpression_Object StaticMemberExpression_Object() {
    return new StaticMemberExpression_Object();
  }

  public static StaticMemberExpression_Property StaticMemberExpression_Property() {
    return new StaticMemberExpression_Property();
  }

  public static StaticPropertyName_Value StaticPropertyName_Value() {
    return new StaticPropertyName_Value();
  }

  public static SwitchCase_Test SwitchCase_Test() {
    return new SwitchCase_Test();
  }

  public static SwitchCase_Consequent SwitchCase_Consequent(int index) {
    return new SwitchCase_Consequent(index);
  }

  public static SwitchDefault_Consequent SwitchDefault_Consequent(int index) {
    return new SwitchDefault_Consequent(index);
  }

  public static SwitchStatement_Discriminant SwitchStatement_Discriminant() {
    return new SwitchStatement_Discriminant();
  }

  public static SwitchStatement_Cases SwitchStatement_Cases(int index) {
    return new SwitchStatement_Cases(index);
  }

  public static SwitchStatementWithDefault_Discriminant SwitchStatementWithDefault_Discriminant() {
    return new SwitchStatementWithDefault_Discriminant();
  }

  public static SwitchStatementWithDefault_PreDefaultCases SwitchStatementWithDefault_PreDefaultCases(int index) {
    return new SwitchStatementWithDefault_PreDefaultCases(index);
  }

  public static SwitchStatementWithDefault_DefaultCase SwitchStatementWithDefault_DefaultCase() {
    return new SwitchStatementWithDefault_DefaultCase();
  }

  public static SwitchStatementWithDefault_PostDefaultCases SwitchStatementWithDefault_PostDefaultCases(int index) {
    return new SwitchStatementWithDefault_PostDefaultCases(index);
  }

  public static TemplateElement_RawValue TemplateElement_RawValue() {
    return new TemplateElement_RawValue();
  }

  public static TemplateExpression_Tag TemplateExpression_Tag() {
    return new TemplateExpression_Tag();
  }

  public static TemplateExpression_Elements TemplateExpression_Elements(int index) {
    return new TemplateExpression_Elements(index);
  }

  public static ThrowStatement_Expression ThrowStatement_Expression() {
    return new ThrowStatement_Expression();
  }

  public static TryCatchStatement_Body TryCatchStatement_Body() {
    return new TryCatchStatement_Body();
  }

  public static TryCatchStatement_CatchClause TryCatchStatement_CatchClause() {
    return new TryCatchStatement_CatchClause();
  }

  public static TryFinallyStatement_Body TryFinallyStatement_Body() {
    return new TryFinallyStatement_Body();
  }

  public static TryFinallyStatement_CatchClause TryFinallyStatement_CatchClause() {
    return new TryFinallyStatement_CatchClause();
  }

  public static TryFinallyStatement_Finalizer TryFinallyStatement_Finalizer() {
    return new TryFinallyStatement_Finalizer();
  }

  public static UnaryExpression_Operator UnaryExpression_Operator() {
    return new UnaryExpression_Operator();
  }

  public static UnaryExpression_Operand UnaryExpression_Operand() {
    return new UnaryExpression_Operand();
  }

  public static UpdateExpression_IsPrefix UpdateExpression_IsPrefix() {
    return new UpdateExpression_IsPrefix();
  }

  public static UpdateExpression_Operator UpdateExpression_Operator() {
    return new UpdateExpression_Operator();
  }

  public static UpdateExpression_Operand UpdateExpression_Operand() {
    return new UpdateExpression_Operand();
  }

  public static VariableDeclaration_Kind VariableDeclaration_Kind() {
    return new VariableDeclaration_Kind();
  }

  public static VariableDeclaration_Declarators VariableDeclaration_Declarators(int index) {
    return new VariableDeclaration_Declarators(index);
  }

  public static VariableDeclarationStatement_Declaration VariableDeclarationStatement_Declaration() {
    return new VariableDeclarationStatement_Declaration();
  }

  public static VariableDeclarator_Binding VariableDeclarator_Binding() {
    return new VariableDeclarator_Binding();
  }

  public static VariableDeclarator_Init VariableDeclarator_Init() {
    return new VariableDeclarator_Init();
  }

  public static WhileStatement_Test WhileStatement_Test() {
    return new WhileStatement_Test();
  }

  public static WhileStatement_Body WhileStatement_Body() {
    return new WhileStatement_Body();
  }

  public static WithStatement_Object WithStatement_Object() {
    return new WithStatement_Object();
  }

  public static WithStatement_Body WithStatement_Body() {
    return new WithStatement_Body();
  }

  public static YieldExpression_Expression YieldExpression_Expression() {
    return new YieldExpression_Expression();
  }

  public static YieldGeneratorExpression_Expression YieldGeneratorExpression_Expression() {
    return new YieldGeneratorExpression_Expression();
  }



  public static class ArrayAssignmentTarget_Elements extends ASTPath.IndexedPath<ArrayAssignmentTarget, AssignmentTargetAssignmentTargetWithDefault> {
  protected ArrayAssignmentTarget_Elements(int index) {
      super(index);
    }

    @Override
    Maybe<AssignmentTargetAssignmentTargetWithDefault> apply(Object source) {
      if (!(source instanceof ArrayAssignmentTarget)) return Maybe.empty();
      return ((ArrayAssignmentTarget) source).elements.index(index).orJust(Maybe.empty());
    }

    public String propertyName() {
      return "elements[" + Integer.toString(index) + "]";
    }
  }

  public static class ArrayAssignmentTarget_Rest extends ASTPath.TrivialPath<ArrayAssignmentTarget, AssignmentTarget> {
    @Override
    Maybe<AssignmentTarget> apply(Object source) {
      if (!(source instanceof ArrayAssignmentTarget)) return Maybe.empty();
      return ((ArrayAssignmentTarget) source).rest;
    }

    public String propertyName() {
      return "rest";
    }
  }

  public static class ArrayBinding_Elements extends ASTPath.IndexedPath<ArrayBinding, BindingBindingWithDefault> {
  protected ArrayBinding_Elements(int index) {
      super(index);
    }

    @Override
    Maybe<BindingBindingWithDefault> apply(Object source) {
      if (!(source instanceof ArrayBinding)) return Maybe.empty();
      return ((ArrayBinding) source).elements.index(index).orJust(Maybe.empty());
    }

    public String propertyName() {
      return "elements[" + Integer.toString(index) + "]";
    }
  }

  public static class ArrayBinding_Rest extends ASTPath.TrivialPath<ArrayBinding, Binding> {
    @Override
    Maybe<Binding> apply(Object source) {
      if (!(source instanceof ArrayBinding)) return Maybe.empty();
      return ((ArrayBinding) source).rest;
    }

    public String propertyName() {
      return "rest";
    }
  }

  public static class ArrayExpression_Elements extends ASTPath.IndexedPath<ArrayExpression, SpreadElementExpression> {
  protected ArrayExpression_Elements(int index) {
      super(index);
    }

    @Override
    Maybe<SpreadElementExpression> apply(Object source) {
      if (!(source instanceof ArrayExpression)) return Maybe.empty();
      return ((ArrayExpression) source).elements.index(index).orJust(Maybe.empty());
    }

    public String propertyName() {
      return "elements[" + Integer.toString(index) + "]";
    }
  }

  public static class ArrowExpression_IsAsync extends ASTPath.TrivialPath<ArrowExpression, Boolean> {
    @Override
    Maybe<Boolean> apply(Object source) {
      if (!(source instanceof ArrowExpression)) return Maybe.empty();
      return Maybe.of(((ArrowExpression) source).isAsync);
    }

    public String propertyName() {
      return "isAsync";
    }
  }

  public static class ArrowExpression_Params extends ASTPath.TrivialPath<ArrowExpression, FormalParameters> {
    @Override
    Maybe<FormalParameters> apply(Object source) {
      if (!(source instanceof ArrowExpression)) return Maybe.empty();
      return Maybe.of(((ArrowExpression) source).params);
    }

    public String propertyName() {
      return "params";
    }
  }

  public static class ArrowExpression_Body extends ASTPath.TrivialPath<ArrowExpression, FunctionBodyExpression> {
    @Override
    Maybe<FunctionBodyExpression> apply(Object source) {
      if (!(source instanceof ArrowExpression)) return Maybe.empty();
      return Maybe.of(((ArrowExpression) source).body);
    }

    public String propertyName() {
      return "body";
    }
  }

  public static class AssignmentExpression_Binding extends ASTPath.TrivialPath<AssignmentExpression, AssignmentTarget> {
    @Override
    Maybe<AssignmentTarget> apply(Object source) {
      if (!(source instanceof AssignmentExpression)) return Maybe.empty();
      return Maybe.of(((AssignmentExpression) source).binding);
    }

    public String propertyName() {
      return "binding";
    }
  }

  public static class AssignmentExpression_Expression extends ASTPath.TrivialPath<AssignmentExpression, Expression> {
    @Override
    Maybe<Expression> apply(Object source) {
      if (!(source instanceof AssignmentExpression)) return Maybe.empty();
      return Maybe.of(((AssignmentExpression) source).expression);
    }

    public String propertyName() {
      return "expression";
    }
  }

  public static class AssignmentTargetIdentifier_Name extends ASTPath.TrivialPath<AssignmentTargetIdentifier, String> {
    @Override
    Maybe<String> apply(Object source) {
      if (!(source instanceof AssignmentTargetIdentifier)) return Maybe.empty();
      return Maybe.of(((AssignmentTargetIdentifier) source).name);
    }

    public String propertyName() {
      return "name";
    }
  }

  public static class AssignmentTargetPropertyIdentifier_Binding extends ASTPath.TrivialPath<AssignmentTargetPropertyIdentifier, AssignmentTargetIdentifier> {
    @Override
    Maybe<AssignmentTargetIdentifier> apply(Object source) {
      if (!(source instanceof AssignmentTargetPropertyIdentifier)) return Maybe.empty();
      return Maybe.of(((AssignmentTargetPropertyIdentifier) source).binding);
    }

    public String propertyName() {
      return "binding";
    }
  }

  public static class AssignmentTargetPropertyIdentifier_Init extends ASTPath.TrivialPath<AssignmentTargetPropertyIdentifier, Expression> {
    @Override
    Maybe<Expression> apply(Object source) {
      if (!(source instanceof AssignmentTargetPropertyIdentifier)) return Maybe.empty();
      return ((AssignmentTargetPropertyIdentifier) source).init;
    }

    public String propertyName() {
      return "init";
    }
  }

  public static class AssignmentTargetPropertyProperty_Name extends ASTPath.TrivialPath<AssignmentTargetPropertyProperty, PropertyName> {
    @Override
    Maybe<PropertyName> apply(Object source) {
      if (!(source instanceof AssignmentTargetPropertyProperty)) return Maybe.empty();
      return Maybe.of(((AssignmentTargetPropertyProperty) source).name);
    }

    public String propertyName() {
      return "name";
    }
  }

  public static class AssignmentTargetPropertyProperty_Binding extends ASTPath.TrivialPath<AssignmentTargetPropertyProperty, AssignmentTargetAssignmentTargetWithDefault> {
    @Override
    Maybe<AssignmentTargetAssignmentTargetWithDefault> apply(Object source) {
      if (!(source instanceof AssignmentTargetPropertyProperty)) return Maybe.empty();
      return Maybe.of(((AssignmentTargetPropertyProperty) source).binding);
    }

    public String propertyName() {
      return "binding";
    }
  }

  public static class AssignmentTargetWithDefault_Binding extends ASTPath.TrivialPath<AssignmentTargetWithDefault, AssignmentTarget> {
    @Override
    Maybe<AssignmentTarget> apply(Object source) {
      if (!(source instanceof AssignmentTargetWithDefault)) return Maybe.empty();
      return Maybe.of(((AssignmentTargetWithDefault) source).binding);
    }

    public String propertyName() {
      return "binding";
    }
  }

  public static class AssignmentTargetWithDefault_Init extends ASTPath.TrivialPath<AssignmentTargetWithDefault, Expression> {
    @Override
    Maybe<Expression> apply(Object source) {
      if (!(source instanceof AssignmentTargetWithDefault)) return Maybe.empty();
      return Maybe.of(((AssignmentTargetWithDefault) source).init);
    }

    public String propertyName() {
      return "init";
    }
  }

  public static class AwaitExpression_Expression extends ASTPath.TrivialPath<AwaitExpression, Expression> {
    @Override
    Maybe<Expression> apply(Object source) {
      if (!(source instanceof AwaitExpression)) return Maybe.empty();
      return Maybe.of(((AwaitExpression) source).expression);
    }

    public String propertyName() {
      return "expression";
    }
  }

  public static class BinaryExpression_Left extends ASTPath.TrivialPath<BinaryExpression, Expression> {
    @Override
    Maybe<Expression> apply(Object source) {
      if (!(source instanceof BinaryExpression)) return Maybe.empty();
      return Maybe.of(((BinaryExpression) source).left);
    }

    public String propertyName() {
      return "left";
    }
  }

  public static class BinaryExpression_Operator extends ASTPath.TrivialPath<BinaryExpression, com.shapesecurity.shift.es2017.ast.operators.BinaryOperator> {
    @Override
    Maybe<com.shapesecurity.shift.es2017.ast.operators.BinaryOperator> apply(Object source) {
      if (!(source instanceof BinaryExpression)) return Maybe.empty();
      return Maybe.of(((BinaryExpression) source).operator);
    }

    public String propertyName() {
      return "operator";
    }
  }

  public static class BinaryExpression_Right extends ASTPath.TrivialPath<BinaryExpression, Expression> {
    @Override
    Maybe<Expression> apply(Object source) {
      if (!(source instanceof BinaryExpression)) return Maybe.empty();
      return Maybe.of(((BinaryExpression) source).right);
    }

    public String propertyName() {
      return "right";
    }
  }

  public static class BindingIdentifier_Name extends ASTPath.TrivialPath<BindingIdentifier, String> {
    @Override
    Maybe<String> apply(Object source) {
      if (!(source instanceof BindingIdentifier)) return Maybe.empty();
      return Maybe.of(((BindingIdentifier) source).name);
    }

    public String propertyName() {
      return "name";
    }
  }

  public static class BindingPropertyIdentifier_Binding extends ASTPath.TrivialPath<BindingPropertyIdentifier, BindingIdentifier> {
    @Override
    Maybe<BindingIdentifier> apply(Object source) {
      if (!(source instanceof BindingPropertyIdentifier)) return Maybe.empty();
      return Maybe.of(((BindingPropertyIdentifier) source).binding);
    }

    public String propertyName() {
      return "binding";
    }
  }

  public static class BindingPropertyIdentifier_Init extends ASTPath.TrivialPath<BindingPropertyIdentifier, Expression> {
    @Override
    Maybe<Expression> apply(Object source) {
      if (!(source instanceof BindingPropertyIdentifier)) return Maybe.empty();
      return ((BindingPropertyIdentifier) source).init;
    }

    public String propertyName() {
      return "init";
    }
  }

  public static class BindingPropertyProperty_Name extends ASTPath.TrivialPath<BindingPropertyProperty, PropertyName> {
    @Override
    Maybe<PropertyName> apply(Object source) {
      if (!(source instanceof BindingPropertyProperty)) return Maybe.empty();
      return Maybe.of(((BindingPropertyProperty) source).name);
    }

    public String propertyName() {
      return "name";
    }
  }

  public static class BindingPropertyProperty_Binding extends ASTPath.TrivialPath<BindingPropertyProperty, BindingBindingWithDefault> {
    @Override
    Maybe<BindingBindingWithDefault> apply(Object source) {
      if (!(source instanceof BindingPropertyProperty)) return Maybe.empty();
      return Maybe.of(((BindingPropertyProperty) source).binding);
    }

    public String propertyName() {
      return "binding";
    }
  }

  public static class BindingWithDefault_Binding extends ASTPath.TrivialPath<BindingWithDefault, Binding> {
    @Override
    Maybe<Binding> apply(Object source) {
      if (!(source instanceof BindingWithDefault)) return Maybe.empty();
      return Maybe.of(((BindingWithDefault) source).binding);
    }

    public String propertyName() {
      return "binding";
    }
  }

  public static class BindingWithDefault_Init extends ASTPath.TrivialPath<BindingWithDefault, Expression> {
    @Override
    Maybe<Expression> apply(Object source) {
      if (!(source instanceof BindingWithDefault)) return Maybe.empty();
      return Maybe.of(((BindingWithDefault) source).init);
    }

    public String propertyName() {
      return "init";
    }
  }

  public static class Block_Statements extends ASTPath.IndexedPath<Block, Statement> {
    protected Block_Statements(int index) {
      super(index);
    }

    @Override
    Maybe<Statement> apply(Object source) {
      if (!(source instanceof Block)) return Maybe.empty();
      return ((Block) source).statements.index(index);
    }

    public String propertyName() {
      return "statements[" + Integer.toString(index) + "]";
    }
  }

  public static class BlockStatement_Block extends ASTPath.TrivialPath<BlockStatement, Block> {
    @Override
    Maybe<Block> apply(Object source) {
      if (!(source instanceof BlockStatement)) return Maybe.empty();
      return Maybe.of(((BlockStatement) source).block);
    }

    public String propertyName() {
      return "block";
    }
  }

  public static class BreakStatement_Label extends ASTPath.TrivialPath<BreakStatement, String> {
    @Override
    Maybe<String> apply(Object source) {
      if (!(source instanceof BreakStatement)) return Maybe.empty();
      return ((BreakStatement) source).label;
    }

    public String propertyName() {
      return "label";
    }
  }

  public static class CallExpression_Callee extends ASTPath.TrivialPath<CallExpression, ExpressionSuper> {
    @Override
    Maybe<ExpressionSuper> apply(Object source) {
      if (!(source instanceof CallExpression)) return Maybe.empty();
      return Maybe.of(((CallExpression) source).callee);
    }

    public String propertyName() {
      return "callee";
    }
  }

  public static class CallExpression_Arguments extends ASTPath.IndexedPath<CallExpression, SpreadElementExpression> {
    protected CallExpression_Arguments(int index) {
      super(index);
    }

    @Override
    Maybe<SpreadElementExpression> apply(Object source) {
      if (!(source instanceof CallExpression)) return Maybe.empty();
      return ((CallExpression) source).arguments.index(index);
    }

    public String propertyName() {
      return "arguments[" + Integer.toString(index) + "]";
    }
  }

  public static class CatchClause_Binding extends ASTPath.TrivialPath<CatchClause, Binding> {
    @Override
    Maybe<Binding> apply(Object source) {
      if (!(source instanceof CatchClause)) return Maybe.empty();
      return Maybe.of(((CatchClause) source).binding);
    }

    public String propertyName() {
      return "binding";
    }
  }

  public static class CatchClause_Body extends ASTPath.TrivialPath<CatchClause, Block> {
    @Override
    Maybe<Block> apply(Object source) {
      if (!(source instanceof CatchClause)) return Maybe.empty();
      return Maybe.of(((CatchClause) source).body);
    }

    public String propertyName() {
      return "body";
    }
  }

  public static class ClassDeclaration_Name extends ASTPath.TrivialPath<ClassDeclaration, BindingIdentifier> {
    @Override
    Maybe<BindingIdentifier> apply(Object source) {
      if (!(source instanceof ClassDeclaration)) return Maybe.empty();
      return Maybe.of(((ClassDeclaration) source).name);
    }

    public String propertyName() {
      return "name";
    }
  }

  public static class ClassDeclaration_Super extends ASTPath.TrivialPath<ClassDeclaration, Expression> {
    @Override
    Maybe<Expression> apply(Object source) {
      if (!(source instanceof ClassDeclaration)) return Maybe.empty();
      return ((ClassDeclaration) source)._super;
    }

    public String propertyName() {
      return "super";
    }
  }

  public static class ClassDeclaration_Elements extends ASTPath.IndexedPath<ClassDeclaration, ClassElement> {
    protected ClassDeclaration_Elements(int index) {
      super(index);
    }

    @Override
    Maybe<ClassElement> apply(Object source) {
      if (!(source instanceof ClassDeclaration)) return Maybe.empty();
      return ((ClassDeclaration) source).elements.index(index);
    }

    public String propertyName() {
      return "elements[" + Integer.toString(index) + "]";
    }
  }

  public static class ClassElement_IsStatic extends ASTPath.TrivialPath<ClassElement, Boolean> {
    @Override
    Maybe<Boolean> apply(Object source) {
      if (!(source instanceof ClassElement)) return Maybe.empty();
      return Maybe.of(((ClassElement) source).isStatic);
    }

    public String propertyName() {
      return "isStatic";
    }
  }

  public static class ClassElement_Method extends ASTPath.TrivialPath<ClassElement, MethodDefinition> {
    @Override
    Maybe<MethodDefinition> apply(Object source) {
      if (!(source instanceof ClassElement)) return Maybe.empty();
      return Maybe.of(((ClassElement) source).method);
    }

    public String propertyName() {
      return "method";
    }
  }

  public static class ClassExpression_Name extends ASTPath.TrivialPath<ClassExpression, BindingIdentifier> {
    @Override
    Maybe<BindingIdentifier> apply(Object source) {
      if (!(source instanceof ClassExpression)) return Maybe.empty();
      return ((ClassExpression) source).name;
    }

    public String propertyName() {
      return "name";
    }
  }

  public static class ClassExpression_Super extends ASTPath.TrivialPath<ClassExpression, Expression> {
    @Override
    Maybe<Expression> apply(Object source) {
      if (!(source instanceof ClassExpression)) return Maybe.empty();
      return ((ClassExpression) source)._super;
    }

    public String propertyName() {
      return "super";
    }
  }

  public static class ClassExpression_Elements extends ASTPath.IndexedPath<ClassExpression, ClassElement> {
    protected ClassExpression_Elements(int index) {
      super(index);
    }

    @Override
    Maybe<ClassElement> apply(Object source) {
      if (!(source instanceof ClassExpression)) return Maybe.empty();
      return ((ClassExpression) source).elements.index(index);
    }

    public String propertyName() {
      return "elements[" + Integer.toString(index) + "]";
    }
  }

  public static class CompoundAssignmentExpression_Binding extends ASTPath.TrivialPath<CompoundAssignmentExpression, SimpleAssignmentTarget> {
    @Override
    Maybe<SimpleAssignmentTarget> apply(Object source) {
      if (!(source instanceof CompoundAssignmentExpression)) return Maybe.empty();
      return Maybe.of(((CompoundAssignmentExpression) source).binding);
    }

    public String propertyName() {
      return "binding";
    }
  }

  public static class CompoundAssignmentExpression_Operator extends ASTPath.TrivialPath<CompoundAssignmentExpression, com.shapesecurity.shift.es2017.ast.operators.CompoundAssignmentOperator> {
    @Override
    Maybe<com.shapesecurity.shift.es2017.ast.operators.CompoundAssignmentOperator> apply(Object source) {
      if (!(source instanceof CompoundAssignmentExpression)) return Maybe.empty();
      return Maybe.of(((CompoundAssignmentExpression) source).operator);
    }

    public String propertyName() {
      return "operator";
    }
  }

  public static class CompoundAssignmentExpression_Expression extends ASTPath.TrivialPath<CompoundAssignmentExpression, Expression> {
    @Override
    Maybe<Expression> apply(Object source) {
      if (!(source instanceof CompoundAssignmentExpression)) return Maybe.empty();
      return Maybe.of(((CompoundAssignmentExpression) source).expression);
    }

    public String propertyName() {
      return "expression";
    }
  }

  public static class ComputedMemberAssignmentTarget_Object extends ASTPath.TrivialPath<ComputedMemberAssignmentTarget, ExpressionSuper> {
    @Override
    Maybe<ExpressionSuper> apply(Object source) {
      if (!(source instanceof ComputedMemberAssignmentTarget)) return Maybe.empty();
      return Maybe.of(((ComputedMemberAssignmentTarget) source).object);
    }

    public String propertyName() {
      return "object";
    }
  }

  public static class ComputedMemberAssignmentTarget_Expression extends ASTPath.TrivialPath<ComputedMemberAssignmentTarget, Expression> {
    @Override
    Maybe<Expression> apply(Object source) {
      if (!(source instanceof ComputedMemberAssignmentTarget)) return Maybe.empty();
      return Maybe.of(((ComputedMemberAssignmentTarget) source).expression);
    }

    public String propertyName() {
      return "expression";
    }
  }

  public static class ComputedMemberExpression_Object extends ASTPath.TrivialPath<ComputedMemberExpression, ExpressionSuper> {
    @Override
    Maybe<ExpressionSuper> apply(Object source) {
      if (!(source instanceof ComputedMemberExpression)) return Maybe.empty();
      return Maybe.of(((ComputedMemberExpression) source).object);
    }

    public String propertyName() {
      return "object";
    }
  }

  public static class ComputedMemberExpression_Expression extends ASTPath.TrivialPath<ComputedMemberExpression, Expression> {
    @Override
    Maybe<Expression> apply(Object source) {
      if (!(source instanceof ComputedMemberExpression)) return Maybe.empty();
      return Maybe.of(((ComputedMemberExpression) source).expression);
    }

    public String propertyName() {
      return "expression";
    }
  }

  public static class ComputedPropertyName_Expression extends ASTPath.TrivialPath<ComputedPropertyName, Expression> {
    @Override
    Maybe<Expression> apply(Object source) {
      if (!(source instanceof ComputedPropertyName)) return Maybe.empty();
      return Maybe.of(((ComputedPropertyName) source).expression);
    }

    public String propertyName() {
      return "expression";
    }
  }

  public static class ConditionalExpression_Test extends ASTPath.TrivialPath<ConditionalExpression, Expression> {
    @Override
    Maybe<Expression> apply(Object source) {
      if (!(source instanceof ConditionalExpression)) return Maybe.empty();
      return Maybe.of(((ConditionalExpression) source).test);
    }

    public String propertyName() {
      return "test";
    }
  }

  public static class ConditionalExpression_Consequent extends ASTPath.TrivialPath<ConditionalExpression, Expression> {
    @Override
    Maybe<Expression> apply(Object source) {
      if (!(source instanceof ConditionalExpression)) return Maybe.empty();
      return Maybe.of(((ConditionalExpression) source).consequent);
    }

    public String propertyName() {
      return "consequent";
    }
  }

  public static class ConditionalExpression_Alternate extends ASTPath.TrivialPath<ConditionalExpression, Expression> {
    @Override
    Maybe<Expression> apply(Object source) {
      if (!(source instanceof ConditionalExpression)) return Maybe.empty();
      return Maybe.of(((ConditionalExpression) source).alternate);
    }

    public String propertyName() {
      return "alternate";
    }
  }

  public static class ContinueStatement_Label extends ASTPath.TrivialPath<ContinueStatement, String> {
    @Override
    Maybe<String> apply(Object source) {
      if (!(source instanceof ContinueStatement)) return Maybe.empty();
      return ((ContinueStatement) source).label;
    }

    public String propertyName() {
      return "label";
    }
  }

  public static class DataProperty_Name extends ASTPath.TrivialPath<DataProperty, PropertyName> {
    @Override
    Maybe<PropertyName> apply(Object source) {
      if (!(source instanceof DataProperty)) return Maybe.empty();
      return Maybe.of(((DataProperty) source).name);
    }

    public String propertyName() {
      return "name";
    }
  }

  public static class DataProperty_Expression extends ASTPath.TrivialPath<DataProperty, Expression> {
    @Override
    Maybe<Expression> apply(Object source) {
      if (!(source instanceof DataProperty)) return Maybe.empty();
      return Maybe.of(((DataProperty) source).expression);
    }

    public String propertyName() {
      return "expression";
    }
  }

  public static class Directive_RawValue extends ASTPath.TrivialPath<Directive, String> {
    @Override
    Maybe<String> apply(Object source) {
      if (!(source instanceof Directive)) return Maybe.empty();
      return Maybe.of(((Directive) source).rawValue);
    }

    public String propertyName() {
      return "rawValue";
    }
  }

  public static class DoWhileStatement_Body extends ASTPath.TrivialPath<DoWhileStatement, Statement> {
    @Override
    Maybe<Statement> apply(Object source) {
      if (!(source instanceof DoWhileStatement)) return Maybe.empty();
      return Maybe.of(((DoWhileStatement) source).body);
    }

    public String propertyName() {
      return "body";
    }
  }

  public static class DoWhileStatement_Test extends ASTPath.TrivialPath<DoWhileStatement, Expression> {
    @Override
    Maybe<Expression> apply(Object source) {
      if (!(source instanceof DoWhileStatement)) return Maybe.empty();
      return Maybe.of(((DoWhileStatement) source).test);
    }

    public String propertyName() {
      return "test";
    }
  }

  public static class Export_Declaration extends ASTPath.TrivialPath<Export, FunctionDeclarationClassDeclarationVariableDeclaration> {
    @Override
    Maybe<FunctionDeclarationClassDeclarationVariableDeclaration> apply(Object source) {
      if (!(source instanceof Export)) return Maybe.empty();
      return Maybe.of(((Export) source).declaration);
    }

    public String propertyName() {
      return "declaration";
    }
  }

  public static class ExportAllFrom_ModuleSpecifier extends ASTPath.TrivialPath<ExportAllFrom, String> {
    @Override
    Maybe<String> apply(Object source) {
      if (!(source instanceof ExportAllFrom)) return Maybe.empty();
      return Maybe.of(((ExportAllFrom) source).moduleSpecifier);
    }

    public String propertyName() {
      return "moduleSpecifier";
    }
  }

  public static class ExportDefault_Body extends ASTPath.TrivialPath<ExportDefault, FunctionDeclarationClassDeclarationExpression> {
    @Override
    Maybe<FunctionDeclarationClassDeclarationExpression> apply(Object source) {
      if (!(source instanceof ExportDefault)) return Maybe.empty();
      return Maybe.of(((ExportDefault) source).body);
    }

    public String propertyName() {
      return "body";
    }
  }

  public static class ExportFrom_NamedExports extends ASTPath.IndexedPath<ExportFrom, ExportFromSpecifier> {
    protected ExportFrom_NamedExports(int index) {
      super(index);
    }

    @Override
    Maybe<ExportFromSpecifier> apply(Object source) {
      if (!(source instanceof ExportFrom)) return Maybe.empty();
      return ((ExportFrom) source).namedExports.index(index);
    }

    public String propertyName() {
      return "namedExports[" + Integer.toString(index) + "]";
    }
  }

  public static class ExportFrom_ModuleSpecifier extends ASTPath.TrivialPath<ExportFrom, String> {
    @Override
    Maybe<String> apply(Object source) {
      if (!(source instanceof ExportFrom)) return Maybe.empty();
      return Maybe.of(((ExportFrom) source).moduleSpecifier);
    }

    public String propertyName() {
      return "moduleSpecifier";
    }
  }

  public static class ExportFromSpecifier_Name extends ASTPath.TrivialPath<ExportFromSpecifier, String> {
    @Override
    Maybe<String> apply(Object source) {
      if (!(source instanceof ExportFromSpecifier)) return Maybe.empty();
      return Maybe.of(((ExportFromSpecifier) source).name);
    }

    public String propertyName() {
      return "name";
    }
  }

  public static class ExportFromSpecifier_ExportedName extends ASTPath.TrivialPath<ExportFromSpecifier, String> {
    @Override
    Maybe<String> apply(Object source) {
      if (!(source instanceof ExportFromSpecifier)) return Maybe.empty();
      return ((ExportFromSpecifier) source).exportedName;
    }

    public String propertyName() {
      return "exportedName";
    }
  }

  public static class ExportLocalSpecifier_Name extends ASTPath.TrivialPath<ExportLocalSpecifier, IdentifierExpression> {
    @Override
    Maybe<IdentifierExpression> apply(Object source) {
      if (!(source instanceof ExportLocalSpecifier)) return Maybe.empty();
      return Maybe.of(((ExportLocalSpecifier) source).name);
    }

    public String propertyName() {
      return "name";
    }
  }

  public static class ExportLocalSpecifier_ExportedName extends ASTPath.TrivialPath<ExportLocalSpecifier, String> {
    @Override
    Maybe<String> apply(Object source) {
      if (!(source instanceof ExportLocalSpecifier)) return Maybe.empty();
      return ((ExportLocalSpecifier) source).exportedName;
    }

    public String propertyName() {
      return "exportedName";
    }
  }

  public static class ExportLocals_NamedExports extends ASTPath.IndexedPath<ExportLocals, ExportLocalSpecifier> {
    protected ExportLocals_NamedExports(int index) {
      super(index);
    }

    @Override
    Maybe<ExportLocalSpecifier> apply(Object source) {
      if (!(source instanceof ExportLocals)) return Maybe.empty();
      return ((ExportLocals) source).namedExports.index(index);
    }

    public String propertyName() {
      return "namedExports[" + Integer.toString(index) + "]";
    }
  }

  public static class ExpressionStatement_Expression extends ASTPath.TrivialPath<ExpressionStatement, Expression> {
    @Override
    Maybe<Expression> apply(Object source) {
      if (!(source instanceof ExpressionStatement)) return Maybe.empty();
      return Maybe.of(((ExpressionStatement) source).expression);
    }

    public String propertyName() {
      return "expression";
    }
  }

  public static class ForInStatement_Left extends ASTPath.TrivialPath<ForInStatement, VariableDeclarationAssignmentTarget> {
    @Override
    Maybe<VariableDeclarationAssignmentTarget> apply(Object source) {
      if (!(source instanceof ForInStatement)) return Maybe.empty();
      return Maybe.of(((ForInStatement) source).left);
    }

    public String propertyName() {
      return "left";
    }
  }

  public static class ForInStatement_Right extends ASTPath.TrivialPath<ForInStatement, Expression> {
    @Override
    Maybe<Expression> apply(Object source) {
      if (!(source instanceof ForInStatement)) return Maybe.empty();
      return Maybe.of(((ForInStatement) source).right);
    }

    public String propertyName() {
      return "right";
    }
  }

  public static class ForInStatement_Body extends ASTPath.TrivialPath<ForInStatement, Statement> {
    @Override
    Maybe<Statement> apply(Object source) {
      if (!(source instanceof ForInStatement)) return Maybe.empty();
      return Maybe.of(((ForInStatement) source).body);
    }

    public String propertyName() {
      return "body";
    }
  }

  public static class ForOfStatement_Left extends ASTPath.TrivialPath<ForOfStatement, VariableDeclarationAssignmentTarget> {
    @Override
    Maybe<VariableDeclarationAssignmentTarget> apply(Object source) {
      if (!(source instanceof ForOfStatement)) return Maybe.empty();
      return Maybe.of(((ForOfStatement) source).left);
    }

    public String propertyName() {
      return "left";
    }
  }

  public static class ForOfStatement_Right extends ASTPath.TrivialPath<ForOfStatement, Expression> {
    @Override
    Maybe<Expression> apply(Object source) {
      if (!(source instanceof ForOfStatement)) return Maybe.empty();
      return Maybe.of(((ForOfStatement) source).right);
    }

    public String propertyName() {
      return "right";
    }
  }

  public static class ForOfStatement_Body extends ASTPath.TrivialPath<ForOfStatement, Statement> {
    @Override
    Maybe<Statement> apply(Object source) {
      if (!(source instanceof ForOfStatement)) return Maybe.empty();
      return Maybe.of(((ForOfStatement) source).body);
    }

    public String propertyName() {
      return "body";
    }
  }

  public static class ForStatement_Init extends ASTPath.TrivialPath<ForStatement, VariableDeclarationExpression> {
    @Override
    Maybe<VariableDeclarationExpression> apply(Object source) {
      if (!(source instanceof ForStatement)) return Maybe.empty();
      return ((ForStatement) source).init;
    }

    public String propertyName() {
      return "init";
    }
  }

  public static class ForStatement_Test extends ASTPath.TrivialPath<ForStatement, Expression> {
    @Override
    Maybe<Expression> apply(Object source) {
      if (!(source instanceof ForStatement)) return Maybe.empty();
      return ((ForStatement) source).test;
    }

    public String propertyName() {
      return "test";
    }
  }

  public static class ForStatement_Update extends ASTPath.TrivialPath<ForStatement, Expression> {
    @Override
    Maybe<Expression> apply(Object source) {
      if (!(source instanceof ForStatement)) return Maybe.empty();
      return ((ForStatement) source).update;
    }

    public String propertyName() {
      return "update";
    }
  }

  public static class ForStatement_Body extends ASTPath.TrivialPath<ForStatement, Statement> {
    @Override
    Maybe<Statement> apply(Object source) {
      if (!(source instanceof ForStatement)) return Maybe.empty();
      return Maybe.of(((ForStatement) source).body);
    }

    public String propertyName() {
      return "body";
    }
  }

  public static class FormalParameters_Items extends ASTPath.IndexedPath<FormalParameters, Parameter> {
    protected FormalParameters_Items(int index) {
      super(index);
    }

    @Override
    Maybe<Parameter> apply(Object source) {
      if (!(source instanceof FormalParameters)) return Maybe.empty();
      return ((FormalParameters) source).items.index(index);
    }

    public String propertyName() {
      return "items[" + Integer.toString(index) + "]";
    }
  }

  public static class FormalParameters_Rest extends ASTPath.TrivialPath<FormalParameters, Binding> {
    @Override
    Maybe<Binding> apply(Object source) {
      if (!(source instanceof FormalParameters)) return Maybe.empty();
      return ((FormalParameters) source).rest;
    }

    public String propertyName() {
      return "rest";
    }
  }

  public static class FunctionBody_Directives extends ASTPath.IndexedPath<FunctionBody, Directive> {
    protected FunctionBody_Directives(int index) {
      super(index);
    }

    @Override
    Maybe<Directive> apply(Object source) {
      if (!(source instanceof FunctionBody)) return Maybe.empty();
      return ((FunctionBody) source).directives.index(index);
    }

    public String propertyName() {
      return "directives[" + Integer.toString(index) + "]";
    }
  }

  public static class FunctionBody_Statements extends ASTPath.IndexedPath<FunctionBody, Statement> {
    protected FunctionBody_Statements(int index) {
      super(index);
    }

    @Override
    Maybe<Statement> apply(Object source) {
      if (!(source instanceof FunctionBody)) return Maybe.empty();
      return ((FunctionBody) source).statements.index(index);
    }

    public String propertyName() {
      return "statements[" + Integer.toString(index) + "]";
    }
  }

  public static class FunctionDeclaration_IsAsync extends ASTPath.TrivialPath<FunctionDeclaration, Boolean> {
    @Override
    Maybe<Boolean> apply(Object source) {
      if (!(source instanceof FunctionDeclaration)) return Maybe.empty();
      return Maybe.of(((FunctionDeclaration) source).isAsync);
    }

    public String propertyName() {
      return "isAsync";
    }
  }

  public static class FunctionDeclaration_IsGenerator extends ASTPath.TrivialPath<FunctionDeclaration, Boolean> {
    @Override
    Maybe<Boolean> apply(Object source) {
      if (!(source instanceof FunctionDeclaration)) return Maybe.empty();
      return Maybe.of(((FunctionDeclaration) source).isGenerator);
    }

    public String propertyName() {
      return "isGenerator";
    }
  }

  public static class FunctionDeclaration_Name extends ASTPath.TrivialPath<FunctionDeclaration, BindingIdentifier> {
    @Override
    Maybe<BindingIdentifier> apply(Object source) {
      if (!(source instanceof FunctionDeclaration)) return Maybe.empty();
      return Maybe.of(((FunctionDeclaration) source).name);
    }

    public String propertyName() {
      return "name";
    }
  }

  public static class FunctionDeclaration_Params extends ASTPath.TrivialPath<FunctionDeclaration, FormalParameters> {
    @Override
    Maybe<FormalParameters> apply(Object source) {
      if (!(source instanceof FunctionDeclaration)) return Maybe.empty();
      return Maybe.of(((FunctionDeclaration) source).params);
    }

    public String propertyName() {
      return "params";
    }
  }

  public static class FunctionDeclaration_Body extends ASTPath.TrivialPath<FunctionDeclaration, FunctionBody> {
    @Override
    Maybe<FunctionBody> apply(Object source) {
      if (!(source instanceof FunctionDeclaration)) return Maybe.empty();
      return Maybe.of(((FunctionDeclaration) source).body);
    }

    public String propertyName() {
      return "body";
    }
  }

  public static class FunctionExpression_IsAsync extends ASTPath.TrivialPath<FunctionExpression, Boolean> {
    @Override
    Maybe<Boolean> apply(Object source) {
      if (!(source instanceof FunctionExpression)) return Maybe.empty();
      return Maybe.of(((FunctionExpression) source).isAsync);
    }

    public String propertyName() {
      return "isAsync";
    }
  }

  public static class FunctionExpression_IsGenerator extends ASTPath.TrivialPath<FunctionExpression, Boolean> {
    @Override
    Maybe<Boolean> apply(Object source) {
      if (!(source instanceof FunctionExpression)) return Maybe.empty();
      return Maybe.of(((FunctionExpression) source).isGenerator);
    }

    public String propertyName() {
      return "isGenerator";
    }
  }

  public static class FunctionExpression_Name extends ASTPath.TrivialPath<FunctionExpression, BindingIdentifier> {
    @Override
    Maybe<BindingIdentifier> apply(Object source) {
      if (!(source instanceof FunctionExpression)) return Maybe.empty();
      return ((FunctionExpression) source).name;
    }

    public String propertyName() {
      return "name";
    }
  }

  public static class FunctionExpression_Params extends ASTPath.TrivialPath<FunctionExpression, FormalParameters> {
    @Override
    Maybe<FormalParameters> apply(Object source) {
      if (!(source instanceof FunctionExpression)) return Maybe.empty();
      return Maybe.of(((FunctionExpression) source).params);
    }

    public String propertyName() {
      return "params";
    }
  }

  public static class FunctionExpression_Body extends ASTPath.TrivialPath<FunctionExpression, FunctionBody> {
    @Override
    Maybe<FunctionBody> apply(Object source) {
      if (!(source instanceof FunctionExpression)) return Maybe.empty();
      return Maybe.of(((FunctionExpression) source).body);
    }

    public String propertyName() {
      return "body";
    }
  }

  public static class Getter_Name extends ASTPath.TrivialPath<Getter, PropertyName> {
    @Override
    Maybe<PropertyName> apply(Object source) {
      if (!(source instanceof Getter)) return Maybe.empty();
      return Maybe.of(((Getter) source).name);
    }

    public String propertyName() {
      return "name";
    }
  }

  public static class Getter_Body extends ASTPath.TrivialPath<Getter, FunctionBody> {
    @Override
    Maybe<FunctionBody> apply(Object source) {
      if (!(source instanceof Getter)) return Maybe.empty();
      return Maybe.of(((Getter) source).body);
    }

    public String propertyName() {
      return "body";
    }
  }

  public static class IdentifierExpression_Name extends ASTPath.TrivialPath<IdentifierExpression, String> {
    @Override
    Maybe<String> apply(Object source) {
      if (!(source instanceof IdentifierExpression)) return Maybe.empty();
      return Maybe.of(((IdentifierExpression) source).name);
    }

    public String propertyName() {
      return "name";
    }
  }

  public static class IfStatement_Test extends ASTPath.TrivialPath<IfStatement, Expression> {
    @Override
    Maybe<Expression> apply(Object source) {
      if (!(source instanceof IfStatement)) return Maybe.empty();
      return Maybe.of(((IfStatement) source).test);
    }

    public String propertyName() {
      return "test";
    }
  }

  public static class IfStatement_Consequent extends ASTPath.TrivialPath<IfStatement, Statement> {
    @Override
    Maybe<Statement> apply(Object source) {
      if (!(source instanceof IfStatement)) return Maybe.empty();
      return Maybe.of(((IfStatement) source).consequent);
    }

    public String propertyName() {
      return "consequent";
    }
  }

  public static class IfStatement_Alternate extends ASTPath.TrivialPath<IfStatement, Statement> {
    @Override
    Maybe<Statement> apply(Object source) {
      if (!(source instanceof IfStatement)) return Maybe.empty();
      return ((IfStatement) source).alternate;
    }

    public String propertyName() {
      return "alternate";
    }
  }

  public static class Import_DefaultBinding extends ASTPath.TrivialPath<Import, BindingIdentifier> {
    @Override
    Maybe<BindingIdentifier> apply(Object source) {
      if (!(source instanceof Import)) return Maybe.empty();
      return ((Import) source).defaultBinding;
    }

    public String propertyName() {
      return "defaultBinding";
    }
  }

  public static class Import_NamedImports extends ASTPath.IndexedPath<Import, ImportSpecifier> {
    protected Import_NamedImports(int index) {
      super(index);
    }

    @Override
    Maybe<ImportSpecifier> apply(Object source) {
      if (!(source instanceof Import)) return Maybe.empty();
      return ((Import) source).namedImports.index(index);
    }

    public String propertyName() {
      return "namedImports[" + Integer.toString(index) + "]";
    }
  }

  public static class Import_ModuleSpecifier extends ASTPath.TrivialPath<Import, String> {
    @Override
    Maybe<String> apply(Object source) {
      if (!(source instanceof Import)) return Maybe.empty();
      return Maybe.of(((Import) source).moduleSpecifier);
    }

    public String propertyName() {
      return "moduleSpecifier";
    }
  }

  public static class ImportNamespace_DefaultBinding extends ASTPath.TrivialPath<ImportNamespace, BindingIdentifier> {
    @Override
    Maybe<BindingIdentifier> apply(Object source) {
      if (!(source instanceof ImportNamespace)) return Maybe.empty();
      return ((ImportNamespace) source).defaultBinding;
    }

    public String propertyName() {
      return "defaultBinding";
    }
  }

  public static class ImportNamespace_NamespaceBinding extends ASTPath.TrivialPath<ImportNamespace, BindingIdentifier> {
    @Override
    Maybe<BindingIdentifier> apply(Object source) {
      if (!(source instanceof ImportNamespace)) return Maybe.empty();
      return Maybe.of(((ImportNamespace) source).namespaceBinding);
    }

    public String propertyName() {
      return "namespaceBinding";
    }
  }

  public static class ImportNamespace_ModuleSpecifier extends ASTPath.TrivialPath<ImportNamespace, String> {
    @Override
    Maybe<String> apply(Object source) {
      if (!(source instanceof ImportNamespace)) return Maybe.empty();
      return Maybe.of(((ImportNamespace) source).moduleSpecifier);
    }

    public String propertyName() {
      return "moduleSpecifier";
    }
  }

  public static class ImportSpecifier_Name extends ASTPath.TrivialPath<ImportSpecifier, String> {
    @Override
    Maybe<String> apply(Object source) {
      if (!(source instanceof ImportSpecifier)) return Maybe.empty();
      return ((ImportSpecifier) source).name;
    }

    public String propertyName() {
      return "name";
    }
  }

  public static class ImportSpecifier_Binding extends ASTPath.TrivialPath<ImportSpecifier, BindingIdentifier> {
    @Override
    Maybe<BindingIdentifier> apply(Object source) {
      if (!(source instanceof ImportSpecifier)) return Maybe.empty();
      return Maybe.of(((ImportSpecifier) source).binding);
    }

    public String propertyName() {
      return "binding";
    }
  }

  public static class LabeledStatement_Label extends ASTPath.TrivialPath<LabeledStatement, String> {
    @Override
    Maybe<String> apply(Object source) {
      if (!(source instanceof LabeledStatement)) return Maybe.empty();
      return Maybe.of(((LabeledStatement) source).label);
    }

    public String propertyName() {
      return "label";
    }
  }

  public static class LabeledStatement_Body extends ASTPath.TrivialPath<LabeledStatement, Statement> {
    @Override
    Maybe<Statement> apply(Object source) {
      if (!(source instanceof LabeledStatement)) return Maybe.empty();
      return Maybe.of(((LabeledStatement) source).body);
    }

    public String propertyName() {
      return "body";
    }
  }

  public static class LiteralBooleanExpression_Value extends ASTPath.TrivialPath<LiteralBooleanExpression, Boolean> {
    @Override
    Maybe<Boolean> apply(Object source) {
      if (!(source instanceof LiteralBooleanExpression)) return Maybe.empty();
      return Maybe.of(((LiteralBooleanExpression) source).value);
    }

    public String propertyName() {
      return "value";
    }
  }

  public static class LiteralNumericExpression_Value extends ASTPath.TrivialPath<LiteralNumericExpression, Double> {
    @Override
    Maybe<Double> apply(Object source) {
      if (!(source instanceof LiteralNumericExpression)) return Maybe.empty();
      return Maybe.of(((LiteralNumericExpression) source).value);
    }

    public String propertyName() {
      return "value";
    }
  }

  public static class LiteralRegExpExpression_Pattern extends ASTPath.TrivialPath<LiteralRegExpExpression, String> {
    @Override
    Maybe<String> apply(Object source) {
      if (!(source instanceof LiteralRegExpExpression)) return Maybe.empty();
      return Maybe.of(((LiteralRegExpExpression) source).pattern);
    }

    public String propertyName() {
      return "pattern";
    }
  }

  public static class LiteralRegExpExpression_Global extends ASTPath.TrivialPath<LiteralRegExpExpression, Boolean> {
    @Override
    Maybe<Boolean> apply(Object source) {
      if (!(source instanceof LiteralRegExpExpression)) return Maybe.empty();
      return Maybe.of(((LiteralRegExpExpression) source).global);
    }

    public String propertyName() {
      return "global";
    }
  }

  public static class LiteralRegExpExpression_IgnoreCase extends ASTPath.TrivialPath<LiteralRegExpExpression, Boolean> {
    @Override
    Maybe<Boolean> apply(Object source) {
      if (!(source instanceof LiteralRegExpExpression)) return Maybe.empty();
      return Maybe.of(((LiteralRegExpExpression) source).ignoreCase);
    }

    public String propertyName() {
      return "ignoreCase";
    }
  }

  public static class LiteralRegExpExpression_MultiLine extends ASTPath.TrivialPath<LiteralRegExpExpression, Boolean> {
    @Override
    Maybe<Boolean> apply(Object source) {
      if (!(source instanceof LiteralRegExpExpression)) return Maybe.empty();
      return Maybe.of(((LiteralRegExpExpression) source).multiLine);
    }

    public String propertyName() {
      return "multiLine";
    }
  }

  public static class LiteralRegExpExpression_Sticky extends ASTPath.TrivialPath<LiteralRegExpExpression, Boolean> {
    @Override
    Maybe<Boolean> apply(Object source) {
      if (!(source instanceof LiteralRegExpExpression)) return Maybe.empty();
      return Maybe.of(((LiteralRegExpExpression) source).sticky);
    }

    public String propertyName() {
      return "sticky";
    }
  }

  public static class LiteralRegExpExpression_Unicode extends ASTPath.TrivialPath<LiteralRegExpExpression, Boolean> {
    @Override
    Maybe<Boolean> apply(Object source) {
      if (!(source instanceof LiteralRegExpExpression)) return Maybe.empty();
      return Maybe.of(((LiteralRegExpExpression) source).unicode);
    }

    public String propertyName() {
      return "unicode";
    }
  }

  public static class LiteralStringExpression_Value extends ASTPath.TrivialPath<LiteralStringExpression, String> {
    @Override
    Maybe<String> apply(Object source) {
      if (!(source instanceof LiteralStringExpression)) return Maybe.empty();
      return Maybe.of(((LiteralStringExpression) source).value);
    }

    public String propertyName() {
      return "value";
    }
  }

  public static class Method_IsAsync extends ASTPath.TrivialPath<Method, Boolean> {
    @Override
    Maybe<Boolean> apply(Object source) {
      if (!(source instanceof Method)) return Maybe.empty();
      return Maybe.of(((Method) source).isAsync);
    }

    public String propertyName() {
      return "isAsync";
    }
  }

  public static class Method_IsGenerator extends ASTPath.TrivialPath<Method, Boolean> {
    @Override
    Maybe<Boolean> apply(Object source) {
      if (!(source instanceof Method)) return Maybe.empty();
      return Maybe.of(((Method) source).isGenerator);
    }

    public String propertyName() {
      return "isGenerator";
    }
  }

  public static class Method_Name extends ASTPath.TrivialPath<Method, PropertyName> {
    @Override
    Maybe<PropertyName> apply(Object source) {
      if (!(source instanceof Method)) return Maybe.empty();
      return Maybe.of(((Method) source).name);
    }

    public String propertyName() {
      return "name";
    }
  }

  public static class Method_Params extends ASTPath.TrivialPath<Method, FormalParameters> {
    @Override
    Maybe<FormalParameters> apply(Object source) {
      if (!(source instanceof Method)) return Maybe.empty();
      return Maybe.of(((Method) source).params);
    }

    public String propertyName() {
      return "params";
    }
  }

  public static class Method_Body extends ASTPath.TrivialPath<Method, FunctionBody> {
    @Override
    Maybe<FunctionBody> apply(Object source) {
      if (!(source instanceof Method)) return Maybe.empty();
      return Maybe.of(((Method) source).body);
    }

    public String propertyName() {
      return "body";
    }
  }

  public static class Module_Directives extends ASTPath.IndexedPath<Module, Directive> {
    protected Module_Directives(int index) {
      super(index);
    }

    @Override
    Maybe<Directive> apply(Object source) {
      if (!(source instanceof Module)) return Maybe.empty();
      return ((Module) source).directives.index(index);
    }

    public String propertyName() {
      return "directives[" + Integer.toString(index) + "]";
    }
  }

  public static class Module_Items extends ASTPath.IndexedPath<Module, ImportDeclarationExportDeclarationStatement> {
    protected Module_Items(int index) {
      super(index);
    }

    @Override
    Maybe<ImportDeclarationExportDeclarationStatement> apply(Object source) {
      if (!(source instanceof Module)) return Maybe.empty();
      return ((Module) source).items.index(index);
    }

    public String propertyName() {
      return "items[" + Integer.toString(index) + "]";
    }
  }

  public static class NewExpression_Callee extends ASTPath.TrivialPath<NewExpression, Expression> {
    @Override
    Maybe<Expression> apply(Object source) {
      if (!(source instanceof NewExpression)) return Maybe.empty();
      return Maybe.of(((NewExpression) source).callee);
    }

    public String propertyName() {
      return "callee";
    }
  }

  public static class NewExpression_Arguments extends ASTPath.IndexedPath<NewExpression, SpreadElementExpression> {
    protected NewExpression_Arguments(int index) {
      super(index);
    }

    @Override
    Maybe<SpreadElementExpression> apply(Object source) {
      if (!(source instanceof NewExpression)) return Maybe.empty();
      return ((NewExpression) source).arguments.index(index);
    }

    public String propertyName() {
      return "arguments[" + Integer.toString(index) + "]";
    }
  }

  public static class ObjectAssignmentTarget_Properties extends ASTPath.IndexedPath<ObjectAssignmentTarget, AssignmentTargetProperty> {
    protected ObjectAssignmentTarget_Properties(int index) {
      super(index);
    }

    @Override
    Maybe<AssignmentTargetProperty> apply(Object source) {
      if (!(source instanceof ObjectAssignmentTarget)) return Maybe.empty();
      return ((ObjectAssignmentTarget) source).properties.index(index);
    }

    public String propertyName() {
      return "properties[" + Integer.toString(index) + "]";
    }
  }

  public static class ObjectBinding_Properties extends ASTPath.IndexedPath<ObjectBinding, BindingProperty> {
    protected ObjectBinding_Properties(int index) {
      super(index);
    }

    @Override
    Maybe<BindingProperty> apply(Object source) {
      if (!(source instanceof ObjectBinding)) return Maybe.empty();
      return ((ObjectBinding) source).properties.index(index);
    }

    public String propertyName() {
      return "properties[" + Integer.toString(index) + "]";
    }
  }

  public static class ObjectExpression_Properties extends ASTPath.IndexedPath<ObjectExpression, ObjectProperty> {
    protected ObjectExpression_Properties(int index) {
      super(index);
    }

    @Override
    Maybe<ObjectProperty> apply(Object source) {
      if (!(source instanceof ObjectExpression)) return Maybe.empty();
      return ((ObjectExpression) source).properties.index(index);
    }

    public String propertyName() {
      return "properties[" + Integer.toString(index) + "]";
    }
  }

  public static class ReturnStatement_Expression extends ASTPath.TrivialPath<ReturnStatement, Expression> {
    @Override
    Maybe<Expression> apply(Object source) {
      if (!(source instanceof ReturnStatement)) return Maybe.empty();
      return ((ReturnStatement) source).expression;
    }

    public String propertyName() {
      return "expression";
    }
  }

  public static class Script_Directives extends ASTPath.IndexedPath<Script, Directive> {
    protected Script_Directives(int index) {
      super(index);
    }

    @Override
    Maybe<Directive> apply(Object source) {
      if (!(source instanceof Script)) return Maybe.empty();
      return ((Script) source).directives.index(index);
    }

    public String propertyName() {
      return "directives[" + Integer.toString(index) + "]";
    }
  }

  public static class Script_Statements extends ASTPath.IndexedPath<Script, Statement> {
    protected Script_Statements(int index) {
      super(index);
    }

    @Override
    Maybe<Statement> apply(Object source) {
      if (!(source instanceof Script)) return Maybe.empty();
      return ((Script) source).statements.index(index);
    }

    public String propertyName() {
      return "statements[" + Integer.toString(index) + "]";
    }
  }

  public static class Setter_Name extends ASTPath.TrivialPath<Setter, PropertyName> {
    @Override
    Maybe<PropertyName> apply(Object source) {
      if (!(source instanceof Setter)) return Maybe.empty();
      return Maybe.of(((Setter) source).name);
    }

    public String propertyName() {
      return "name";
    }
  }

  public static class Setter_Param extends ASTPath.TrivialPath<Setter, Parameter> {
    @Override
    Maybe<Parameter> apply(Object source) {
      if (!(source instanceof Setter)) return Maybe.empty();
      return Maybe.of(((Setter) source).param);
    }

    public String propertyName() {
      return "param";
    }
  }

  public static class Setter_Body extends ASTPath.TrivialPath<Setter, FunctionBody> {
    @Override
    Maybe<FunctionBody> apply(Object source) {
      if (!(source instanceof Setter)) return Maybe.empty();
      return Maybe.of(((Setter) source).body);
    }

    public String propertyName() {
      return "body";
    }
  }

  public static class ShorthandProperty_Name extends ASTPath.TrivialPath<ShorthandProperty, IdentifierExpression> {
    @Override
    Maybe<IdentifierExpression> apply(Object source) {
      if (!(source instanceof ShorthandProperty)) return Maybe.empty();
      return Maybe.of(((ShorthandProperty) source).name);
    }

    public String propertyName() {
      return "name";
    }
  }

  public static class SpreadElement_Expression extends ASTPath.TrivialPath<SpreadElement, Expression> {
    @Override
    Maybe<Expression> apply(Object source) {
      if (!(source instanceof SpreadElement)) return Maybe.empty();
      return Maybe.of(((SpreadElement) source).expression);
    }

    public String propertyName() {
      return "expression";
    }
  }

  public static class StaticMemberAssignmentTarget_Object extends ASTPath.TrivialPath<StaticMemberAssignmentTarget, ExpressionSuper> {
    @Override
    Maybe<ExpressionSuper> apply(Object source) {
      if (!(source instanceof StaticMemberAssignmentTarget)) return Maybe.empty();
      return Maybe.of(((StaticMemberAssignmentTarget) source).object);
    }

    public String propertyName() {
      return "object";
    }
  }

  public static class StaticMemberAssignmentTarget_Property extends ASTPath.TrivialPath<StaticMemberAssignmentTarget, String> {
    @Override
    Maybe<String> apply(Object source) {
      if (!(source instanceof StaticMemberAssignmentTarget)) return Maybe.empty();
      return Maybe.of(((StaticMemberAssignmentTarget) source).property);
    }

    public String propertyName() {
      return "property";
    }
  }

  public static class StaticMemberExpression_Object extends ASTPath.TrivialPath<StaticMemberExpression, ExpressionSuper> {
    @Override
    Maybe<ExpressionSuper> apply(Object source) {
      if (!(source instanceof StaticMemberExpression)) return Maybe.empty();
      return Maybe.of(((StaticMemberExpression) source).object);
    }

    public String propertyName() {
      return "object";
    }
  }

  public static class StaticMemberExpression_Property extends ASTPath.TrivialPath<StaticMemberExpression, String> {
    @Override
    Maybe<String> apply(Object source) {
      if (!(source instanceof StaticMemberExpression)) return Maybe.empty();
      return Maybe.of(((StaticMemberExpression) source).property);
    }

    public String propertyName() {
      return "property";
    }
  }

  public static class StaticPropertyName_Value extends ASTPath.TrivialPath<StaticPropertyName, String> {
    @Override
    Maybe<String> apply(Object source) {
      if (!(source instanceof StaticPropertyName)) return Maybe.empty();
      return Maybe.of(((StaticPropertyName) source).value);
    }

    public String propertyName() {
      return "value";
    }
  }

  public static class SwitchCase_Test extends ASTPath.TrivialPath<SwitchCase, Expression> {
    @Override
    Maybe<Expression> apply(Object source) {
      if (!(source instanceof SwitchCase)) return Maybe.empty();
      return Maybe.of(((SwitchCase) source).test);
    }

    public String propertyName() {
      return "test";
    }
  }

  public static class SwitchCase_Consequent extends ASTPath.IndexedPath<SwitchCase, Statement> {
    protected SwitchCase_Consequent(int index) {
      super(index);
    }

    @Override
    Maybe<Statement> apply(Object source) {
      if (!(source instanceof SwitchCase)) return Maybe.empty();
      return ((SwitchCase) source).consequent.index(index);
    }

    public String propertyName() {
      return "consequent[" + Integer.toString(index) + "]";
    }
  }

  public static class SwitchDefault_Consequent extends ASTPath.IndexedPath<SwitchDefault, Statement> {
    protected SwitchDefault_Consequent(int index) {
      super(index);
    }

    @Override
    Maybe<Statement> apply(Object source) {
      if (!(source instanceof SwitchDefault)) return Maybe.empty();
      return ((SwitchDefault) source).consequent.index(index);
    }

    public String propertyName() {
      return "consequent[" + Integer.toString(index) + "]";
    }
  }

  public static class SwitchStatement_Discriminant extends ASTPath.TrivialPath<SwitchStatement, Expression> {
    @Override
    Maybe<Expression> apply(Object source) {
      if (!(source instanceof SwitchStatement)) return Maybe.empty();
      return Maybe.of(((SwitchStatement) source).discriminant);
    }

    public String propertyName() {
      return "discriminant";
    }
  }

  public static class SwitchStatement_Cases extends ASTPath.IndexedPath<SwitchStatement, SwitchCase> {
    protected SwitchStatement_Cases(int index) {
      super(index);
    }

    @Override
    Maybe<SwitchCase> apply(Object source) {
      if (!(source instanceof SwitchStatement)) return Maybe.empty();
      return ((SwitchStatement) source).cases.index(index);
    }

    public String propertyName() {
      return "cases[" + Integer.toString(index) + "]";
    }
  }

  public static class SwitchStatementWithDefault_Discriminant extends ASTPath.TrivialPath<SwitchStatementWithDefault, Expression> {
    @Override
    Maybe<Expression> apply(Object source) {
      if (!(source instanceof SwitchStatementWithDefault)) return Maybe.empty();
      return Maybe.of(((SwitchStatementWithDefault) source).discriminant);
    }

    public String propertyName() {
      return "discriminant";
    }
  }

  public static class SwitchStatementWithDefault_PreDefaultCases extends ASTPath.IndexedPath<SwitchStatementWithDefault, SwitchCase> {
    protected SwitchStatementWithDefault_PreDefaultCases(int index) {
      super(index);
    }

    @Override
    Maybe<SwitchCase> apply(Object source) {
      if (!(source instanceof SwitchStatementWithDefault)) return Maybe.empty();
      return ((SwitchStatementWithDefault) source).preDefaultCases.index(index);
    }

    public String propertyName() {
      return "preDefaultCases[" + Integer.toString(index) + "]";
    }
  }

  public static class SwitchStatementWithDefault_DefaultCase extends ASTPath.TrivialPath<SwitchStatementWithDefault, SwitchDefault> {
    @Override
    Maybe<SwitchDefault> apply(Object source) {
      if (!(source instanceof SwitchStatementWithDefault)) return Maybe.empty();
      return Maybe.of(((SwitchStatementWithDefault) source).defaultCase);
    }

    public String propertyName() {
      return "defaultCase";
    }
  }

  public static class SwitchStatementWithDefault_PostDefaultCases extends ASTPath.IndexedPath<SwitchStatementWithDefault, SwitchCase> {
    protected SwitchStatementWithDefault_PostDefaultCases(int index) {
      super(index);
    }

    @Override
    Maybe<SwitchCase> apply(Object source) {
      if (!(source instanceof SwitchStatementWithDefault)) return Maybe.empty();
      return ((SwitchStatementWithDefault) source).postDefaultCases.index(index);
    }

    public String propertyName() {
      return "postDefaultCases[" + Integer.toString(index) + "]";
    }
  }

  public static class TemplateElement_RawValue extends ASTPath.TrivialPath<TemplateElement, String> {
    @Override
    Maybe<String> apply(Object source) {
      if (!(source instanceof TemplateElement)) return Maybe.empty();
      return Maybe.of(((TemplateElement) source).rawValue);
    }

    public String propertyName() {
      return "rawValue";
    }
  }

  public static class TemplateExpression_Tag extends ASTPath.TrivialPath<TemplateExpression, Expression> {
    @Override
    Maybe<Expression> apply(Object source) {
      if (!(source instanceof TemplateExpression)) return Maybe.empty();
      return ((TemplateExpression) source).tag;
    }

    public String propertyName() {
      return "tag";
    }
  }

  public static class TemplateExpression_Elements extends ASTPath.IndexedPath<TemplateExpression, ExpressionTemplateElement> {
    protected TemplateExpression_Elements(int index) {
      super(index);
    }

    @Override
    Maybe<ExpressionTemplateElement> apply(Object source) {
      if (!(source instanceof TemplateExpression)) return Maybe.empty();
      return ((TemplateExpression) source).elements.index(index);
    }

    public String propertyName() {
      return "elements[" + Integer.toString(index) + "]";
    }
  }

  public static class ThrowStatement_Expression extends ASTPath.TrivialPath<ThrowStatement, Expression> {
    @Override
    Maybe<Expression> apply(Object source) {
      if (!(source instanceof ThrowStatement)) return Maybe.empty();
      return Maybe.of(((ThrowStatement) source).expression);
    }

    public String propertyName() {
      return "expression";
    }
  }

  public static class TryCatchStatement_Body extends ASTPath.TrivialPath<TryCatchStatement, Block> {
    @Override
    Maybe<Block> apply(Object source) {
      if (!(source instanceof TryCatchStatement)) return Maybe.empty();
      return Maybe.of(((TryCatchStatement) source).body);
    }

    public String propertyName() {
      return "body";
    }
  }

  public static class TryCatchStatement_CatchClause extends ASTPath.TrivialPath<TryCatchStatement, CatchClause> {
    @Override
    Maybe<CatchClause> apply(Object source) {
      if (!(source instanceof TryCatchStatement)) return Maybe.empty();
      return Maybe.of(((TryCatchStatement) source).catchClause);
    }

    public String propertyName() {
      return "catchClause";
    }
  }

  public static class TryFinallyStatement_Body extends ASTPath.TrivialPath<TryFinallyStatement, Block> {
    @Override
    Maybe<Block> apply(Object source) {
      if (!(source instanceof TryFinallyStatement)) return Maybe.empty();
      return Maybe.of(((TryFinallyStatement) source).body);
    }

    public String propertyName() {
      return "body";
    }
  }

  public static class TryFinallyStatement_CatchClause extends ASTPath.TrivialPath<TryFinallyStatement, CatchClause> {
    @Override
    Maybe<CatchClause> apply(Object source) {
      if (!(source instanceof TryFinallyStatement)) return Maybe.empty();
      return ((TryFinallyStatement) source).catchClause;
    }

    public String propertyName() {
      return "catchClause";
    }
  }

  public static class TryFinallyStatement_Finalizer extends ASTPath.TrivialPath<TryFinallyStatement, Block> {
    @Override
    Maybe<Block> apply(Object source) {
      if (!(source instanceof TryFinallyStatement)) return Maybe.empty();
      return Maybe.of(((TryFinallyStatement) source).finalizer);
    }

    public String propertyName() {
      return "finalizer";
    }
  }

  public static class UnaryExpression_Operator extends ASTPath.TrivialPath<UnaryExpression, com.shapesecurity.shift.es2017.ast.operators.UnaryOperator> {
    @Override
    Maybe<com.shapesecurity.shift.es2017.ast.operators.UnaryOperator> apply(Object source) {
      if (!(source instanceof UnaryExpression)) return Maybe.empty();
      return Maybe.of(((UnaryExpression) source).operator);
    }

    public String propertyName() {
      return "operator";
    }
  }

  public static class UnaryExpression_Operand extends ASTPath.TrivialPath<UnaryExpression, Expression> {
    @Override
    Maybe<Expression> apply(Object source) {
      if (!(source instanceof UnaryExpression)) return Maybe.empty();
      return Maybe.of(((UnaryExpression) source).operand);
    }

    public String propertyName() {
      return "operand";
    }
  }

  public static class UpdateExpression_IsPrefix extends ASTPath.TrivialPath<UpdateExpression, Boolean> {
    @Override
    Maybe<Boolean> apply(Object source) {
      if (!(source instanceof UpdateExpression)) return Maybe.empty();
      return Maybe.of(((UpdateExpression) source).isPrefix);
    }

    public String propertyName() {
      return "isPrefix";
    }
  }

  public static class UpdateExpression_Operator extends ASTPath.TrivialPath<UpdateExpression, com.shapesecurity.shift.es2017.ast.operators.UpdateOperator> {
    @Override
    Maybe<com.shapesecurity.shift.es2017.ast.operators.UpdateOperator> apply(Object source) {
      if (!(source instanceof UpdateExpression)) return Maybe.empty();
      return Maybe.of(((UpdateExpression) source).operator);
    }

    public String propertyName() {
      return "operator";
    }
  }

  public static class UpdateExpression_Operand extends ASTPath.TrivialPath<UpdateExpression, SimpleAssignmentTarget> {
    @Override
    Maybe<SimpleAssignmentTarget> apply(Object source) {
      if (!(source instanceof UpdateExpression)) return Maybe.empty();
      return Maybe.of(((UpdateExpression) source).operand);
    }

    public String propertyName() {
      return "operand";
    }
  }

  public static class VariableDeclaration_Kind extends ASTPath.TrivialPath<VariableDeclaration, VariableDeclarationKind> {
    @Override
    Maybe<VariableDeclarationKind> apply(Object source) {
      if (!(source instanceof VariableDeclaration)) return Maybe.empty();
      return Maybe.of(((VariableDeclaration) source).kind);
    }

    public String propertyName() {
      return "kind";
    }
  }

  public static class VariableDeclaration_Declarators extends ASTPath.IndexedPath<VariableDeclaration, VariableDeclarator> {
    protected VariableDeclaration_Declarators(int index) {
      super(index);
    }

    @Override
    Maybe<VariableDeclarator> apply(Object source) {
      if (!(source instanceof VariableDeclaration)) return Maybe.empty();
      return ((VariableDeclaration) source).declarators.index(index);
    }

    public String propertyName() {
      return "declarators[" + Integer.toString(index) + "]";
    }
  }

  public static class VariableDeclarationStatement_Declaration extends ASTPath.TrivialPath<VariableDeclarationStatement, VariableDeclaration> {
    @Override
    Maybe<VariableDeclaration> apply(Object source) {
      if (!(source instanceof VariableDeclarationStatement)) return Maybe.empty();
      return Maybe.of(((VariableDeclarationStatement) source).declaration);
    }

    public String propertyName() {
      return "declaration";
    }
  }

  public static class VariableDeclarator_Binding extends ASTPath.TrivialPath<VariableDeclarator, Binding> {
    @Override
    Maybe<Binding> apply(Object source) {
      if (!(source instanceof VariableDeclarator)) return Maybe.empty();
      return Maybe.of(((VariableDeclarator) source).binding);
    }

    public String propertyName() {
      return "binding";
    }
  }

  public static class VariableDeclarator_Init extends ASTPath.TrivialPath<VariableDeclarator, Expression> {
    @Override
    Maybe<Expression> apply(Object source) {
      if (!(source instanceof VariableDeclarator)) return Maybe.empty();
      return ((VariableDeclarator) source).init;
    }

    public String propertyName() {
      return "init";
    }
  }

  public static class WhileStatement_Test extends ASTPath.TrivialPath<WhileStatement, Expression> {
    @Override
    Maybe<Expression> apply(Object source) {
      if (!(source instanceof WhileStatement)) return Maybe.empty();
      return Maybe.of(((WhileStatement) source).test);
    }

    public String propertyName() {
      return "test";
    }
  }

  public static class WhileStatement_Body extends ASTPath.TrivialPath<WhileStatement, Statement> {
    @Override
    Maybe<Statement> apply(Object source) {
      if (!(source instanceof WhileStatement)) return Maybe.empty();
      return Maybe.of(((WhileStatement) source).body);
    }

    public String propertyName() {
      return "body";
    }
  }

  public static class WithStatement_Object extends ASTPath.TrivialPath<WithStatement, Expression> {
    @Override
    Maybe<Expression> apply(Object source) {
      if (!(source instanceof WithStatement)) return Maybe.empty();
      return Maybe.of(((WithStatement) source).object);
    }

    public String propertyName() {
      return "object";
    }
  }

  public static class WithStatement_Body extends ASTPath.TrivialPath<WithStatement, Statement> {
    @Override
    Maybe<Statement> apply(Object source) {
      if (!(source instanceof WithStatement)) return Maybe.empty();
      return Maybe.of(((WithStatement) source).body);
    }

    public String propertyName() {
      return "body";
    }
  }

  public static class YieldExpression_Expression extends ASTPath.TrivialPath<YieldExpression, Expression> {
    @Override
    Maybe<Expression> apply(Object source) {
      if (!(source instanceof YieldExpression)) return Maybe.empty();
      return ((YieldExpression) source).expression;
    }

    public String propertyName() {
      return "expression";
    }
  }

  public static class YieldGeneratorExpression_Expression extends ASTPath.TrivialPath<YieldGeneratorExpression, Expression> {
    @Override
    Maybe<Expression> apply(Object source) {
      if (!(source instanceof YieldGeneratorExpression)) return Maybe.empty();
      return Maybe.of(((YieldGeneratorExpression) source).expression);
    }

    public String propertyName() {
      return "expression";
    }
  }
}
