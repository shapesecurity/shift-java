// Generated by shift-spec-java/branch.js

/**
 * Copyright 2016 Shape Security, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License")
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.shapesecurity.shift.es2016.path;


import com.shapesecurity.functional.data.Maybe;
import com.shapesecurity.shift.es2016.ast.ArrayAssignmentTarget;
import com.shapesecurity.shift.es2016.ast.ArrayBinding;
import com.shapesecurity.shift.es2016.ast.ArrayExpression;
import com.shapesecurity.shift.es2016.ast.ArrowExpression;
import com.shapesecurity.shift.es2016.ast.AssignmentExpression;
import com.shapesecurity.shift.es2016.ast.AssignmentTargetPropertyIdentifier;
import com.shapesecurity.shift.es2016.ast.AssignmentTargetPropertyProperty;
import com.shapesecurity.shift.es2016.ast.AssignmentTargetWithDefault;
import com.shapesecurity.shift.es2016.ast.BinaryExpression;
import com.shapesecurity.shift.es2016.ast.BindingPropertyIdentifier;
import com.shapesecurity.shift.es2016.ast.BindingPropertyProperty;
import com.shapesecurity.shift.es2016.ast.BindingWithDefault;
import com.shapesecurity.shift.es2016.ast.Block;
import com.shapesecurity.shift.es2016.ast.BlockStatement;
import com.shapesecurity.shift.es2016.ast.CallExpression;
import com.shapesecurity.shift.es2016.ast.CatchClause;
import com.shapesecurity.shift.es2016.ast.ClassDeclaration;
import com.shapesecurity.shift.es2016.ast.ClassElement;
import com.shapesecurity.shift.es2016.ast.ClassExpression;
import com.shapesecurity.shift.es2016.ast.CompoundAssignmentExpression;
import com.shapesecurity.shift.es2016.ast.ComputedMemberAssignmentTarget;
import com.shapesecurity.shift.es2016.ast.ComputedMemberExpression;
import com.shapesecurity.shift.es2016.ast.ComputedPropertyName;
import com.shapesecurity.shift.es2016.ast.ConditionalExpression;
import com.shapesecurity.shift.es2016.ast.DataProperty;
import com.shapesecurity.shift.es2016.ast.DoWhileStatement;
import com.shapesecurity.shift.es2016.ast.Export;
import com.shapesecurity.shift.es2016.ast.ExportDefault;
import com.shapesecurity.shift.es2016.ast.ExportFrom;
import com.shapesecurity.shift.es2016.ast.ExportLocalSpecifier;
import com.shapesecurity.shift.es2016.ast.ExportLocals;
import com.shapesecurity.shift.es2016.ast.ExpressionStatement;
import com.shapesecurity.shift.es2016.ast.ForInStatement;
import com.shapesecurity.shift.es2016.ast.ForOfStatement;
import com.shapesecurity.shift.es2016.ast.ForStatement;
import com.shapesecurity.shift.es2016.ast.FormalParameters;
import com.shapesecurity.shift.es2016.ast.FunctionBody;
import com.shapesecurity.shift.es2016.ast.FunctionDeclaration;
import com.shapesecurity.shift.es2016.ast.FunctionExpression;
import com.shapesecurity.shift.es2016.ast.Getter;
import com.shapesecurity.shift.es2016.ast.IfStatement;
import com.shapesecurity.shift.es2016.ast.Import;
import com.shapesecurity.shift.es2016.ast.ImportNamespace;
import com.shapesecurity.shift.es2016.ast.ImportSpecifier;
import com.shapesecurity.shift.es2016.ast.LabeledStatement;
import com.shapesecurity.shift.es2016.ast.Method;
import com.shapesecurity.shift.es2016.ast.Module;
import com.shapesecurity.shift.es2016.ast.NewExpression;
import com.shapesecurity.shift.es2016.ast.Node;
import com.shapesecurity.shift.es2016.ast.ObjectAssignmentTarget;
import com.shapesecurity.shift.es2016.ast.ObjectBinding;
import com.shapesecurity.shift.es2016.ast.ObjectExpression;
import com.shapesecurity.shift.es2016.ast.ReturnStatement;
import com.shapesecurity.shift.es2016.ast.Script;
import com.shapesecurity.shift.es2016.ast.Setter;
import com.shapesecurity.shift.es2016.ast.ShorthandProperty;
import com.shapesecurity.shift.es2016.ast.SpreadElement;
import com.shapesecurity.shift.es2016.ast.StaticMemberAssignmentTarget;
import com.shapesecurity.shift.es2016.ast.StaticMemberExpression;
import com.shapesecurity.shift.es2016.ast.SwitchCase;
import com.shapesecurity.shift.es2016.ast.SwitchDefault;
import com.shapesecurity.shift.es2016.ast.SwitchStatement;
import com.shapesecurity.shift.es2016.ast.SwitchStatementWithDefault;
import com.shapesecurity.shift.es2016.ast.TemplateExpression;
import com.shapesecurity.shift.es2016.ast.ThrowStatement;
import com.shapesecurity.shift.es2016.ast.TryCatchStatement;
import com.shapesecurity.shift.es2016.ast.TryFinallyStatement;
import com.shapesecurity.shift.es2016.ast.UnaryExpression;
import com.shapesecurity.shift.es2016.ast.UpdateExpression;
import com.shapesecurity.shift.es2016.ast.VariableDeclaration;
import com.shapesecurity.shift.es2016.ast.VariableDeclarationStatement;
import com.shapesecurity.shift.es2016.ast.VariableDeclarator;
import com.shapesecurity.shift.es2016.ast.WhileStatement;
import com.shapesecurity.shift.es2016.ast.WithStatement;
import com.shapesecurity.shift.es2016.ast.YieldExpression;
import com.shapesecurity.shift.es2016.ast.YieldGeneratorExpression;

public abstract class Branch {
    abstract public Maybe<? extends Node> step(Node node);

    public static ArrayAssignmentTargetElements ArrayAssignmentTargetElements_(int index) {
        return new ArrayAssignmentTargetElements(index);
    }

    public static ArrayAssignmentTargetRest ArrayAssignmentTargetRest_() {
        return new ArrayAssignmentTargetRest();
    }

    public static ArrayBindingElements ArrayBindingElements_(int index) {
        return new ArrayBindingElements(index);
    }

    public static ArrayBindingRest ArrayBindingRest_() {
        return new ArrayBindingRest();
    }

    public static ArrayExpressionElements ArrayExpressionElements_(int index) {
        return new ArrayExpressionElements(index);
    }

    public static ArrowExpressionParams ArrowExpressionParams_() {
        return new ArrowExpressionParams();
    }

    public static ArrowExpressionBody ArrowExpressionBody_() {
        return new ArrowExpressionBody();
    }

    public static AssignmentExpressionBinding AssignmentExpressionBinding_() {
        return new AssignmentExpressionBinding();
    }

    public static AssignmentExpressionExpression AssignmentExpressionExpression_() {
        return new AssignmentExpressionExpression();
    }

    public static AssignmentTargetPropertyIdentifierBinding AssignmentTargetPropertyIdentifierBinding_() {
        return new AssignmentTargetPropertyIdentifierBinding();
    }

    public static AssignmentTargetPropertyIdentifierInit AssignmentTargetPropertyIdentifierInit_() {
        return new AssignmentTargetPropertyIdentifierInit();
    }

    public static AssignmentTargetPropertyPropertyName AssignmentTargetPropertyPropertyName_() {
        return new AssignmentTargetPropertyPropertyName();
    }

    public static AssignmentTargetPropertyPropertyBinding AssignmentTargetPropertyPropertyBinding_() {
        return new AssignmentTargetPropertyPropertyBinding();
    }

    public static AssignmentTargetWithDefaultBinding AssignmentTargetWithDefaultBinding_() {
        return new AssignmentTargetWithDefaultBinding();
    }

    public static AssignmentTargetWithDefaultInit AssignmentTargetWithDefaultInit_() {
        return new AssignmentTargetWithDefaultInit();
    }

    public static BinaryExpressionLeft BinaryExpressionLeft_() {
        return new BinaryExpressionLeft();
    }

    public static BinaryExpressionRight BinaryExpressionRight_() {
        return new BinaryExpressionRight();
    }

    public static BindingPropertyIdentifierBinding BindingPropertyIdentifierBinding_() {
        return new BindingPropertyIdentifierBinding();
    }

    public static BindingPropertyIdentifierInit BindingPropertyIdentifierInit_() {
        return new BindingPropertyIdentifierInit();
    }

    public static BindingPropertyPropertyName BindingPropertyPropertyName_() {
        return new BindingPropertyPropertyName();
    }

    public static BindingPropertyPropertyBinding BindingPropertyPropertyBinding_() {
        return new BindingPropertyPropertyBinding();
    }

    public static BindingWithDefaultBinding BindingWithDefaultBinding_() {
        return new BindingWithDefaultBinding();
    }

    public static BindingWithDefaultInit BindingWithDefaultInit_() {
        return new BindingWithDefaultInit();
    }

    public static BlockStatements BlockStatements_(int index) {
        return new BlockStatements(index);
    }

    public static BlockStatementBlock BlockStatementBlock_() {
        return new BlockStatementBlock();
    }

    public static CallExpressionCallee CallExpressionCallee_() {
        return new CallExpressionCallee();
    }

    public static CallExpressionArguments CallExpressionArguments_(int index) {
        return new CallExpressionArguments(index);
    }

    public static CatchClauseBinding CatchClauseBinding_() {
        return new CatchClauseBinding();
    }

    public static CatchClauseBody CatchClauseBody_() {
        return new CatchClauseBody();
    }

    public static ClassDeclarationName ClassDeclarationName_() {
        return new ClassDeclarationName();
    }

    public static ClassDeclarationSuper ClassDeclarationSuper_() {
        return new ClassDeclarationSuper();
    }

    public static ClassDeclarationElements ClassDeclarationElements_(int index) {
        return new ClassDeclarationElements(index);
    }

    public static ClassElementMethod ClassElementMethod_() {
        return new ClassElementMethod();
    }

    public static ClassExpressionName ClassExpressionName_() {
        return new ClassExpressionName();
    }

    public static ClassExpressionSuper ClassExpressionSuper_() {
        return new ClassExpressionSuper();
    }

    public static ClassExpressionElements ClassExpressionElements_(int index) {
        return new ClassExpressionElements(index);
    }

    public static CompoundAssignmentExpressionBinding CompoundAssignmentExpressionBinding_() {
        return new CompoundAssignmentExpressionBinding();
    }

    public static CompoundAssignmentExpressionExpression CompoundAssignmentExpressionExpression_() {
        return new CompoundAssignmentExpressionExpression();
    }

    public static ComputedMemberAssignmentTargetObject ComputedMemberAssignmentTargetObject_() {
        return new ComputedMemberAssignmentTargetObject();
    }

    public static ComputedMemberAssignmentTargetExpression ComputedMemberAssignmentTargetExpression_() {
        return new ComputedMemberAssignmentTargetExpression();
    }

    public static ComputedMemberExpressionObject ComputedMemberExpressionObject_() {
        return new ComputedMemberExpressionObject();
    }

    public static ComputedMemberExpressionExpression ComputedMemberExpressionExpression_() {
        return new ComputedMemberExpressionExpression();
    }

    public static ComputedPropertyNameExpression ComputedPropertyNameExpression_() {
        return new ComputedPropertyNameExpression();
    }

    public static ConditionalExpressionTest ConditionalExpressionTest_() {
        return new ConditionalExpressionTest();
    }

    public static ConditionalExpressionConsequent ConditionalExpressionConsequent_() {
        return new ConditionalExpressionConsequent();
    }

    public static ConditionalExpressionAlternate ConditionalExpressionAlternate_() {
        return new ConditionalExpressionAlternate();
    }

    public static DataPropertyName DataPropertyName_() {
        return new DataPropertyName();
    }

    public static DataPropertyExpression DataPropertyExpression_() {
        return new DataPropertyExpression();
    }

    public static DoWhileStatementBody DoWhileStatementBody_() {
        return new DoWhileStatementBody();
    }

    public static DoWhileStatementTest DoWhileStatementTest_() {
        return new DoWhileStatementTest();
    }

    public static ExportDeclaration ExportDeclaration_() {
        return new ExportDeclaration();
    }

    public static ExportDefaultBody ExportDefaultBody_() {
        return new ExportDefaultBody();
    }

    public static ExportFromNamedExports ExportFromNamedExports_(int index) {
        return new ExportFromNamedExports(index);
    }

    public static ExportLocalSpecifierName ExportLocalSpecifierName_() {
        return new ExportLocalSpecifierName();
    }

    public static ExportLocalsNamedExports ExportLocalsNamedExports_(int index) {
        return new ExportLocalsNamedExports(index);
    }

    public static ExpressionStatementExpression ExpressionStatementExpression_() {
        return new ExpressionStatementExpression();
    }

    public static ForInStatementLeft ForInStatementLeft_() {
        return new ForInStatementLeft();
    }

    public static ForInStatementRight ForInStatementRight_() {
        return new ForInStatementRight();
    }

    public static ForInStatementBody ForInStatementBody_() {
        return new ForInStatementBody();
    }

    public static ForOfStatementLeft ForOfStatementLeft_() {
        return new ForOfStatementLeft();
    }

    public static ForOfStatementRight ForOfStatementRight_() {
        return new ForOfStatementRight();
    }

    public static ForOfStatementBody ForOfStatementBody_() {
        return new ForOfStatementBody();
    }

    public static ForStatementInit ForStatementInit_() {
        return new ForStatementInit();
    }

    public static ForStatementTest ForStatementTest_() {
        return new ForStatementTest();
    }

    public static ForStatementUpdate ForStatementUpdate_() {
        return new ForStatementUpdate();
    }

    public static ForStatementBody ForStatementBody_() {
        return new ForStatementBody();
    }

    public static FormalParametersItems FormalParametersItems_(int index) {
        return new FormalParametersItems(index);
    }

    public static FormalParametersRest FormalParametersRest_() {
        return new FormalParametersRest();
    }

    public static FunctionBodyDirectives FunctionBodyDirectives_(int index) {
        return new FunctionBodyDirectives(index);
    }

    public static FunctionBodyStatements FunctionBodyStatements_(int index) {
        return new FunctionBodyStatements(index);
    }

    public static FunctionDeclarationName FunctionDeclarationName_() {
        return new FunctionDeclarationName();
    }

    public static FunctionDeclarationParams FunctionDeclarationParams_() {
        return new FunctionDeclarationParams();
    }

    public static FunctionDeclarationBody FunctionDeclarationBody_() {
        return new FunctionDeclarationBody();
    }

    public static FunctionExpressionName FunctionExpressionName_() {
        return new FunctionExpressionName();
    }

    public static FunctionExpressionParams FunctionExpressionParams_() {
        return new FunctionExpressionParams();
    }

    public static FunctionExpressionBody FunctionExpressionBody_() {
        return new FunctionExpressionBody();
    }

    public static GetterName GetterName_() {
        return new GetterName();
    }

    public static GetterBody GetterBody_() {
        return new GetterBody();
    }

    public static IfStatementTest IfStatementTest_() {
        return new IfStatementTest();
    }

    public static IfStatementConsequent IfStatementConsequent_() {
        return new IfStatementConsequent();
    }

    public static IfStatementAlternate IfStatementAlternate_() {
        return new IfStatementAlternate();
    }

    public static ImportDefaultBinding ImportDefaultBinding_() {
        return new ImportDefaultBinding();
    }

    public static ImportNamedImports ImportNamedImports_(int index) {
        return new ImportNamedImports(index);
    }

    public static ImportNamespaceDefaultBinding ImportNamespaceDefaultBinding_() {
        return new ImportNamespaceDefaultBinding();
    }

    public static ImportNamespaceNamespaceBinding ImportNamespaceNamespaceBinding_() {
        return new ImportNamespaceNamespaceBinding();
    }

    public static ImportSpecifierBinding ImportSpecifierBinding_() {
        return new ImportSpecifierBinding();
    }

    public static LabeledStatementBody LabeledStatementBody_() {
        return new LabeledStatementBody();
    }

    public static MethodName MethodName_() {
        return new MethodName();
    }

    public static MethodParams MethodParams_() {
        return new MethodParams();
    }

    public static MethodBody MethodBody_() {
        return new MethodBody();
    }

    public static ModuleDirectives ModuleDirectives_(int index) {
        return new ModuleDirectives(index);
    }

    public static ModuleItems ModuleItems_(int index) {
        return new ModuleItems(index);
    }

    public static NewExpressionCallee NewExpressionCallee_() {
        return new NewExpressionCallee();
    }

    public static NewExpressionArguments NewExpressionArguments_(int index) {
        return new NewExpressionArguments(index);
    }

    public static ObjectAssignmentTargetProperties ObjectAssignmentTargetProperties_(int index) {
        return new ObjectAssignmentTargetProperties(index);
    }

    public static ObjectBindingProperties ObjectBindingProperties_(int index) {
        return new ObjectBindingProperties(index);
    }

    public static ObjectExpressionProperties ObjectExpressionProperties_(int index) {
        return new ObjectExpressionProperties(index);
    }

    public static ReturnStatementExpression ReturnStatementExpression_() {
        return new ReturnStatementExpression();
    }

    public static ScriptDirectives ScriptDirectives_(int index) {
        return new ScriptDirectives(index);
    }

    public static ScriptStatements ScriptStatements_(int index) {
        return new ScriptStatements(index);
    }

    public static SetterName SetterName_() {
        return new SetterName();
    }

    public static SetterParam SetterParam_() {
        return new SetterParam();
    }

    public static SetterBody SetterBody_() {
        return new SetterBody();
    }

    public static ShorthandPropertyName ShorthandPropertyName_() {
        return new ShorthandPropertyName();
    }

    public static SpreadElementExpression SpreadElementExpression_() {
        return new SpreadElementExpression();
    }

    public static StaticMemberAssignmentTargetObject StaticMemberAssignmentTargetObject_() {
        return new StaticMemberAssignmentTargetObject();
    }

    public static StaticMemberExpressionObject StaticMemberExpressionObject_() {
        return new StaticMemberExpressionObject();
    }

    public static SwitchCaseTest SwitchCaseTest_() {
        return new SwitchCaseTest();
    }

    public static SwitchCaseConsequent SwitchCaseConsequent_(int index) {
        return new SwitchCaseConsequent(index);
    }

    public static SwitchDefaultConsequent SwitchDefaultConsequent_(int index) {
        return new SwitchDefaultConsequent(index);
    }

    public static SwitchStatementDiscriminant SwitchStatementDiscriminant_() {
        return new SwitchStatementDiscriminant();
    }

    public static SwitchStatementCases SwitchStatementCases_(int index) {
        return new SwitchStatementCases(index);
    }

    public static SwitchStatementWithDefaultDiscriminant SwitchStatementWithDefaultDiscriminant_() {
        return new SwitchStatementWithDefaultDiscriminant();
    }

    public static SwitchStatementWithDefaultPreDefaultCases SwitchStatementWithDefaultPreDefaultCases_(int index) {
        return new SwitchStatementWithDefaultPreDefaultCases(index);
    }

    public static SwitchStatementWithDefaultDefaultCase SwitchStatementWithDefaultDefaultCase_() {
        return new SwitchStatementWithDefaultDefaultCase();
    }

    public static SwitchStatementWithDefaultPostDefaultCases SwitchStatementWithDefaultPostDefaultCases_(int index) {
        return new SwitchStatementWithDefaultPostDefaultCases(index);
    }

    public static TemplateExpressionTag TemplateExpressionTag_() {
        return new TemplateExpressionTag();
    }

    public static TemplateExpressionElements TemplateExpressionElements_(int index) {
        return new TemplateExpressionElements(index);
    }

    public static ThrowStatementExpression ThrowStatementExpression_() {
        return new ThrowStatementExpression();
    }

    public static TryCatchStatementBody TryCatchStatementBody_() {
        return new TryCatchStatementBody();
    }

    public static TryCatchStatementCatchClause TryCatchStatementCatchClause_() {
        return new TryCatchStatementCatchClause();
    }

    public static TryFinallyStatementBody TryFinallyStatementBody_() {
        return new TryFinallyStatementBody();
    }

    public static TryFinallyStatementCatchClause TryFinallyStatementCatchClause_() {
        return new TryFinallyStatementCatchClause();
    }

    public static TryFinallyStatementFinalizer TryFinallyStatementFinalizer_() {
        return new TryFinallyStatementFinalizer();
    }

    public static UnaryExpressionOperand UnaryExpressionOperand_() {
        return new UnaryExpressionOperand();
    }

    public static UpdateExpressionOperand UpdateExpressionOperand_() {
        return new UpdateExpressionOperand();
    }

    public static VariableDeclarationDeclarators VariableDeclarationDeclarators_(int index) {
        return new VariableDeclarationDeclarators(index);
    }

    public static VariableDeclarationStatementDeclaration VariableDeclarationStatementDeclaration_() {
        return new VariableDeclarationStatementDeclaration();
    }

    public static VariableDeclaratorBinding VariableDeclaratorBinding_() {
        return new VariableDeclaratorBinding();
    }

    public static VariableDeclaratorInit VariableDeclaratorInit_() {
        return new VariableDeclaratorInit();
    }

    public static WhileStatementTest WhileStatementTest_() {
        return new WhileStatementTest();
    }

    public static WhileStatementBody WhileStatementBody_() {
        return new WhileStatementBody();
    }

    public static WithStatementObject WithStatementObject_() {
        return new WithStatementObject();
    }

    public static WithStatementBody WithStatementBody_() {
        return new WithStatementBody();
    }

    public static YieldExpressionExpression YieldExpressionExpression_() {
        return new YieldExpressionExpression();
    }

    public static YieldGeneratorExpressionExpression YieldGeneratorExpressionExpression_() {
        return new YieldGeneratorExpressionExpression();
    }

}

abstract class IndexedBranch extends Branch {
    public final int index;

    protected IndexedBranch(int index) {
        this.index = index;
    }
}

@SuppressWarnings("ConstantConditions")
    class ArrayAssignmentTargetElements extends IndexedBranch {
    protected ArrayAssignmentTargetElements(int index) {
        super(index);
    }

    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof ArrayAssignmentTarget)) return Maybe.empty();
        return ((ArrayAssignmentTarget) node).elements.index(index).orJust(Maybe.empty());
    }
}
@SuppressWarnings("ConstantConditions")
    class ArrayAssignmentTargetRest extends Branch {
    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof ArrayAssignmentTarget)) return Maybe.empty();
        return ((ArrayAssignmentTarget) node).rest;
    }
}
@SuppressWarnings("ConstantConditions")
    class ArrayBindingElements extends IndexedBranch {
    protected ArrayBindingElements(int index) {
        super(index);
    }

    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof ArrayBinding)) return Maybe.empty();
        return ((ArrayBinding) node).elements.index(index).orJust(Maybe.empty());
    }
}
@SuppressWarnings("ConstantConditions")
    class ArrayBindingRest extends Branch {
    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof ArrayBinding)) return Maybe.empty();
        return ((ArrayBinding) node).rest;
    }
}
@SuppressWarnings("ConstantConditions")
    class ArrayExpressionElements extends IndexedBranch {
    protected ArrayExpressionElements(int index) {
        super(index);
    }

    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof ArrayExpression)) return Maybe.empty();
        return ((ArrayExpression) node).elements.index(index).orJust(Maybe.empty());
    }
}
@SuppressWarnings("ConstantConditions")
    class ArrowExpressionParams extends Branch {
    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof ArrowExpression)) return Maybe.empty();
        return Maybe.of(((ArrowExpression) node).params);
    }
}
@SuppressWarnings("ConstantConditions")
    class ArrowExpressionBody extends Branch {
    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof ArrowExpression)) return Maybe.empty();
        return Maybe.of(((ArrowExpression) node).body);
    }
}
@SuppressWarnings("ConstantConditions")
    class AssignmentExpressionBinding extends Branch {
    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof AssignmentExpression)) return Maybe.empty();
        return Maybe.of(((AssignmentExpression) node).binding);
    }
}
@SuppressWarnings("ConstantConditions")
    class AssignmentExpressionExpression extends Branch {
    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof AssignmentExpression)) return Maybe.empty();
        return Maybe.of(((AssignmentExpression) node).expression);
    }
}
@SuppressWarnings("ConstantConditions")
    class AssignmentTargetPropertyIdentifierBinding extends Branch {
    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof AssignmentTargetPropertyIdentifier)) return Maybe.empty();
        return Maybe.of(((AssignmentTargetPropertyIdentifier) node).binding);
    }
}
@SuppressWarnings("ConstantConditions")
    class AssignmentTargetPropertyIdentifierInit extends Branch {
    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof AssignmentTargetPropertyIdentifier)) return Maybe.empty();
        return ((AssignmentTargetPropertyIdentifier) node).init;
    }
}
@SuppressWarnings("ConstantConditions")
    class AssignmentTargetPropertyPropertyName extends Branch {
    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof AssignmentTargetPropertyProperty)) return Maybe.empty();
        return Maybe.of(((AssignmentTargetPropertyProperty) node).name);
    }
}
@SuppressWarnings("ConstantConditions")
    class AssignmentTargetPropertyPropertyBinding extends Branch {
    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof AssignmentTargetPropertyProperty)) return Maybe.empty();
        return Maybe.of(((AssignmentTargetPropertyProperty) node).binding);
    }
}
@SuppressWarnings("ConstantConditions")
    class AssignmentTargetWithDefaultBinding extends Branch {
    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof AssignmentTargetWithDefault)) return Maybe.empty();
        return Maybe.of(((AssignmentTargetWithDefault) node).binding);
    }
}
@SuppressWarnings("ConstantConditions")
    class AssignmentTargetWithDefaultInit extends Branch {
    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof AssignmentTargetWithDefault)) return Maybe.empty();
        return Maybe.of(((AssignmentTargetWithDefault) node).init);
    }
}
@SuppressWarnings("ConstantConditions")
    class BinaryExpressionLeft extends Branch {
    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof BinaryExpression)) return Maybe.empty();
        return Maybe.of(((BinaryExpression) node).left);
    }
}
@SuppressWarnings("ConstantConditions")
    class BinaryExpressionRight extends Branch {
    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof BinaryExpression)) return Maybe.empty();
        return Maybe.of(((BinaryExpression) node).right);
    }
}
@SuppressWarnings("ConstantConditions")
    class BindingPropertyIdentifierBinding extends Branch {
    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof BindingPropertyIdentifier)) return Maybe.empty();
        return Maybe.of(((BindingPropertyIdentifier) node).binding);
    }
}
@SuppressWarnings("ConstantConditions")
    class BindingPropertyIdentifierInit extends Branch {
    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof BindingPropertyIdentifier)) return Maybe.empty();
        return ((BindingPropertyIdentifier) node).init;
    }
}
@SuppressWarnings("ConstantConditions")
    class BindingPropertyPropertyName extends Branch {
    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof BindingPropertyProperty)) return Maybe.empty();
        return Maybe.of(((BindingPropertyProperty) node).name);
    }
}
@SuppressWarnings("ConstantConditions")
    class BindingPropertyPropertyBinding extends Branch {
    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof BindingPropertyProperty)) return Maybe.empty();
        return Maybe.of(((BindingPropertyProperty) node).binding);
    }
}
@SuppressWarnings("ConstantConditions")
    class BindingWithDefaultBinding extends Branch {
    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof BindingWithDefault)) return Maybe.empty();
        return Maybe.of(((BindingWithDefault) node).binding);
    }
}
@SuppressWarnings("ConstantConditions")
    class BindingWithDefaultInit extends Branch {
    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof BindingWithDefault)) return Maybe.empty();
        return Maybe.of(((BindingWithDefault) node).init);
    }
}
@SuppressWarnings("ConstantConditions")
    class BlockStatements extends IndexedBranch {
    protected BlockStatements(int index) {
        super(index);
    }

    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof Block)) return Maybe.empty();
        return ((Block) node).statements.index(index);
    }
}
@SuppressWarnings("ConstantConditions")
    class BlockStatementBlock extends Branch {
    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof BlockStatement)) return Maybe.empty();
        return Maybe.of(((BlockStatement) node).block);
    }
}
@SuppressWarnings("ConstantConditions")
    class CallExpressionCallee extends Branch {
    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof CallExpression)) return Maybe.empty();
        return Maybe.of(((CallExpression) node).callee);
    }
}
@SuppressWarnings("ConstantConditions")
    class CallExpressionArguments extends IndexedBranch {
    protected CallExpressionArguments(int index) {
        super(index);
    }

    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof CallExpression)) return Maybe.empty();
        return ((CallExpression) node).arguments.index(index);
    }
}
@SuppressWarnings("ConstantConditions")
    class CatchClauseBinding extends Branch {
    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof CatchClause)) return Maybe.empty();
        return Maybe.of(((CatchClause) node).binding);
    }
}
@SuppressWarnings("ConstantConditions")
    class CatchClauseBody extends Branch {
    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof CatchClause)) return Maybe.empty();
        return Maybe.of(((CatchClause) node).body);
    }
}
@SuppressWarnings("ConstantConditions")
    class ClassDeclarationName extends Branch {
    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof ClassDeclaration)) return Maybe.empty();
        return Maybe.of(((ClassDeclaration) node).name);
    }
}
@SuppressWarnings("ConstantConditions")
    class ClassDeclarationSuper extends Branch {
    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof ClassDeclaration)) return Maybe.empty();
        return ((ClassDeclaration) node)._super;
    }
}
@SuppressWarnings("ConstantConditions")
    class ClassDeclarationElements extends IndexedBranch {
    protected ClassDeclarationElements(int index) {
        super(index);
    }

    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof ClassDeclaration)) return Maybe.empty();
        return ((ClassDeclaration) node).elements.index(index);
    }
}
@SuppressWarnings("ConstantConditions")
    class ClassElementMethod extends Branch {
    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof ClassElement)) return Maybe.empty();
        return Maybe.of(((ClassElement) node).method);
    }
}
@SuppressWarnings("ConstantConditions")
    class ClassExpressionName extends Branch {
    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof ClassExpression)) return Maybe.empty();
        return ((ClassExpression) node).name;
    }
}
@SuppressWarnings("ConstantConditions")
    class ClassExpressionSuper extends Branch {
    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof ClassExpression)) return Maybe.empty();
        return ((ClassExpression) node)._super;
    }
}
@SuppressWarnings("ConstantConditions")
    class ClassExpressionElements extends IndexedBranch {
    protected ClassExpressionElements(int index) {
        super(index);
    }

    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof ClassExpression)) return Maybe.empty();
        return ((ClassExpression) node).elements.index(index);
    }
}
@SuppressWarnings("ConstantConditions")
    class CompoundAssignmentExpressionBinding extends Branch {
    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof CompoundAssignmentExpression)) return Maybe.empty();
        return Maybe.of(((CompoundAssignmentExpression) node).binding);
    }
}
@SuppressWarnings("ConstantConditions")
    class CompoundAssignmentExpressionExpression extends Branch {
    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof CompoundAssignmentExpression)) return Maybe.empty();
        return Maybe.of(((CompoundAssignmentExpression) node).expression);
    }
}
@SuppressWarnings("ConstantConditions")
    class ComputedMemberAssignmentTargetObject extends Branch {
    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof ComputedMemberAssignmentTarget)) return Maybe.empty();
        return Maybe.of(((ComputedMemberAssignmentTarget) node).object);
    }
}
@SuppressWarnings("ConstantConditions")
    class ComputedMemberAssignmentTargetExpression extends Branch {
    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof ComputedMemberAssignmentTarget)) return Maybe.empty();
        return Maybe.of(((ComputedMemberAssignmentTarget) node).expression);
    }
}
@SuppressWarnings("ConstantConditions")
    class ComputedMemberExpressionObject extends Branch {
    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof ComputedMemberExpression)) return Maybe.empty();
        return Maybe.of(((ComputedMemberExpression) node).object);
    }
}
@SuppressWarnings("ConstantConditions")
    class ComputedMemberExpressionExpression extends Branch {
    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof ComputedMemberExpression)) return Maybe.empty();
        return Maybe.of(((ComputedMemberExpression) node).expression);
    }
}
@SuppressWarnings("ConstantConditions")
    class ComputedPropertyNameExpression extends Branch {
    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof ComputedPropertyName)) return Maybe.empty();
        return Maybe.of(((ComputedPropertyName) node).expression);
    }
}
@SuppressWarnings("ConstantConditions")
    class ConditionalExpressionTest extends Branch {
    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof ConditionalExpression)) return Maybe.empty();
        return Maybe.of(((ConditionalExpression) node).test);
    }
}
@SuppressWarnings("ConstantConditions")
    class ConditionalExpressionConsequent extends Branch {
    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof ConditionalExpression)) return Maybe.empty();
        return Maybe.of(((ConditionalExpression) node).consequent);
    }
}
@SuppressWarnings("ConstantConditions")
    class ConditionalExpressionAlternate extends Branch {
    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof ConditionalExpression)) return Maybe.empty();
        return Maybe.of(((ConditionalExpression) node).alternate);
    }
}
@SuppressWarnings("ConstantConditions")
    class DataPropertyName extends Branch {
    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof DataProperty)) return Maybe.empty();
        return Maybe.of(((DataProperty) node).name);
    }
}
@SuppressWarnings("ConstantConditions")
    class DataPropertyExpression extends Branch {
    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof DataProperty)) return Maybe.empty();
        return Maybe.of(((DataProperty) node).expression);
    }
}
@SuppressWarnings("ConstantConditions")
    class DoWhileStatementBody extends Branch {
    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof DoWhileStatement)) return Maybe.empty();
        return Maybe.of(((DoWhileStatement) node).body);
    }
}
@SuppressWarnings("ConstantConditions")
    class DoWhileStatementTest extends Branch {
    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof DoWhileStatement)) return Maybe.empty();
        return Maybe.of(((DoWhileStatement) node).test);
    }
}
@SuppressWarnings("ConstantConditions")
    class ExportDeclaration extends Branch {
    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof Export)) return Maybe.empty();
        return Maybe.of(((Export) node).declaration);
    }
}
@SuppressWarnings("ConstantConditions")
    class ExportDefaultBody extends Branch {
    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof ExportDefault)) return Maybe.empty();
        return Maybe.of(((ExportDefault) node).body);
    }
}
@SuppressWarnings("ConstantConditions")
    class ExportFromNamedExports extends IndexedBranch {
    protected ExportFromNamedExports(int index) {
        super(index);
    }

    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof ExportFrom)) return Maybe.empty();
        return ((ExportFrom) node).namedExports.index(index);
    }
}
@SuppressWarnings("ConstantConditions")
    class ExportLocalSpecifierName extends Branch {
    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof ExportLocalSpecifier)) return Maybe.empty();
        return Maybe.of(((ExportLocalSpecifier) node).name);
    }
}
@SuppressWarnings("ConstantConditions")
    class ExportLocalsNamedExports extends IndexedBranch {
    protected ExportLocalsNamedExports(int index) {
        super(index);
    }

    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof ExportLocals)) return Maybe.empty();
        return ((ExportLocals) node).namedExports.index(index);
    }
}
@SuppressWarnings("ConstantConditions")
    class ExpressionStatementExpression extends Branch {
    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof ExpressionStatement)) return Maybe.empty();
        return Maybe.of(((ExpressionStatement) node).expression);
    }
}
@SuppressWarnings("ConstantConditions")
    class ForInStatementLeft extends Branch {
    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof ForInStatement)) return Maybe.empty();
        return Maybe.of(((ForInStatement) node).left);
    }
}
@SuppressWarnings("ConstantConditions")
    class ForInStatementRight extends Branch {
    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof ForInStatement)) return Maybe.empty();
        return Maybe.of(((ForInStatement) node).right);
    }
}
@SuppressWarnings("ConstantConditions")
    class ForInStatementBody extends Branch {
    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof ForInStatement)) return Maybe.empty();
        return Maybe.of(((ForInStatement) node).body);
    }
}
@SuppressWarnings("ConstantConditions")
    class ForOfStatementLeft extends Branch {
    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof ForOfStatement)) return Maybe.empty();
        return Maybe.of(((ForOfStatement) node).left);
    }
}
@SuppressWarnings("ConstantConditions")
    class ForOfStatementRight extends Branch {
    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof ForOfStatement)) return Maybe.empty();
        return Maybe.of(((ForOfStatement) node).right);
    }
}
@SuppressWarnings("ConstantConditions")
    class ForOfStatementBody extends Branch {
    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof ForOfStatement)) return Maybe.empty();
        return Maybe.of(((ForOfStatement) node).body);
    }
}
@SuppressWarnings("ConstantConditions")
    class ForStatementInit extends Branch {
    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof ForStatement)) return Maybe.empty();
        return ((ForStatement) node).init;
    }
}
@SuppressWarnings("ConstantConditions")
    class ForStatementTest extends Branch {
    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof ForStatement)) return Maybe.empty();
        return ((ForStatement) node).test;
    }
}
@SuppressWarnings("ConstantConditions")
    class ForStatementUpdate extends Branch {
    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof ForStatement)) return Maybe.empty();
        return ((ForStatement) node).update;
    }
}
@SuppressWarnings("ConstantConditions")
    class ForStatementBody extends Branch {
    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof ForStatement)) return Maybe.empty();
        return Maybe.of(((ForStatement) node).body);
    }
}
@SuppressWarnings("ConstantConditions")
    class FormalParametersItems extends IndexedBranch {
    protected FormalParametersItems(int index) {
        super(index);
    }

    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof FormalParameters)) return Maybe.empty();
        return ((FormalParameters) node).items.index(index);
    }
}
@SuppressWarnings("ConstantConditions")
    class FormalParametersRest extends Branch {
    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof FormalParameters)) return Maybe.empty();
        return ((FormalParameters) node).rest;
    }
}
@SuppressWarnings("ConstantConditions")
    class FunctionBodyDirectives extends IndexedBranch {
    protected FunctionBodyDirectives(int index) {
        super(index);
    }

    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof FunctionBody)) return Maybe.empty();
        return ((FunctionBody) node).directives.index(index);
    }
}
@SuppressWarnings("ConstantConditions")
    class FunctionBodyStatements extends IndexedBranch {
    protected FunctionBodyStatements(int index) {
        super(index);
    }

    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof FunctionBody)) return Maybe.empty();
        return ((FunctionBody) node).statements.index(index);
    }
}
@SuppressWarnings("ConstantConditions")
    class FunctionDeclarationName extends Branch {
    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof FunctionDeclaration)) return Maybe.empty();
        return Maybe.of(((FunctionDeclaration) node).name);
    }
}
@SuppressWarnings("ConstantConditions")
    class FunctionDeclarationParams extends Branch {
    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof FunctionDeclaration)) return Maybe.empty();
        return Maybe.of(((FunctionDeclaration) node).params);
    }
}
@SuppressWarnings("ConstantConditions")
    class FunctionDeclarationBody extends Branch {
    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof FunctionDeclaration)) return Maybe.empty();
        return Maybe.of(((FunctionDeclaration) node).body);
    }
}
@SuppressWarnings("ConstantConditions")
    class FunctionExpressionName extends Branch {
    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof FunctionExpression)) return Maybe.empty();
        return ((FunctionExpression) node).name;
    }
}
@SuppressWarnings("ConstantConditions")
    class FunctionExpressionParams extends Branch {
    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof FunctionExpression)) return Maybe.empty();
        return Maybe.of(((FunctionExpression) node).params);
    }
}
@SuppressWarnings("ConstantConditions")
    class FunctionExpressionBody extends Branch {
    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof FunctionExpression)) return Maybe.empty();
        return Maybe.of(((FunctionExpression) node).body);
    }
}
@SuppressWarnings("ConstantConditions")
    class GetterName extends Branch {
    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof Getter)) return Maybe.empty();
        return Maybe.of(((Getter) node).name);
    }
}
@SuppressWarnings("ConstantConditions")
    class GetterBody extends Branch {
    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof Getter)) return Maybe.empty();
        return Maybe.of(((Getter) node).body);
    }
}
@SuppressWarnings("ConstantConditions")
    class IfStatementTest extends Branch {
    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof IfStatement)) return Maybe.empty();
        return Maybe.of(((IfStatement) node).test);
    }
}
@SuppressWarnings("ConstantConditions")
    class IfStatementConsequent extends Branch {
    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof IfStatement)) return Maybe.empty();
        return Maybe.of(((IfStatement) node).consequent);
    }
}
@SuppressWarnings("ConstantConditions")
    class IfStatementAlternate extends Branch {
    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof IfStatement)) return Maybe.empty();
        return ((IfStatement) node).alternate;
    }
}
@SuppressWarnings("ConstantConditions")
    class ImportDefaultBinding extends Branch {
    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof Import)) return Maybe.empty();
        return ((Import) node).defaultBinding;
    }
}
@SuppressWarnings("ConstantConditions")
    class ImportNamedImports extends IndexedBranch {
    protected ImportNamedImports(int index) {
        super(index);
    }

    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof Import)) return Maybe.empty();
        return ((Import) node).namedImports.index(index);
    }
}
@SuppressWarnings("ConstantConditions")
    class ImportNamespaceDefaultBinding extends Branch {
    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof ImportNamespace)) return Maybe.empty();
        return ((ImportNamespace) node).defaultBinding;
    }
}
@SuppressWarnings("ConstantConditions")
    class ImportNamespaceNamespaceBinding extends Branch {
    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof ImportNamespace)) return Maybe.empty();
        return Maybe.of(((ImportNamespace) node).namespaceBinding);
    }
}
@SuppressWarnings("ConstantConditions")
    class ImportSpecifierBinding extends Branch {
    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof ImportSpecifier)) return Maybe.empty();
        return Maybe.of(((ImportSpecifier) node).binding);
    }
}
@SuppressWarnings("ConstantConditions")
    class LabeledStatementBody extends Branch {
    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof LabeledStatement)) return Maybe.empty();
        return Maybe.of(((LabeledStatement) node).body);
    }
}
@SuppressWarnings("ConstantConditions")
    class MethodName extends Branch {
    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof Method)) return Maybe.empty();
        return Maybe.of(((Method) node).name);
    }
}
@SuppressWarnings("ConstantConditions")
    class MethodParams extends Branch {
    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof Method)) return Maybe.empty();
        return Maybe.of(((Method) node).params);
    }
}
@SuppressWarnings("ConstantConditions")
    class MethodBody extends Branch {
    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof Method)) return Maybe.empty();
        return Maybe.of(((Method) node).body);
    }
}
@SuppressWarnings("ConstantConditions")
    class ModuleDirectives extends IndexedBranch {
    protected ModuleDirectives(int index) {
        super(index);
    }

    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof Module)) return Maybe.empty();
        return ((Module) node).directives.index(index);
    }
}
@SuppressWarnings("ConstantConditions")
    class ModuleItems extends IndexedBranch {
    protected ModuleItems(int index) {
        super(index);
    }

    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof Module)) return Maybe.empty();
        return ((Module) node).items.index(index);
    }
}
@SuppressWarnings("ConstantConditions")
    class NewExpressionCallee extends Branch {
    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof NewExpression)) return Maybe.empty();
        return Maybe.of(((NewExpression) node).callee);
    }
}
@SuppressWarnings("ConstantConditions")
    class NewExpressionArguments extends IndexedBranch {
    protected NewExpressionArguments(int index) {
        super(index);
    }

    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof NewExpression)) return Maybe.empty();
        return ((NewExpression) node).arguments.index(index);
    }
}
@SuppressWarnings("ConstantConditions")
    class ObjectAssignmentTargetProperties extends IndexedBranch {
    protected ObjectAssignmentTargetProperties(int index) {
        super(index);
    }

    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof ObjectAssignmentTarget)) return Maybe.empty();
        return ((ObjectAssignmentTarget) node).properties.index(index);
    }
}
@SuppressWarnings("ConstantConditions")
    class ObjectBindingProperties extends IndexedBranch {
    protected ObjectBindingProperties(int index) {
        super(index);
    }

    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof ObjectBinding)) return Maybe.empty();
        return ((ObjectBinding) node).properties.index(index);
    }
}
@SuppressWarnings("ConstantConditions")
    class ObjectExpressionProperties extends IndexedBranch {
    protected ObjectExpressionProperties(int index) {
        super(index);
    }

    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof ObjectExpression)) return Maybe.empty();
        return ((ObjectExpression) node).properties.index(index);
    }
}
@SuppressWarnings("ConstantConditions")
    class ReturnStatementExpression extends Branch {
    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof ReturnStatement)) return Maybe.empty();
        return ((ReturnStatement) node).expression;
    }
}
@SuppressWarnings("ConstantConditions")
    class ScriptDirectives extends IndexedBranch {
    protected ScriptDirectives(int index) {
        super(index);
    }

    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof Script)) return Maybe.empty();
        return ((Script) node).directives.index(index);
    }
}
@SuppressWarnings("ConstantConditions")
    class ScriptStatements extends IndexedBranch {
    protected ScriptStatements(int index) {
        super(index);
    }

    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof Script)) return Maybe.empty();
        return ((Script) node).statements.index(index);
    }
}
@SuppressWarnings("ConstantConditions")
    class SetterName extends Branch {
    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof Setter)) return Maybe.empty();
        return Maybe.of(((Setter) node).name);
    }
}
@SuppressWarnings("ConstantConditions")
    class SetterParam extends Branch {
    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof Setter)) return Maybe.empty();
        return Maybe.of(((Setter) node).param);
    }
}
@SuppressWarnings("ConstantConditions")
    class SetterBody extends Branch {
    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof Setter)) return Maybe.empty();
        return Maybe.of(((Setter) node).body);
    }
}
@SuppressWarnings("ConstantConditions")
    class ShorthandPropertyName extends Branch {
    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof ShorthandProperty)) return Maybe.empty();
        return Maybe.of(((ShorthandProperty) node).name);
    }
}
@SuppressWarnings("ConstantConditions")
    class SpreadElementExpression extends Branch {
    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof SpreadElement)) return Maybe.empty();
        return Maybe.of(((SpreadElement) node).expression);
    }
}
@SuppressWarnings("ConstantConditions")
    class StaticMemberAssignmentTargetObject extends Branch {
    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof StaticMemberAssignmentTarget)) return Maybe.empty();
        return Maybe.of(((StaticMemberAssignmentTarget) node).object);
    }
}
@SuppressWarnings("ConstantConditions")
    class StaticMemberExpressionObject extends Branch {
    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof StaticMemberExpression)) return Maybe.empty();
        return Maybe.of(((StaticMemberExpression) node).object);
    }
}
@SuppressWarnings("ConstantConditions")
    class SwitchCaseTest extends Branch {
    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof SwitchCase)) return Maybe.empty();
        return Maybe.of(((SwitchCase) node).test);
    }
}
@SuppressWarnings("ConstantConditions")
    class SwitchCaseConsequent extends IndexedBranch {
    protected SwitchCaseConsequent(int index) {
        super(index);
    }

    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof SwitchCase)) return Maybe.empty();
        return ((SwitchCase) node).consequent.index(index);
    }
}
@SuppressWarnings("ConstantConditions")
    class SwitchDefaultConsequent extends IndexedBranch {
    protected SwitchDefaultConsequent(int index) {
        super(index);
    }

    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof SwitchDefault)) return Maybe.empty();
        return ((SwitchDefault) node).consequent.index(index);
    }
}
@SuppressWarnings("ConstantConditions")
    class SwitchStatementDiscriminant extends Branch {
    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof SwitchStatement)) return Maybe.empty();
        return Maybe.of(((SwitchStatement) node).discriminant);
    }
}
@SuppressWarnings("ConstantConditions")
    class SwitchStatementCases extends IndexedBranch {
    protected SwitchStatementCases(int index) {
        super(index);
    }

    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof SwitchStatement)) return Maybe.empty();
        return ((SwitchStatement) node).cases.index(index);
    }
}
@SuppressWarnings("ConstantConditions")
    class SwitchStatementWithDefaultDiscriminant extends Branch {
    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof SwitchStatementWithDefault)) return Maybe.empty();
        return Maybe.of(((SwitchStatementWithDefault) node).discriminant);
    }
}
@SuppressWarnings("ConstantConditions")
    class SwitchStatementWithDefaultPreDefaultCases extends IndexedBranch {
    protected SwitchStatementWithDefaultPreDefaultCases(int index) {
        super(index);
    }

    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof SwitchStatementWithDefault)) return Maybe.empty();
        return ((SwitchStatementWithDefault) node).preDefaultCases.index(index);
    }
}
@SuppressWarnings("ConstantConditions")
    class SwitchStatementWithDefaultDefaultCase extends Branch {
    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof SwitchStatementWithDefault)) return Maybe.empty();
        return Maybe.of(((SwitchStatementWithDefault) node).defaultCase);
    }
}
@SuppressWarnings("ConstantConditions")
    class SwitchStatementWithDefaultPostDefaultCases extends IndexedBranch {
    protected SwitchStatementWithDefaultPostDefaultCases(int index) {
        super(index);
    }

    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof SwitchStatementWithDefault)) return Maybe.empty();
        return ((SwitchStatementWithDefault) node).postDefaultCases.index(index);
    }
}
@SuppressWarnings("ConstantConditions")
    class TemplateExpressionTag extends Branch {
    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof TemplateExpression)) return Maybe.empty();
        return ((TemplateExpression) node).tag;
    }
}
@SuppressWarnings("ConstantConditions")
    class TemplateExpressionElements extends IndexedBranch {
    protected TemplateExpressionElements(int index) {
        super(index);
    }

    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof TemplateExpression)) return Maybe.empty();
        return ((TemplateExpression) node).elements.index(index);
    }
}
@SuppressWarnings("ConstantConditions")
    class ThrowStatementExpression extends Branch {
    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof ThrowStatement)) return Maybe.empty();
        return Maybe.of(((ThrowStatement) node).expression);
    }
}
@SuppressWarnings("ConstantConditions")
    class TryCatchStatementBody extends Branch {
    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof TryCatchStatement)) return Maybe.empty();
        return Maybe.of(((TryCatchStatement) node).body);
    }
}
@SuppressWarnings("ConstantConditions")
    class TryCatchStatementCatchClause extends Branch {
    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof TryCatchStatement)) return Maybe.empty();
        return Maybe.of(((TryCatchStatement) node).catchClause);
    }
}
@SuppressWarnings("ConstantConditions")
    class TryFinallyStatementBody extends Branch {
    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof TryFinallyStatement)) return Maybe.empty();
        return Maybe.of(((TryFinallyStatement) node).body);
    }
}
@SuppressWarnings("ConstantConditions")
    class TryFinallyStatementCatchClause extends Branch {
    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof TryFinallyStatement)) return Maybe.empty();
        return ((TryFinallyStatement) node).catchClause;
    }
}
@SuppressWarnings("ConstantConditions")
    class TryFinallyStatementFinalizer extends Branch {
    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof TryFinallyStatement)) return Maybe.empty();
        return Maybe.of(((TryFinallyStatement) node).finalizer);
    }
}
@SuppressWarnings("ConstantConditions")
    class UnaryExpressionOperand extends Branch {
    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof UnaryExpression)) return Maybe.empty();
        return Maybe.of(((UnaryExpression) node).operand);
    }
}
@SuppressWarnings("ConstantConditions")
    class UpdateExpressionOperand extends Branch {
    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof UpdateExpression)) return Maybe.empty();
        return Maybe.of(((UpdateExpression) node).operand);
    }
}
@SuppressWarnings("ConstantConditions")
    class VariableDeclarationDeclarators extends IndexedBranch {
    protected VariableDeclarationDeclarators(int index) {
        super(index);
    }

    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof VariableDeclaration)) return Maybe.empty();
        return ((VariableDeclaration) node).declarators.index(index);
    }
}
@SuppressWarnings("ConstantConditions")
    class VariableDeclarationStatementDeclaration extends Branch {
    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof VariableDeclarationStatement)) return Maybe.empty();
        return Maybe.of(((VariableDeclarationStatement) node).declaration);
    }
}
@SuppressWarnings("ConstantConditions")
    class VariableDeclaratorBinding extends Branch {
    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof VariableDeclarator)) return Maybe.empty();
        return Maybe.of(((VariableDeclarator) node).binding);
    }
}
@SuppressWarnings("ConstantConditions")
    class VariableDeclaratorInit extends Branch {
    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof VariableDeclarator)) return Maybe.empty();
        return ((VariableDeclarator) node).init;
    }
}
@SuppressWarnings("ConstantConditions")
    class WhileStatementTest extends Branch {
    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof WhileStatement)) return Maybe.empty();
        return Maybe.of(((WhileStatement) node).test);
    }
}
@SuppressWarnings("ConstantConditions")
    class WhileStatementBody extends Branch {
    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof WhileStatement)) return Maybe.empty();
        return Maybe.of(((WhileStatement) node).body);
    }
}
@SuppressWarnings("ConstantConditions")
    class WithStatementObject extends Branch {
    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof WithStatement)) return Maybe.empty();
        return Maybe.of(((WithStatement) node).object);
    }
}
@SuppressWarnings("ConstantConditions")
    class WithStatementBody extends Branch {
    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof WithStatement)) return Maybe.empty();
        return Maybe.of(((WithStatement) node).body);
    }
}
@SuppressWarnings("ConstantConditions")
    class YieldExpressionExpression extends Branch {
    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof YieldExpression)) return Maybe.empty();
        return ((YieldExpression) node).expression;
    }
}
@SuppressWarnings("ConstantConditions")
    class YieldGeneratorExpressionExpression extends Branch {
    @Override
    public Maybe<? extends Node> step(Node node) {
        if (!(node instanceof YieldGeneratorExpression)) return Maybe.empty();
        return Maybe.of(((YieldGeneratorExpression) node).expression);
    }
}
