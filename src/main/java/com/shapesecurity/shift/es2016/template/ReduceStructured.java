// Generated by shift-spec-java/template-structured-reducer.js

/*
 * Copyright 2018 Shape Security, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


package com.shapesecurity.shift.es2016.template;

import com.shapesecurity.functional.F;
import com.shapesecurity.functional.Pair;
import com.shapesecurity.functional.data.ConcatList;
import com.shapesecurity.functional.data.ImmutableList;
import com.shapesecurity.functional.data.Maybe;
import com.shapesecurity.functional.data.NonEmptyImmutableList;
import com.shapesecurity.shift.es2016.ast.*;
import com.shapesecurity.shift.es2016.reducer.ThunkedReducer;

import javax.annotation.Nonnull;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.function.Supplier;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class ReduceStructured implements ThunkedReducer<Node> {
    public static abstract class Label {}
    public static class Bare extends Label {
        final String name;

        public Bare(String name) {
            this.name = name;
        }
    }
    public static class If extends Label {
        final boolean inverted;
        final String condition;

        public If(boolean inverted, String condition) {
            this.inverted = inverted;
            this.condition = condition;
        }
    }
    public static class Loop extends Label {
        final String variable;
        final String values;

        public Loop(String variable, String values) {
            this.variable = variable;
            this.values = values;
        }
    }

    public static class TemplateValues { // TODO relocate to Template
        public final Map<String, Boolean> conditions;
        public final Map<String, List<TemplateValues>> lists;
        public final Map<String, F<Node, Node>> replacers;

        public TemplateValues(Map<String, Boolean> conditions, Map<String, List<TemplateValues>> lists, Map<String, F<Node, Node>> replacers) {
            this.conditions = conditions;
            this.lists = lists;
            this.replacers = replacers;
        }

        public TemplateValues merge(TemplateValues other, String namespace) {
             // non-destructive
            TemplateValues merged = new TemplateValues(new HashMap<>(this.conditions), new HashMap<>(this.lists), new HashMap<>(this.replacers));
            for (Map.Entry<String, Boolean> entry : other.conditions.entrySet()) {
                String namespaced = namespace + "::" + entry.getKey();
                if (merged.conditions.containsKey(namespaced)) {
                    throw new RuntimeException("Name " + namespaced + " already exists");
                }
                merged.conditions.put(namespaced, entry.getValue());
            }
            for (Map.Entry<String, List<TemplateValues>> entry : other.lists.entrySet()) {
                String namespaced = namespace + "::" + entry.getKey();
                if (merged.lists.containsKey(namespaced)) {
                    throw new RuntimeException("Name " + namespaced + " already exists");
                }
                merged.lists.put(namespaced, entry.getValue());
            }
            for (Map.Entry<String, F<Node, Node>> entry : other.replacers.entrySet()) {
                String namespaced = namespace + "::" + entry.getKey();
                if (merged.replacers.containsKey(namespaced)) {
                    throw new RuntimeException("Name " + namespaced + " already exists");
                }
                merged.replacers.put(namespaced, entry.getValue());
            }
            return merged;
        }
    }

    Map<Node, List<Label>> nodeToLabels;
    TemplateValues values;
    boolean currentNodeMayHaveStructuredLabel;

    public ReduceStructured(Map<Node, List<Label>> nodeToLabels, TemplateValues values) {
        this.nodeToLabels = nodeToLabels;
        this.values = values;
        this.currentNodeMayHaveStructuredLabel = false;
    }

    void enforceNoStrayStructuralLabels(Node node) {
        List<Label> labels = this.nodeToLabels.get(node);
        if (!this.currentNodeMayHaveStructuredLabel && labels != null && labels.stream().anyMatch(l -> !(l instanceof Bare))) {
            Label label = labels.stream().filter(l -> !(l instanceof Bare)).findFirst().get();
            if (label instanceof If) {
                throw new RuntimeException("Node of type " + node.getClass().getSimpleName() + " with condition " + ((If) label).condition + " is not in an omittable position");
            } else if (label instanceof Loop) {
                throw new RuntimeException("Node of type " + node.getClass().getSimpleName() + " iterating over " + ((Loop) label).values + " is not in a loopable position");
            } else {
                throw new RuntimeException("unreachable");
            }
        }
        this.currentNodeMayHaveStructuredLabel = false;
    }

    Node applyReplacer(Node original, Node transformed) {
        List<Label> labels = this.nodeToLabels.get(original);
        if (labels == null || labels.isEmpty()) {
            return transformed;
        }
        List<Bare> bareLabels = labels.stream().flatMap(l -> l instanceof Bare ? Stream.of((Bare) l) : Stream.empty()).collect(Collectors.toList());
        if (bareLabels.size() > 1) {
            throw new RuntimeException("Node has multiple labels: " + bareLabels.get(0).name + ", " + bareLabels.get(1).name);
        }
        if (bareLabels.isEmpty()) {
            return transformed;
        }
        F<Node, Node> replacer = this.values.replacers.get(bareLabels.get(0).name);
        if (replacer == null) {
            throw new RuntimeException("Replacer " + bareLabels.get(0).name + " not found");
        }
        return replacer.apply(transformed);
    }

    <T extends Node> ImmutableList<T> applyListLabels(ImmutableList<T> originalChildren, ImmutableList<Supplier<Node>> childThunks) {
        return originalChildren.zipWith(Pair::of, childThunks).flatMap(p -> {
            List<Label> childLabels = this.nodeToLabels.get(p.left);
            if (childLabels == null || childLabels.isEmpty()) {
                return ImmutableList.of(p.right.get());
            }
            return this.applyLabels(p.right, ImmutableList.from(childLabels).filter(l -> !(l instanceof Bare))).toList();
        }).map(n -> (T) n);
    }

    <T extends Node> Maybe<T> applyMaybeLabels(Maybe<T> originalChild, Maybe<Supplier<Node>> childThunk) {
        if (originalChild.isNothing()) {
            return Maybe.empty();
        }
        List<Label> childLabels = this.nodeToLabels.get(originalChild.fromJust());
        if (childLabels == null || childLabels.isEmpty()) {
            return Maybe.of((T) childThunk.fromJust().get());
        }
        ImmutableList<Node> result = this.applyLabels(childThunk.fromJust(), ImmutableList.from(childLabels).filter(l -> !(l instanceof Bare))).toList();
        if (result.isEmpty()) {
            return Maybe.empty();
        }
        NonEmptyImmutableList<Node> nonEmptyResult = (NonEmptyImmutableList<Node>) result;
        if (nonEmptyResult.tail.isNotEmpty()) {
            throw new RuntimeException("unreachable");
        }
        return Maybe.of((T) nonEmptyResult.head);
    }

    <T extends Node> ImmutableList<Maybe<T>> applyListMaybeLabels(ImmutableList<Maybe<T>> originalChildren, ImmutableList<Maybe<Supplier<Node>>> childThunks) {
        return originalChildren.zipWith(Pair::of, childThunks).flatMap(p -> {
            if (p.left.isNothing()) {
                return ImmutableList.of(Maybe.empty());
            }
            List<Label> childLabels = this.nodeToLabels.get(p.left.fromJust());
            if (childLabels == null || childLabels.isEmpty()) {
                return ImmutableList.of(Maybe.of(p.right.fromJust().get()));
            }
            return this.applyLabels(p.right.fromJust(), ImmutableList.from(childLabels).filter(l -> !(l instanceof Bare))).toList().map(Maybe::of);
        }).map(m -> m.map(n -> (T) n));
    }

    ConcatList<Node> applyLabels(Supplier<Node> childThunk, ImmutableList<Label> remainingLabels) {
        if (remainingLabels.isEmpty()) {
            this.currentNodeMayHaveStructuredLabel = true;
            return ConcatList.of(childThunk.get());
        }
        NonEmptyImmutableList<Label> nonEmptyLabels = (NonEmptyImmutableList<Label>) remainingLabels;
        Label head = nonEmptyLabels.head;
        ImmutableList<Label> tail = nonEmptyLabels.tail;
        if (head instanceof If) {
            If label = (If) head;
            Boolean condition = this.values.conditions.get(label.condition);
            if (condition == null) {
                throw new RuntimeException("Condition " + label.condition + " not found");
            }
            if (label.inverted == condition) {
                return ConcatList.empty();
            }
            return applyLabels(childThunk, tail);
        }
        if (head instanceof Loop) {
            Loop label = (Loop) head;
            List<TemplateValues> list = this.values.lists.get(label.values);
            if (list == null) {
                throw new RuntimeException("Loop values " + label.values + " not found");
            }
            TemplateValues oldValues = this.values;
            ConcatList<Node> out = ConcatList.empty();
            for (TemplateValues perIterationTemplateValues : list) {
                this.values = oldValues.merge(perIterationTemplateValues, label.variable);
                out = out.append(applyLabels(childThunk, tail));
            }
            this.values = oldValues;
            return out;
        }
        throw new RuntimeException("unreachable");
    }

    @Override
    @Nonnull
    public Node reduceArrayAssignmentTarget(
        @Nonnull ArrayAssignmentTarget node,
        @Nonnull ImmutableList<Maybe<Supplier<Node>>> elements,
        @Nonnull Maybe<Supplier<Node>> rest
    ) {
        enforceNoStrayStructuralLabels(node);
        return applyReplacer(node, new ArrayAssignmentTarget(applyListMaybeLabels(node.elements, elements), applyMaybeLabels(node.rest, rest)));
    }

    @Override
    @Nonnull
    public Node reduceArrayBinding(
        @Nonnull ArrayBinding node,
        @Nonnull ImmutableList<Maybe<Supplier<Node>>> elements,
        @Nonnull Maybe<Supplier<Node>> rest
    ) {
        enforceNoStrayStructuralLabels(node);
        return applyReplacer(node, new ArrayBinding(applyListMaybeLabels(node.elements, elements), applyMaybeLabels(node.rest, rest)));
    }

    @Override
    @Nonnull
    public Node reduceArrayExpression(
        @Nonnull ArrayExpression node,
        @Nonnull ImmutableList<Maybe<Supplier<Node>>> elements
    ) {
        enforceNoStrayStructuralLabels(node);
        return applyReplacer(node, new ArrayExpression(applyListMaybeLabels(node.elements, elements)));
    }

    @Override
    @Nonnull
    public Node reduceArrowExpression(
        @Nonnull ArrowExpression node,
        @Nonnull Supplier<Node> params,
        @Nonnull Supplier<Node> body
    ) {
        enforceNoStrayStructuralLabels(node);
        return applyReplacer(node, new ArrowExpression((FormalParameters) params.get(), (FunctionBodyExpression) body.get()));
    }

    @Override
    @Nonnull
    public Node reduceAssignmentExpression(
        @Nonnull AssignmentExpression node,
        @Nonnull Supplier<Node> binding,
        @Nonnull Supplier<Node> expression
    ) {
        enforceNoStrayStructuralLabels(node);
        return applyReplacer(node, new AssignmentExpression((AssignmentTarget) binding.get(), (Expression) expression.get()));
    }

    @Override
    @Nonnull
    public Node reduceAssignmentTargetIdentifier(
        @Nonnull AssignmentTargetIdentifier node
    ) {
        enforceNoStrayStructuralLabels(node);
        return applyReplacer(node, new AssignmentTargetIdentifier(node.name));
    }

    @Override
    @Nonnull
    public Node reduceAssignmentTargetPropertyIdentifier(
        @Nonnull AssignmentTargetPropertyIdentifier node,
        @Nonnull Supplier<Node> binding,
        @Nonnull Maybe<Supplier<Node>> init
    ) {
        enforceNoStrayStructuralLabels(node);
        return applyReplacer(node, new AssignmentTargetPropertyIdentifier((AssignmentTargetIdentifier) binding.get(), applyMaybeLabels(node.init, init)));
    }

    @Override
    @Nonnull
    public Node reduceAssignmentTargetPropertyProperty(
        @Nonnull AssignmentTargetPropertyProperty node,
        @Nonnull Supplier<Node> name,
        @Nonnull Supplier<Node> binding
    ) {
        enforceNoStrayStructuralLabels(node);
        return applyReplacer(node, new AssignmentTargetPropertyProperty((PropertyName) name.get(), (AssignmentTargetAssignmentTargetWithDefault) binding.get()));
    }

    @Override
    @Nonnull
    public Node reduceAssignmentTargetWithDefault(
        @Nonnull AssignmentTargetWithDefault node,
        @Nonnull Supplier<Node> binding,
        @Nonnull Supplier<Node> init
    ) {
        enforceNoStrayStructuralLabels(node);
        return applyReplacer(node, new AssignmentTargetWithDefault((AssignmentTarget) binding.get(), (Expression) init.get()));
    }

    @Override
    @Nonnull
    public Node reduceBinaryExpression(
        @Nonnull BinaryExpression node,
        @Nonnull Supplier<Node> left,
        @Nonnull Supplier<Node> right
    ) {
        enforceNoStrayStructuralLabels(node);
        return applyReplacer(node, new BinaryExpression((Expression) left.get(), node.operator, (Expression) right.get()));
    }

    @Override
    @Nonnull
    public Node reduceBindingIdentifier(
        @Nonnull BindingIdentifier node
    ) {
        enforceNoStrayStructuralLabels(node);
        return applyReplacer(node, new BindingIdentifier(node.name));
    }

    @Override
    @Nonnull
    public Node reduceBindingPropertyIdentifier(
        @Nonnull BindingPropertyIdentifier node,
        @Nonnull Supplier<Node> binding,
        @Nonnull Maybe<Supplier<Node>> init
    ) {
        enforceNoStrayStructuralLabels(node);
        return applyReplacer(node, new BindingPropertyIdentifier((BindingIdentifier) binding.get(), applyMaybeLabels(node.init, init)));
    }

    @Override
    @Nonnull
    public Node reduceBindingPropertyProperty(
        @Nonnull BindingPropertyProperty node,
        @Nonnull Supplier<Node> name,
        @Nonnull Supplier<Node> binding
    ) {
        enforceNoStrayStructuralLabels(node);
        return applyReplacer(node, new BindingPropertyProperty((PropertyName) name.get(), (BindingBindingWithDefault) binding.get()));
    }

    @Override
    @Nonnull
    public Node reduceBindingWithDefault(
        @Nonnull BindingWithDefault node,
        @Nonnull Supplier<Node> binding,
        @Nonnull Supplier<Node> init
    ) {
        enforceNoStrayStructuralLabels(node);
        return applyReplacer(node, new BindingWithDefault((Binding) binding.get(), (Expression) init.get()));
    }

    @Override
    @Nonnull
    public Node reduceBlock(
        @Nonnull Block node,
        @Nonnull ImmutableList<Supplier<Node>> statements
    ) {
        enforceNoStrayStructuralLabels(node);
        return applyReplacer(node, new Block(applyListLabels(node.statements, statements)));
    }

    @Override
    @Nonnull
    public Node reduceBlockStatement(
        @Nonnull BlockStatement node,
        @Nonnull Supplier<Node> block
    ) {
        enforceNoStrayStructuralLabels(node);
        return applyReplacer(node, new BlockStatement((Block) block.get()));
    }

    @Override
    @Nonnull
    public Node reduceBreakStatement(
        @Nonnull BreakStatement node
    ) {
        enforceNoStrayStructuralLabels(node);
        return applyReplacer(node, new BreakStatement(node.label));
    }

    @Override
    @Nonnull
    public Node reduceCallExpression(
        @Nonnull CallExpression node,
        @Nonnull Supplier<Node> callee,
        @Nonnull ImmutableList<Supplier<Node>> arguments
    ) {
        enforceNoStrayStructuralLabels(node);
        return applyReplacer(node, new CallExpression((ExpressionSuper) callee.get(), applyListLabels(node.arguments, arguments)));
    }

    @Override
    @Nonnull
    public Node reduceCatchClause(
        @Nonnull CatchClause node,
        @Nonnull Supplier<Node> binding,
        @Nonnull Supplier<Node> body
    ) {
        enforceNoStrayStructuralLabels(node);
        return applyReplacer(node, new CatchClause((Binding) binding.get(), (Block) body.get()));
    }

    @Override
    @Nonnull
    public Node reduceClassDeclaration(
        @Nonnull ClassDeclaration node,
        @Nonnull Supplier<Node> name,
        @Nonnull Maybe<Supplier<Node>> _super,
        @Nonnull ImmutableList<Supplier<Node>> elements
    ) {
        enforceNoStrayStructuralLabels(node);
        return applyReplacer(node, new ClassDeclaration((BindingIdentifier) name.get(), applyMaybeLabels(node._super, _super), applyListLabels(node.elements, elements)));
    }

    @Override
    @Nonnull
    public Node reduceClassElement(
        @Nonnull ClassElement node,
        @Nonnull Supplier<Node> method
    ) {
        enforceNoStrayStructuralLabels(node);
        return applyReplacer(node, new ClassElement(node.isStatic, (MethodDefinition) method.get()));
    }

    @Override
    @Nonnull
    public Node reduceClassExpression(
        @Nonnull ClassExpression node,
        @Nonnull Maybe<Supplier<Node>> name,
        @Nonnull Maybe<Supplier<Node>> _super,
        @Nonnull ImmutableList<Supplier<Node>> elements
    ) {
        enforceNoStrayStructuralLabels(node);
        return applyReplacer(node, new ClassExpression(applyMaybeLabels(node.name, name), applyMaybeLabels(node._super, _super), applyListLabels(node.elements, elements)));
    }

    @Override
    @Nonnull
    public Node reduceCompoundAssignmentExpression(
        @Nonnull CompoundAssignmentExpression node,
        @Nonnull Supplier<Node> binding,
        @Nonnull Supplier<Node> expression
    ) {
        enforceNoStrayStructuralLabels(node);
        return applyReplacer(node, new CompoundAssignmentExpression((SimpleAssignmentTarget) binding.get(), node.operator, (Expression) expression.get()));
    }

    @Override
    @Nonnull
    public Node reduceComputedMemberAssignmentTarget(
        @Nonnull ComputedMemberAssignmentTarget node,
        @Nonnull Supplier<Node> object,
        @Nonnull Supplier<Node> expression
    ) {
        enforceNoStrayStructuralLabels(node);
        return applyReplacer(node, new ComputedMemberAssignmentTarget((ExpressionSuper) object.get(), (Expression) expression.get()));
    }

    @Override
    @Nonnull
    public Node reduceComputedMemberExpression(
        @Nonnull ComputedMemberExpression node,
        @Nonnull Supplier<Node> object,
        @Nonnull Supplier<Node> expression
    ) {
        enforceNoStrayStructuralLabels(node);
        return applyReplacer(node, new ComputedMemberExpression((ExpressionSuper) object.get(), (Expression) expression.get()));
    }

    @Override
    @Nonnull
    public Node reduceComputedPropertyName(
        @Nonnull ComputedPropertyName node,
        @Nonnull Supplier<Node> expression
    ) {
        enforceNoStrayStructuralLabels(node);
        return applyReplacer(node, new ComputedPropertyName((Expression) expression.get()));
    }

    @Override
    @Nonnull
    public Node reduceConditionalExpression(
        @Nonnull ConditionalExpression node,
        @Nonnull Supplier<Node> test,
        @Nonnull Supplier<Node> consequent,
        @Nonnull Supplier<Node> alternate
    ) {
        enforceNoStrayStructuralLabels(node);
        return applyReplacer(node, new ConditionalExpression((Expression) test.get(), (Expression) consequent.get(), (Expression) alternate.get()));
    }

    @Override
    @Nonnull
    public Node reduceContinueStatement(
        @Nonnull ContinueStatement node
    ) {
        enforceNoStrayStructuralLabels(node);
        return applyReplacer(node, new ContinueStatement(node.label));
    }

    @Override
    @Nonnull
    public Node reduceDataProperty(
        @Nonnull DataProperty node,
        @Nonnull Supplier<Node> name,
        @Nonnull Supplier<Node> expression
    ) {
        enforceNoStrayStructuralLabels(node);
        return applyReplacer(node, new DataProperty((PropertyName) name.get(), (Expression) expression.get()));
    }

    @Override
    @Nonnull
    public Node reduceDebuggerStatement(
        @Nonnull DebuggerStatement node
    ) {
        enforceNoStrayStructuralLabels(node);
        return applyReplacer(node, new DebuggerStatement());
    }

    @Override
    @Nonnull
    public Node reduceDirective(
        @Nonnull Directive node
    ) {
        enforceNoStrayStructuralLabels(node);
        return applyReplacer(node, new Directive(node.rawValue));
    }

    @Override
    @Nonnull
    public Node reduceDoWhileStatement(
        @Nonnull DoWhileStatement node,
        @Nonnull Supplier<Node> body,
        @Nonnull Supplier<Node> test
    ) {
        enforceNoStrayStructuralLabels(node);
        return applyReplacer(node, new DoWhileStatement((Statement) body.get(), (Expression) test.get()));
    }

    @Override
    @Nonnull
    public Node reduceEmptyStatement(
        @Nonnull EmptyStatement node
    ) {
        enforceNoStrayStructuralLabels(node);
        return applyReplacer(node, new EmptyStatement());
    }

    @Override
    @Nonnull
    public Node reduceExport(
        @Nonnull Export node,
        @Nonnull Supplier<Node> declaration
    ) {
        enforceNoStrayStructuralLabels(node);
        return applyReplacer(node, new Export((FunctionDeclarationClassDeclarationVariableDeclaration) declaration.get()));
    }

    @Override
    @Nonnull
    public Node reduceExportAllFrom(
        @Nonnull ExportAllFrom node
    ) {
        enforceNoStrayStructuralLabels(node);
        return applyReplacer(node, new ExportAllFrom(node.moduleSpecifier));
    }

    @Override
    @Nonnull
    public Node reduceExportDefault(
        @Nonnull ExportDefault node,
        @Nonnull Supplier<Node> body
    ) {
        enforceNoStrayStructuralLabels(node);
        return applyReplacer(node, new ExportDefault((FunctionDeclarationClassDeclarationExpression) body.get()));
    }

    @Override
    @Nonnull
    public Node reduceExportFrom(
        @Nonnull ExportFrom node,
        @Nonnull ImmutableList<Supplier<Node>> namedExports
    ) {
        enforceNoStrayStructuralLabels(node);
        return applyReplacer(node, new ExportFrom(applyListLabels(node.namedExports, namedExports), node.moduleSpecifier));
    }

    @Override
    @Nonnull
    public Node reduceExportFromSpecifier(
        @Nonnull ExportFromSpecifier node
    ) {
        enforceNoStrayStructuralLabels(node);
        return applyReplacer(node, new ExportFromSpecifier(node.name, node.exportedName));
    }

    @Override
    @Nonnull
    public Node reduceExportLocalSpecifier(
        @Nonnull ExportLocalSpecifier node,
        @Nonnull Supplier<Node> name
    ) {
        enforceNoStrayStructuralLabels(node);
        return applyReplacer(node, new ExportLocalSpecifier((IdentifierExpression) name.get(), node.exportedName));
    }

    @Override
    @Nonnull
    public Node reduceExportLocals(
        @Nonnull ExportLocals node,
        @Nonnull ImmutableList<Supplier<Node>> namedExports
    ) {
        enforceNoStrayStructuralLabels(node);
        return applyReplacer(node, new ExportLocals(applyListLabels(node.namedExports, namedExports)));
    }

    @Override
    @Nonnull
    public Node reduceExpressionStatement(
        @Nonnull ExpressionStatement node,
        @Nonnull Supplier<Node> expression
    ) {
        enforceNoStrayStructuralLabels(node);
        return applyReplacer(node, new ExpressionStatement((Expression) expression.get()));
    }

    @Override
    @Nonnull
    public Node reduceForInStatement(
        @Nonnull ForInStatement node,
        @Nonnull Supplier<Node> left,
        @Nonnull Supplier<Node> right,
        @Nonnull Supplier<Node> body
    ) {
        enforceNoStrayStructuralLabels(node);
        return applyReplacer(node, new ForInStatement((VariableDeclarationAssignmentTarget) left.get(), (Expression) right.get(), (Statement) body.get()));
    }

    @Override
    @Nonnull
    public Node reduceForOfStatement(
        @Nonnull ForOfStatement node,
        @Nonnull Supplier<Node> left,
        @Nonnull Supplier<Node> right,
        @Nonnull Supplier<Node> body
    ) {
        enforceNoStrayStructuralLabels(node);
        return applyReplacer(node, new ForOfStatement((VariableDeclarationAssignmentTarget) left.get(), (Expression) right.get(), (Statement) body.get()));
    }

    @Override
    @Nonnull
    public Node reduceForStatement(
        @Nonnull ForStatement node,
        @Nonnull Maybe<Supplier<Node>> init,
        @Nonnull Maybe<Supplier<Node>> test,
        @Nonnull Maybe<Supplier<Node>> update,
        @Nonnull Supplier<Node> body
    ) {
        enforceNoStrayStructuralLabels(node);
        return applyReplacer(node, new ForStatement(applyMaybeLabels(node.init, init), applyMaybeLabels(node.test, test), applyMaybeLabels(node.update, update), (Statement) body.get()));
    }

    @Override
    @Nonnull
    public Node reduceFormalParameters(
        @Nonnull FormalParameters node,
        @Nonnull ImmutableList<Supplier<Node>> items,
        @Nonnull Maybe<Supplier<Node>> rest
    ) {
        enforceNoStrayStructuralLabels(node);
        return applyReplacer(node, new FormalParameters(applyListLabels(node.items, items), applyMaybeLabels(node.rest, rest)));
    }

    @Override
    @Nonnull
    public Node reduceFunctionBody(
        @Nonnull FunctionBody node,
        @Nonnull ImmutableList<Supplier<Node>> directives,
        @Nonnull ImmutableList<Supplier<Node>> statements
    ) {
        enforceNoStrayStructuralLabels(node);
        return applyReplacer(node, new FunctionBody(applyListLabels(node.directives, directives), applyListLabels(node.statements, statements)));
    }

    @Override
    @Nonnull
    public Node reduceFunctionDeclaration(
        @Nonnull FunctionDeclaration node,
        @Nonnull Supplier<Node> name,
        @Nonnull Supplier<Node> params,
        @Nonnull Supplier<Node> body
    ) {
        enforceNoStrayStructuralLabels(node);
        return applyReplacer(node, new FunctionDeclaration(node.isGenerator, (BindingIdentifier) name.get(), (FormalParameters) params.get(), (FunctionBody) body.get()));
    }

    @Override
    @Nonnull
    public Node reduceFunctionExpression(
        @Nonnull FunctionExpression node,
        @Nonnull Maybe<Supplier<Node>> name,
        @Nonnull Supplier<Node> params,
        @Nonnull Supplier<Node> body
    ) {
        enforceNoStrayStructuralLabels(node);
        return applyReplacer(node, new FunctionExpression(node.isGenerator, applyMaybeLabels(node.name, name), (FormalParameters) params.get(), (FunctionBody) body.get()));
    }

    @Override
    @Nonnull
    public Node reduceGetter(
        @Nonnull Getter node,
        @Nonnull Supplier<Node> name,
        @Nonnull Supplier<Node> body
    ) {
        enforceNoStrayStructuralLabels(node);
        return applyReplacer(node, new Getter((PropertyName) name.get(), (FunctionBody) body.get()));
    }

    @Override
    @Nonnull
    public Node reduceIdentifierExpression(
        @Nonnull IdentifierExpression node
    ) {
        enforceNoStrayStructuralLabels(node);
        return applyReplacer(node, new IdentifierExpression(node.name));
    }

    @Override
    @Nonnull
    public Node reduceIfStatement(
        @Nonnull IfStatement node,
        @Nonnull Supplier<Node> test,
        @Nonnull Supplier<Node> consequent,
        @Nonnull Maybe<Supplier<Node>> alternate
    ) {
        enforceNoStrayStructuralLabels(node);
        return applyReplacer(node, new IfStatement((Expression) test.get(), (Statement) consequent.get(), applyMaybeLabels(node.alternate, alternate)));
    }

    @Override
    @Nonnull
    public Node reduceImport(
        @Nonnull Import node,
        @Nonnull Maybe<Supplier<Node>> defaultBinding,
        @Nonnull ImmutableList<Supplier<Node>> namedImports
    ) {
        enforceNoStrayStructuralLabels(node);
        return applyReplacer(node, new Import(applyMaybeLabels(node.defaultBinding, defaultBinding), applyListLabels(node.namedImports, namedImports), node.moduleSpecifier));
    }

    @Override
    @Nonnull
    public Node reduceImportNamespace(
        @Nonnull ImportNamespace node,
        @Nonnull Maybe<Supplier<Node>> defaultBinding,
        @Nonnull Supplier<Node> namespaceBinding
    ) {
        enforceNoStrayStructuralLabels(node);
        return applyReplacer(node, new ImportNamespace(applyMaybeLabels(node.defaultBinding, defaultBinding), (BindingIdentifier) namespaceBinding.get(), node.moduleSpecifier));
    }

    @Override
    @Nonnull
    public Node reduceImportSpecifier(
        @Nonnull ImportSpecifier node,
        @Nonnull Supplier<Node> binding
    ) {
        enforceNoStrayStructuralLabels(node);
        return applyReplacer(node, new ImportSpecifier(node.name, (BindingIdentifier) binding.get()));
    }

    @Override
    @Nonnull
    public Node reduceLabeledStatement(
        @Nonnull LabeledStatement node,
        @Nonnull Supplier<Node> body
    ) {
        enforceNoStrayStructuralLabels(node);
        return applyReplacer(node, new LabeledStatement(node.label, (Statement) body.get()));
    }

    @Override
    @Nonnull
    public Node reduceLiteralBooleanExpression(
        @Nonnull LiteralBooleanExpression node
    ) {
        enforceNoStrayStructuralLabels(node);
        return applyReplacer(node, new LiteralBooleanExpression(node.value));
    }

    @Override
    @Nonnull
    public Node reduceLiteralInfinityExpression(
        @Nonnull LiteralInfinityExpression node
    ) {
        enforceNoStrayStructuralLabels(node);
        return applyReplacer(node, new LiteralInfinityExpression());
    }

    @Override
    @Nonnull
    public Node reduceLiteralNullExpression(
        @Nonnull LiteralNullExpression node
    ) {
        enforceNoStrayStructuralLabels(node);
        return applyReplacer(node, new LiteralNullExpression());
    }

    @Override
    @Nonnull
    public Node reduceLiteralNumericExpression(
        @Nonnull LiteralNumericExpression node
    ) {
        enforceNoStrayStructuralLabels(node);
        return applyReplacer(node, new LiteralNumericExpression(node.value));
    }

    @Override
    @Nonnull
    public Node reduceLiteralRegExpExpression(
        @Nonnull LiteralRegExpExpression node
    ) {
        enforceNoStrayStructuralLabels(node);
        return applyReplacer(node, new LiteralRegExpExpression(node.pattern, node.global, node.ignoreCase, node.multiLine, node.sticky, node.unicode));
    }

    @Override
    @Nonnull
    public Node reduceLiteralStringExpression(
        @Nonnull LiteralStringExpression node
    ) {
        enforceNoStrayStructuralLabels(node);
        return applyReplacer(node, new LiteralStringExpression(node.value));
    }

    @Override
    @Nonnull
    public Node reduceMethod(
        @Nonnull Method node,
        @Nonnull Supplier<Node> name,
        @Nonnull Supplier<Node> params,
        @Nonnull Supplier<Node> body
    ) {
        enforceNoStrayStructuralLabels(node);
        return applyReplacer(node, new Method(node.isGenerator, (PropertyName) name.get(), (FormalParameters) params.get(), (FunctionBody) body.get()));
    }

    @Override
    @Nonnull
    public Node reduceModule(
        @Nonnull Module node,
        @Nonnull ImmutableList<Supplier<Node>> directives,
        @Nonnull ImmutableList<Supplier<Node>> items
    ) {
        enforceNoStrayStructuralLabels(node);
        return applyReplacer(node, new Module(applyListLabels(node.directives, directives), applyListLabels(node.items, items)));
    }

    @Override
    @Nonnull
    public Node reduceNewExpression(
        @Nonnull NewExpression node,
        @Nonnull Supplier<Node> callee,
        @Nonnull ImmutableList<Supplier<Node>> arguments
    ) {
        enforceNoStrayStructuralLabels(node);
        return applyReplacer(node, new NewExpression((Expression) callee.get(), applyListLabels(node.arguments, arguments)));
    }

    @Override
    @Nonnull
    public Node reduceNewTargetExpression(
        @Nonnull NewTargetExpression node
    ) {
        enforceNoStrayStructuralLabels(node);
        return applyReplacer(node, new NewTargetExpression());
    }

    @Override
    @Nonnull
    public Node reduceObjectAssignmentTarget(
        @Nonnull ObjectAssignmentTarget node,
        @Nonnull ImmutableList<Supplier<Node>> properties
    ) {
        enforceNoStrayStructuralLabels(node);
        return applyReplacer(node, new ObjectAssignmentTarget(applyListLabels(node.properties, properties)));
    }

    @Override
    @Nonnull
    public Node reduceObjectBinding(
        @Nonnull ObjectBinding node,
        @Nonnull ImmutableList<Supplier<Node>> properties
    ) {
        enforceNoStrayStructuralLabels(node);
        return applyReplacer(node, new ObjectBinding(applyListLabels(node.properties, properties)));
    }

    @Override
    @Nonnull
    public Node reduceObjectExpression(
        @Nonnull ObjectExpression node,
        @Nonnull ImmutableList<Supplier<Node>> properties
    ) {
        enforceNoStrayStructuralLabels(node);
        return applyReplacer(node, new ObjectExpression(applyListLabels(node.properties, properties)));
    }

    @Override
    @Nonnull
    public Node reduceReturnStatement(
        @Nonnull ReturnStatement node,
        @Nonnull Maybe<Supplier<Node>> expression
    ) {
        enforceNoStrayStructuralLabels(node);
        return applyReplacer(node, new ReturnStatement(applyMaybeLabels(node.expression, expression)));
    }

    @Override
    @Nonnull
    public Node reduceScript(
        @Nonnull Script node,
        @Nonnull ImmutableList<Supplier<Node>> directives,
        @Nonnull ImmutableList<Supplier<Node>> statements
    ) {
        enforceNoStrayStructuralLabels(node);
        return applyReplacer(node, new Script(applyListLabels(node.directives, directives), applyListLabels(node.statements, statements)));
    }

    @Override
    @Nonnull
    public Node reduceSetter(
        @Nonnull Setter node,
        @Nonnull Supplier<Node> name,
        @Nonnull Supplier<Node> param,
        @Nonnull Supplier<Node> body
    ) {
        enforceNoStrayStructuralLabels(node);
        return applyReplacer(node, new Setter((PropertyName) name.get(), (Parameter) param.get(), (FunctionBody) body.get()));
    }

    @Override
    @Nonnull
    public Node reduceShorthandProperty(
        @Nonnull ShorthandProperty node,
        @Nonnull Supplier<Node> name
    ) {
        enforceNoStrayStructuralLabels(node);
        return applyReplacer(node, new ShorthandProperty((IdentifierExpression) name.get()));
    }

    @Override
    @Nonnull
    public Node reduceSpreadElement(
        @Nonnull SpreadElement node,
        @Nonnull Supplier<Node> expression
    ) {
        enforceNoStrayStructuralLabels(node);
        return applyReplacer(node, new SpreadElement((Expression) expression.get()));
    }

    @Override
    @Nonnull
    public Node reduceStaticMemberAssignmentTarget(
        @Nonnull StaticMemberAssignmentTarget node,
        @Nonnull Supplier<Node> object
    ) {
        enforceNoStrayStructuralLabels(node);
        return applyReplacer(node, new StaticMemberAssignmentTarget((ExpressionSuper) object.get(), node.property));
    }

    @Override
    @Nonnull
    public Node reduceStaticMemberExpression(
        @Nonnull StaticMemberExpression node,
        @Nonnull Supplier<Node> object
    ) {
        enforceNoStrayStructuralLabels(node);
        return applyReplacer(node, new StaticMemberExpression((ExpressionSuper) object.get(), node.property));
    }

    @Override
    @Nonnull
    public Node reduceStaticPropertyName(
        @Nonnull StaticPropertyName node
    ) {
        enforceNoStrayStructuralLabels(node);
        return applyReplacer(node, new StaticPropertyName(node.value));
    }

    @Override
    @Nonnull
    public Node reduceSuper(
        @Nonnull Super node
    ) {
        enforceNoStrayStructuralLabels(node);
        return applyReplacer(node, new Super());
    }

    @Override
    @Nonnull
    public Node reduceSwitchCase(
        @Nonnull SwitchCase node,
        @Nonnull Supplier<Node> test,
        @Nonnull ImmutableList<Supplier<Node>> consequent
    ) {
        enforceNoStrayStructuralLabels(node);
        return applyReplacer(node, new SwitchCase((Expression) test.get(), applyListLabels(node.consequent, consequent)));
    }

    @Override
    @Nonnull
    public Node reduceSwitchDefault(
        @Nonnull SwitchDefault node,
        @Nonnull ImmutableList<Supplier<Node>> consequent
    ) {
        enforceNoStrayStructuralLabels(node);
        return applyReplacer(node, new SwitchDefault(applyListLabels(node.consequent, consequent)));
    }

    @Override
    @Nonnull
    public Node reduceSwitchStatement(
        @Nonnull SwitchStatement node,
        @Nonnull Supplier<Node> discriminant,
        @Nonnull ImmutableList<Supplier<Node>> cases
    ) {
        enforceNoStrayStructuralLabels(node);
        return applyReplacer(node, new SwitchStatement((Expression) discriminant.get(), applyListLabels(node.cases, cases)));
    }

    @Override
    @Nonnull
    public Node reduceSwitchStatementWithDefault(
        @Nonnull SwitchStatementWithDefault node,
        @Nonnull Supplier<Node> discriminant,
        @Nonnull ImmutableList<Supplier<Node>> preDefaultCases,
        @Nonnull Supplier<Node> defaultCase,
        @Nonnull ImmutableList<Supplier<Node>> postDefaultCases
    ) {
        enforceNoStrayStructuralLabels(node);
        return applyReplacer(node, new SwitchStatementWithDefault((Expression) discriminant.get(), applyListLabels(node.preDefaultCases, preDefaultCases), (SwitchDefault) defaultCase.get(), applyListLabels(node.postDefaultCases, postDefaultCases)));
    }

    @Override
    @Nonnull
    public Node reduceTemplateElement(
        @Nonnull TemplateElement node
    ) {
        enforceNoStrayStructuralLabels(node);
        return applyReplacer(node, new TemplateElement(node.rawValue));
    }

    @Override
    @Nonnull
    public Node reduceTemplateExpression(
        @Nonnull TemplateExpression node,
        @Nonnull Maybe<Supplier<Node>> tag,
        @Nonnull ImmutableList<Supplier<Node>> elements
    ) {
        enforceNoStrayStructuralLabels(node);
        return applyReplacer(node, new TemplateExpression(applyMaybeLabels(node.tag, tag), applyListLabels(node.elements, elements)));
    }

    @Override
    @Nonnull
    public Node reduceThisExpression(
        @Nonnull ThisExpression node
    ) {
        enforceNoStrayStructuralLabels(node);
        return applyReplacer(node, new ThisExpression());
    }

    @Override
    @Nonnull
    public Node reduceThrowStatement(
        @Nonnull ThrowStatement node,
        @Nonnull Supplier<Node> expression
    ) {
        enforceNoStrayStructuralLabels(node);
        return applyReplacer(node, new ThrowStatement((Expression) expression.get()));
    }

    @Override
    @Nonnull
    public Node reduceTryCatchStatement(
        @Nonnull TryCatchStatement node,
        @Nonnull Supplier<Node> body,
        @Nonnull Supplier<Node> catchClause
    ) {
        enforceNoStrayStructuralLabels(node);
        return applyReplacer(node, new TryCatchStatement((Block) body.get(), (CatchClause) catchClause.get()));
    }

    @Override
    @Nonnull
    public Node reduceTryFinallyStatement(
        @Nonnull TryFinallyStatement node,
        @Nonnull Supplier<Node> body,
        @Nonnull Maybe<Supplier<Node>> catchClause,
        @Nonnull Supplier<Node> finalizer
    ) {
        enforceNoStrayStructuralLabels(node);
        return applyReplacer(node, new TryFinallyStatement((Block) body.get(), applyMaybeLabels(node.catchClause, catchClause), (Block) finalizer.get()));
    }

    @Override
    @Nonnull
    public Node reduceUnaryExpression(
        @Nonnull UnaryExpression node,
        @Nonnull Supplier<Node> operand
    ) {
        enforceNoStrayStructuralLabels(node);
        return applyReplacer(node, new UnaryExpression(node.operator, (Expression) operand.get()));
    }

    @Override
    @Nonnull
    public Node reduceUpdateExpression(
        @Nonnull UpdateExpression node,
        @Nonnull Supplier<Node> operand
    ) {
        enforceNoStrayStructuralLabels(node);
        return applyReplacer(node, new UpdateExpression(node.isPrefix, node.operator, (SimpleAssignmentTarget) operand.get()));
    }

    @Override
    @Nonnull
    public Node reduceVariableDeclaration(
        @Nonnull VariableDeclaration node,
        @Nonnull ImmutableList<Supplier<Node>> declarators
    ) {
        enforceNoStrayStructuralLabels(node);
        return applyReplacer(node, new VariableDeclaration(node.kind, applyListLabels(node.declarators, declarators)));
    }

    @Override
    @Nonnull
    public Node reduceVariableDeclarationStatement(
        @Nonnull VariableDeclarationStatement node,
        @Nonnull Supplier<Node> declaration
    ) {
        enforceNoStrayStructuralLabels(node);
        return applyReplacer(node, new VariableDeclarationStatement((VariableDeclaration) declaration.get()));
    }

    @Override
    @Nonnull
    public Node reduceVariableDeclarator(
        @Nonnull VariableDeclarator node,
        @Nonnull Supplier<Node> binding,
        @Nonnull Maybe<Supplier<Node>> init
    ) {
        enforceNoStrayStructuralLabels(node);
        return applyReplacer(node, new VariableDeclarator((Binding) binding.get(), applyMaybeLabels(node.init, init)));
    }

    @Override
    @Nonnull
    public Node reduceWhileStatement(
        @Nonnull WhileStatement node,
        @Nonnull Supplier<Node> test,
        @Nonnull Supplier<Node> body
    ) {
        enforceNoStrayStructuralLabels(node);
        return applyReplacer(node, new WhileStatement((Expression) test.get(), (Statement) body.get()));
    }

    @Override
    @Nonnull
    public Node reduceWithStatement(
        @Nonnull WithStatement node,
        @Nonnull Supplier<Node> object,
        @Nonnull Supplier<Node> body
    ) {
        enforceNoStrayStructuralLabels(node);
        return applyReplacer(node, new WithStatement((Expression) object.get(), (Statement) body.get()));
    }

    @Override
    @Nonnull
    public Node reduceYieldExpression(
        @Nonnull YieldExpression node,
        @Nonnull Maybe<Supplier<Node>> expression
    ) {
        enforceNoStrayStructuralLabels(node);
        return applyReplacer(node, new YieldExpression(applyMaybeLabels(node.expression, expression)));
    }

    @Override
    @Nonnull
    public Node reduceYieldGeneratorExpression(
        @Nonnull YieldGeneratorExpression node,
        @Nonnull Supplier<Node> expression
    ) {
        enforceNoStrayStructuralLabels(node);
        return applyReplacer(node, new YieldGeneratorExpression((Expression) expression.get()));
    }

}
