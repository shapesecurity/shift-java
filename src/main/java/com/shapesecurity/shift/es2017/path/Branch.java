// Generated by branch.js
/**
 * Copyright 2018 Shape Security, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


package com.shapesecurity.shift.es2017.path;


import com.shapesecurity.functional.data.Maybe;
import com.shapesecurity.shift.es2017.ast.*;
import com.shapesecurity.shift.es2017.ast.Module;

import javax.annotation.Nonnull;
import java.util.Objects;


public abstract class Branch {
	@Nonnull
	abstract public Maybe<? extends Node> step(Node node);

	abstract public String propertyName();

	@Override
	public boolean equals(Object o) {
		if (this == o) return true;
		return o != null && getClass() == o.getClass();
	}

	@Override
	public int hashCode() {
		return Objects.hash(getClass());
	}

	public static ArrayAssignmentTargetElements ArrayAssignmentTargetElements_(int index) {
		return new ArrayAssignmentTargetElements(index);
	}

	public static ArrayAssignmentTargetRest ArrayAssignmentTargetRest_() {
		return new ArrayAssignmentTargetRest();
	}

	public static ArrayBindingElements ArrayBindingElements_(int index) {
		return new ArrayBindingElements(index);
	}

	public static ArrayBindingRest ArrayBindingRest_() {
		return new ArrayBindingRest();
	}

	public static ArrayExpressionElements ArrayExpressionElements_(int index) {
		return new ArrayExpressionElements(index);
	}

	public static ArrowExpressionParams ArrowExpressionParams_() {
		return new ArrowExpressionParams();
	}

	public static ArrowExpressionBody ArrowExpressionBody_() {
		return new ArrowExpressionBody();
	}

	public static AssignmentExpressionBinding AssignmentExpressionBinding_() {
		return new AssignmentExpressionBinding();
	}

	public static AssignmentExpressionExpression AssignmentExpressionExpression_() {
		return new AssignmentExpressionExpression();
	}

	public static AssignmentTargetPropertyIdentifierBinding AssignmentTargetPropertyIdentifierBinding_() {
		return new AssignmentTargetPropertyIdentifierBinding();
	}

	public static AssignmentTargetPropertyIdentifierInit AssignmentTargetPropertyIdentifierInit_() {
		return new AssignmentTargetPropertyIdentifierInit();
	}

	public static AssignmentTargetPropertyPropertyName AssignmentTargetPropertyPropertyName_() {
		return new AssignmentTargetPropertyPropertyName();
	}

	public static AssignmentTargetPropertyPropertyBinding AssignmentTargetPropertyPropertyBinding_() {
		return new AssignmentTargetPropertyPropertyBinding();
	}

	public static AssignmentTargetWithDefaultBinding AssignmentTargetWithDefaultBinding_() {
		return new AssignmentTargetWithDefaultBinding();
	}

	public static AssignmentTargetWithDefaultInit AssignmentTargetWithDefaultInit_() {
		return new AssignmentTargetWithDefaultInit();
	}

	public static AwaitExpressionExpression AwaitExpressionExpression_() {
		return new AwaitExpressionExpression();
	}

	public static BinaryExpressionLeft BinaryExpressionLeft_() {
		return new BinaryExpressionLeft();
	}

	public static BinaryExpressionRight BinaryExpressionRight_() {
		return new BinaryExpressionRight();
	}

	public static BindingPropertyIdentifierBinding BindingPropertyIdentifierBinding_() {
		return new BindingPropertyIdentifierBinding();
	}

	public static BindingPropertyIdentifierInit BindingPropertyIdentifierInit_() {
		return new BindingPropertyIdentifierInit();
	}

	public static BindingPropertyPropertyName BindingPropertyPropertyName_() {
		return new BindingPropertyPropertyName();
	}

	public static BindingPropertyPropertyBinding BindingPropertyPropertyBinding_() {
		return new BindingPropertyPropertyBinding();
	}

	public static BindingWithDefaultBinding BindingWithDefaultBinding_() {
		return new BindingWithDefaultBinding();
	}

	public static BindingWithDefaultInit BindingWithDefaultInit_() {
		return new BindingWithDefaultInit();
	}

	public static BlockStatements BlockStatements_(int index) {
		return new BlockStatements(index);
	}

	public static BlockStatementBlock BlockStatementBlock_() {
		return new BlockStatementBlock();
	}

	public static CallExpressionCallee CallExpressionCallee_() {
		return new CallExpressionCallee();
	}

	public static CallExpressionArguments CallExpressionArguments_(int index) {
		return new CallExpressionArguments(index);
	}

	public static CatchClauseBinding CatchClauseBinding_() {
		return new CatchClauseBinding();
	}

	public static CatchClauseBody CatchClauseBody_() {
		return new CatchClauseBody();
	}

	public static ClassDeclarationName ClassDeclarationName_() {
		return new ClassDeclarationName();
	}

	public static ClassDeclarationSuper ClassDeclarationSuper_() {
		return new ClassDeclarationSuper();
	}

	public static ClassDeclarationElements ClassDeclarationElements_(int index) {
		return new ClassDeclarationElements(index);
	}

	public static ClassElementMethod ClassElementMethod_() {
		return new ClassElementMethod();
	}

	public static ClassExpressionName ClassExpressionName_() {
		return new ClassExpressionName();
	}

	public static ClassExpressionSuper ClassExpressionSuper_() {
		return new ClassExpressionSuper();
	}

	public static ClassExpressionElements ClassExpressionElements_(int index) {
		return new ClassExpressionElements(index);
	}

	public static CompoundAssignmentExpressionBinding CompoundAssignmentExpressionBinding_() {
		return new CompoundAssignmentExpressionBinding();
	}

	public static CompoundAssignmentExpressionExpression CompoundAssignmentExpressionExpression_() {
		return new CompoundAssignmentExpressionExpression();
	}

	public static ComputedMemberAssignmentTargetObject ComputedMemberAssignmentTargetObject_() {
		return new ComputedMemberAssignmentTargetObject();
	}

	public static ComputedMemberAssignmentTargetExpression ComputedMemberAssignmentTargetExpression_() {
		return new ComputedMemberAssignmentTargetExpression();
	}

	public static ComputedMemberExpressionObject ComputedMemberExpressionObject_() {
		return new ComputedMemberExpressionObject();
	}

	public static ComputedMemberExpressionExpression ComputedMemberExpressionExpression_() {
		return new ComputedMemberExpressionExpression();
	}

	public static ComputedPropertyNameExpression ComputedPropertyNameExpression_() {
		return new ComputedPropertyNameExpression();
	}

	public static ConditionalExpressionTest ConditionalExpressionTest_() {
		return new ConditionalExpressionTest();
	}

	public static ConditionalExpressionConsequent ConditionalExpressionConsequent_() {
		return new ConditionalExpressionConsequent();
	}

	public static ConditionalExpressionAlternate ConditionalExpressionAlternate_() {
		return new ConditionalExpressionAlternate();
	}

	public static DataPropertyName DataPropertyName_() {
		return new DataPropertyName();
	}

	public static DataPropertyExpression DataPropertyExpression_() {
		return new DataPropertyExpression();
	}

	public static DoWhileStatementBody DoWhileStatementBody_() {
		return new DoWhileStatementBody();
	}

	public static DoWhileStatementTest DoWhileStatementTest_() {
		return new DoWhileStatementTest();
	}

	public static ExportDeclaration ExportDeclaration_() {
		return new ExportDeclaration();
	}

	public static ExportDefaultBody ExportDefaultBody_() {
		return new ExportDefaultBody();
	}

	public static ExportFromNamedExports ExportFromNamedExports_(int index) {
		return new ExportFromNamedExports(index);
	}

	public static ExportLocalSpecifierName ExportLocalSpecifierName_() {
		return new ExportLocalSpecifierName();
	}

	public static ExportLocalsNamedExports ExportLocalsNamedExports_(int index) {
		return new ExportLocalsNamedExports(index);
	}

	public static ExpressionStatementExpression ExpressionStatementExpression_() {
		return new ExpressionStatementExpression();
	}

	public static ForInStatementLeft ForInStatementLeft_() {
		return new ForInStatementLeft();
	}

	public static ForInStatementRight ForInStatementRight_() {
		return new ForInStatementRight();
	}

	public static ForInStatementBody ForInStatementBody_() {
		return new ForInStatementBody();
	}

	public static ForOfStatementLeft ForOfStatementLeft_() {
		return new ForOfStatementLeft();
	}

	public static ForOfStatementRight ForOfStatementRight_() {
		return new ForOfStatementRight();
	}

	public static ForOfStatementBody ForOfStatementBody_() {
		return new ForOfStatementBody();
	}

	public static ForStatementInit ForStatementInit_() {
		return new ForStatementInit();
	}

	public static ForStatementTest ForStatementTest_() {
		return new ForStatementTest();
	}

	public static ForStatementUpdate ForStatementUpdate_() {
		return new ForStatementUpdate();
	}

	public static ForStatementBody ForStatementBody_() {
		return new ForStatementBody();
	}

	public static FormalParametersItems FormalParametersItems_(int index) {
		return new FormalParametersItems(index);
	}

	public static FormalParametersRest FormalParametersRest_() {
		return new FormalParametersRest();
	}

	public static FunctionBodyDirectives FunctionBodyDirectives_(int index) {
		return new FunctionBodyDirectives(index);
	}

	public static FunctionBodyStatements FunctionBodyStatements_(int index) {
		return new FunctionBodyStatements(index);
	}

	public static FunctionDeclarationName FunctionDeclarationName_() {
		return new FunctionDeclarationName();
	}

	public static FunctionDeclarationParams FunctionDeclarationParams_() {
		return new FunctionDeclarationParams();
	}

	public static FunctionDeclarationBody FunctionDeclarationBody_() {
		return new FunctionDeclarationBody();
	}

	public static FunctionExpressionName FunctionExpressionName_() {
		return new FunctionExpressionName();
	}

	public static FunctionExpressionParams FunctionExpressionParams_() {
		return new FunctionExpressionParams();
	}

	public static FunctionExpressionBody FunctionExpressionBody_() {
		return new FunctionExpressionBody();
	}

	public static GetterName GetterName_() {
		return new GetterName();
	}

	public static GetterBody GetterBody_() {
		return new GetterBody();
	}

	public static IfStatementTest IfStatementTest_() {
		return new IfStatementTest();
	}

	public static IfStatementConsequent IfStatementConsequent_() {
		return new IfStatementConsequent();
	}

	public static IfStatementAlternate IfStatementAlternate_() {
		return new IfStatementAlternate();
	}

	public static ImportDefaultBinding ImportDefaultBinding_() {
		return new ImportDefaultBinding();
	}

	public static ImportNamedImports ImportNamedImports_(int index) {
		return new ImportNamedImports(index);
	}

	public static ImportNamespaceDefaultBinding ImportNamespaceDefaultBinding_() {
		return new ImportNamespaceDefaultBinding();
	}

	public static ImportNamespaceNamespaceBinding ImportNamespaceNamespaceBinding_() {
		return new ImportNamespaceNamespaceBinding();
	}

	public static ImportSpecifierBinding ImportSpecifierBinding_() {
		return new ImportSpecifierBinding();
	}

	public static LabeledStatementBody LabeledStatementBody_() {
		return new LabeledStatementBody();
	}

	public static MethodName MethodName_() {
		return new MethodName();
	}

	public static MethodParams MethodParams_() {
		return new MethodParams();
	}

	public static MethodBody MethodBody_() {
		return new MethodBody();
	}

	public static ModuleDirectives ModuleDirectives_(int index) {
		return new ModuleDirectives(index);
	}

	public static ModuleItems ModuleItems_(int index) {
		return new ModuleItems(index);
	}

	public static NewExpressionCallee NewExpressionCallee_() {
		return new NewExpressionCallee();
	}

	public static NewExpressionArguments NewExpressionArguments_(int index) {
		return new NewExpressionArguments(index);
	}

	public static ObjectAssignmentTargetProperties ObjectAssignmentTargetProperties_(int index) {
		return new ObjectAssignmentTargetProperties(index);
	}

	public static ObjectBindingProperties ObjectBindingProperties_(int index) {
		return new ObjectBindingProperties(index);
	}

	public static ObjectExpressionProperties ObjectExpressionProperties_(int index) {
		return new ObjectExpressionProperties(index);
	}

	public static ReturnStatementExpression ReturnStatementExpression_() {
		return new ReturnStatementExpression();
	}

	public static ScriptDirectives ScriptDirectives_(int index) {
		return new ScriptDirectives(index);
	}

	public static ScriptStatements ScriptStatements_(int index) {
		return new ScriptStatements(index);
	}

	public static SetterName SetterName_() {
		return new SetterName();
	}

	public static SetterParam SetterParam_() {
		return new SetterParam();
	}

	public static SetterBody SetterBody_() {
		return new SetterBody();
	}

	public static ShorthandPropertyName ShorthandPropertyName_() {
		return new ShorthandPropertyName();
	}

	public static SpreadElementExpression SpreadElementExpression_() {
		return new SpreadElementExpression();
	}

	public static StaticMemberAssignmentTargetObject StaticMemberAssignmentTargetObject_() {
		return new StaticMemberAssignmentTargetObject();
	}

	public static StaticMemberExpressionObject StaticMemberExpressionObject_() {
		return new StaticMemberExpressionObject();
	}

	public static SwitchCaseTest SwitchCaseTest_() {
		return new SwitchCaseTest();
	}

	public static SwitchCaseConsequent SwitchCaseConsequent_(int index) {
		return new SwitchCaseConsequent(index);
	}

	public static SwitchDefaultConsequent SwitchDefaultConsequent_(int index) {
		return new SwitchDefaultConsequent(index);
	}

	public static SwitchStatementDiscriminant SwitchStatementDiscriminant_() {
		return new SwitchStatementDiscriminant();
	}

	public static SwitchStatementCases SwitchStatementCases_(int index) {
		return new SwitchStatementCases(index);
	}

	public static SwitchStatementWithDefaultDiscriminant SwitchStatementWithDefaultDiscriminant_() {
		return new SwitchStatementWithDefaultDiscriminant();
	}

	public static SwitchStatementWithDefaultPreDefaultCases SwitchStatementWithDefaultPreDefaultCases_(int index) {
		return new SwitchStatementWithDefaultPreDefaultCases(index);
	}

	public static SwitchStatementWithDefaultDefaultCase SwitchStatementWithDefaultDefaultCase_() {
		return new SwitchStatementWithDefaultDefaultCase();
	}

	public static SwitchStatementWithDefaultPostDefaultCases SwitchStatementWithDefaultPostDefaultCases_(int index) {
		return new SwitchStatementWithDefaultPostDefaultCases(index);
	}

	public static TemplateExpressionTag TemplateExpressionTag_() {
		return new TemplateExpressionTag();
	}

	public static TemplateExpressionElements TemplateExpressionElements_(int index) {
		return new TemplateExpressionElements(index);
	}

	public static ThrowStatementExpression ThrowStatementExpression_() {
		return new ThrowStatementExpression();
	}

	public static TryCatchStatementBody TryCatchStatementBody_() {
		return new TryCatchStatementBody();
	}

	public static TryCatchStatementCatchClause TryCatchStatementCatchClause_() {
		return new TryCatchStatementCatchClause();
	}

	public static TryFinallyStatementBody TryFinallyStatementBody_() {
		return new TryFinallyStatementBody();
	}

	public static TryFinallyStatementCatchClause TryFinallyStatementCatchClause_() {
		return new TryFinallyStatementCatchClause();
	}

	public static TryFinallyStatementFinalizer TryFinallyStatementFinalizer_() {
		return new TryFinallyStatementFinalizer();
	}

	public static UnaryExpressionOperand UnaryExpressionOperand_() {
		return new UnaryExpressionOperand();
	}

	public static UpdateExpressionOperand UpdateExpressionOperand_() {
		return new UpdateExpressionOperand();
	}

	public static VariableDeclarationDeclarators VariableDeclarationDeclarators_(int index) {
		return new VariableDeclarationDeclarators(index);
	}

	public static VariableDeclarationStatementDeclaration VariableDeclarationStatementDeclaration_() {
		return new VariableDeclarationStatementDeclaration();
	}

	public static VariableDeclaratorBinding VariableDeclaratorBinding_() {
		return new VariableDeclaratorBinding();
	}

	public static VariableDeclaratorInit VariableDeclaratorInit_() {
		return new VariableDeclaratorInit();
	}

	public static WhileStatementTest WhileStatementTest_() {
		return new WhileStatementTest();
	}

	public static WhileStatementBody WhileStatementBody_() {
		return new WhileStatementBody();
	}

	public static WithStatementObject WithStatementObject_() {
		return new WithStatementObject();
	}

	public static WithStatementBody WithStatementBody_() {
		return new WithStatementBody();
	}

	public static YieldExpressionExpression YieldExpressionExpression_() {
		return new YieldExpressionExpression();
	}

	public static YieldGeneratorExpressionExpression YieldGeneratorExpressionExpression_() {
		return new YieldGeneratorExpressionExpression();
	}

}

abstract class IndexedBranch extends Branch {
	public final int index;

	protected IndexedBranch(int index) {
		this.index = index;
	}

	@Override
	public boolean equals(Object o) {
		if (this == o) return true;
		if (o == null || getClass() != o.getClass()) return false;
		IndexedBranch that = (IndexedBranch) o;
		return index == that.index;
	}

	@Override
	public int hashCode() {
		return Objects.hash(getClass(), index);
	}
}


class ArrayAssignmentTargetElements extends IndexedBranch {
	protected ArrayAssignmentTargetElements(int index) {
		super(index);
	}

	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof ArrayAssignmentTarget)) return Maybe.empty();
		return ((ArrayAssignmentTarget) node).elements.index(index).orJust(Maybe.empty());
	}

	public String propertyName() {
		return "elements[" + Integer.toString(index) + "]";
	}
}

class ArrayAssignmentTargetRest extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof ArrayAssignmentTarget)) return Maybe.empty();
		return ((ArrayAssignmentTarget) node).rest;
	}

	public String propertyName() {
		return "rest";
	}
}

class ArrayBindingElements extends IndexedBranch {
	protected ArrayBindingElements(int index) {
		super(index);
	}

	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof ArrayBinding)) return Maybe.empty();
		return ((ArrayBinding) node).elements.index(index).orJust(Maybe.empty());
	}

	public String propertyName() {
		return "elements[" + Integer.toString(index) + "]";
	}
}

class ArrayBindingRest extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof ArrayBinding)) return Maybe.empty();
		return ((ArrayBinding) node).rest;
	}

	public String propertyName() {
		return "rest";
	}
}

class ArrayExpressionElements extends IndexedBranch {
	protected ArrayExpressionElements(int index) {
		super(index);
	}

	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof ArrayExpression)) return Maybe.empty();
		return ((ArrayExpression) node).elements.index(index).orJust(Maybe.empty());
	}

	public String propertyName() {
		return "elements[" + Integer.toString(index) + "]";
	}
}

class ArrowExpressionParams extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof ArrowExpression)) return Maybe.empty();
		return Maybe.of(((ArrowExpression) node).params);
	}

	public String propertyName() {
		return "params";
	}
}

class ArrowExpressionBody extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof ArrowExpression)) return Maybe.empty();
		return Maybe.of(((ArrowExpression) node).body);
	}

	public String propertyName() {
		return "body";
	}
}

class AssignmentExpressionBinding extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof AssignmentExpression)) return Maybe.empty();
		return Maybe.of(((AssignmentExpression) node).binding);
	}

	public String propertyName() {
		return "binding";
	}
}

class AssignmentExpressionExpression extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof AssignmentExpression)) return Maybe.empty();
		return Maybe.of(((AssignmentExpression) node).expression);
	}

	public String propertyName() {
		return "expression";
	}
}

class AssignmentTargetPropertyIdentifierBinding extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof AssignmentTargetPropertyIdentifier)) return Maybe.empty();
		return Maybe.of(((AssignmentTargetPropertyIdentifier) node).binding);
	}

	public String propertyName() {
		return "binding";
	}
}

class AssignmentTargetPropertyIdentifierInit extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof AssignmentTargetPropertyIdentifier)) return Maybe.empty();
		return ((AssignmentTargetPropertyIdentifier) node).init;
	}

	public String propertyName() {
		return "init";
	}
}

class AssignmentTargetPropertyPropertyName extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof AssignmentTargetPropertyProperty)) return Maybe.empty();
		return Maybe.of(((AssignmentTargetPropertyProperty) node).name);
	}

	public String propertyName() {
		return "name";
	}
}

class AssignmentTargetPropertyPropertyBinding extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof AssignmentTargetPropertyProperty)) return Maybe.empty();
		return Maybe.of(((AssignmentTargetPropertyProperty) node).binding);
	}

	public String propertyName() {
		return "binding";
	}
}

class AssignmentTargetWithDefaultBinding extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof AssignmentTargetWithDefault)) return Maybe.empty();
		return Maybe.of(((AssignmentTargetWithDefault) node).binding);
	}

	public String propertyName() {
		return "binding";
	}
}

class AssignmentTargetWithDefaultInit extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof AssignmentTargetWithDefault)) return Maybe.empty();
		return Maybe.of(((AssignmentTargetWithDefault) node).init);
	}

	public String propertyName() {
		return "init";
	}
}

class AwaitExpressionExpression extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof AwaitExpression)) return Maybe.empty();
		return Maybe.of(((AwaitExpression) node).expression);
	}

	public String propertyName() {
		return "expression";
	}
}

class BinaryExpressionLeft extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof BinaryExpression)) return Maybe.empty();
		return Maybe.of(((BinaryExpression) node).left);
	}

	public String propertyName() {
		return "left";
	}
}

class BinaryExpressionRight extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof BinaryExpression)) return Maybe.empty();
		return Maybe.of(((BinaryExpression) node).right);
	}

	public String propertyName() {
		return "right";
	}
}

class BindingPropertyIdentifierBinding extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof BindingPropertyIdentifier)) return Maybe.empty();
		return Maybe.of(((BindingPropertyIdentifier) node).binding);
	}

	public String propertyName() {
		return "binding";
	}
}

class BindingPropertyIdentifierInit extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof BindingPropertyIdentifier)) return Maybe.empty();
		return ((BindingPropertyIdentifier) node).init;
	}

	public String propertyName() {
		return "init";
	}
}

class BindingPropertyPropertyName extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof BindingPropertyProperty)) return Maybe.empty();
		return Maybe.of(((BindingPropertyProperty) node).name);
	}

	public String propertyName() {
		return "name";
	}
}

class BindingPropertyPropertyBinding extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof BindingPropertyProperty)) return Maybe.empty();
		return Maybe.of(((BindingPropertyProperty) node).binding);
	}

	public String propertyName() {
		return "binding";
	}
}

class BindingWithDefaultBinding extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof BindingWithDefault)) return Maybe.empty();
		return Maybe.of(((BindingWithDefault) node).binding);
	}

	public String propertyName() {
		return "binding";
	}
}

class BindingWithDefaultInit extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof BindingWithDefault)) return Maybe.empty();
		return Maybe.of(((BindingWithDefault) node).init);
	}

	public String propertyName() {
		return "init";
	}
}

class BlockStatements extends IndexedBranch {
	protected BlockStatements(int index) {
		super(index);
	}

	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof Block)) return Maybe.empty();
		return ((Block) node).statements.index(index);
	}

	public String propertyName() {
		return "statements[" + Integer.toString(index) + "]";
	}
}

class BlockStatementBlock extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof BlockStatement)) return Maybe.empty();
		return Maybe.of(((BlockStatement) node).block);
	}

	public String propertyName() {
		return "block";
	}
}

class CallExpressionCallee extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof CallExpression)) return Maybe.empty();
		return Maybe.of(((CallExpression) node).callee);
	}

	public String propertyName() {
		return "callee";
	}
}

class CallExpressionArguments extends IndexedBranch {
	protected CallExpressionArguments(int index) {
		super(index);
	}

	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof CallExpression)) return Maybe.empty();
		return ((CallExpression) node).arguments.index(index);
	}

	public String propertyName() {
		return "arguments[" + Integer.toString(index) + "]";
	}
}

class CatchClauseBinding extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof CatchClause)) return Maybe.empty();
		return Maybe.of(((CatchClause) node).binding);
	}

	public String propertyName() {
		return "binding";
	}
}

class CatchClauseBody extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof CatchClause)) return Maybe.empty();
		return Maybe.of(((CatchClause) node).body);
	}

	public String propertyName() {
		return "body";
	}
}

class ClassDeclarationName extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof ClassDeclaration)) return Maybe.empty();
		return Maybe.of(((ClassDeclaration) node).name);
	}

	public String propertyName() {
		return "name";
	}
}

class ClassDeclarationSuper extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof ClassDeclaration)) return Maybe.empty();
		return ((ClassDeclaration) node)._super;
	}

	public String propertyName() {
		return "super";
	}
}

class ClassDeclarationElements extends IndexedBranch {
	protected ClassDeclarationElements(int index) {
		super(index);
	}

	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof ClassDeclaration)) return Maybe.empty();
		return ((ClassDeclaration) node).elements.index(index);
	}

	public String propertyName() {
		return "elements[" + Integer.toString(index) + "]";
	}
}

class ClassElementMethod extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof ClassElement)) return Maybe.empty();
		return Maybe.of(((ClassElement) node).method);
	}

	public String propertyName() {
		return "method";
	}
}

class ClassExpressionName extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof ClassExpression)) return Maybe.empty();
		return ((ClassExpression) node).name;
	}

	public String propertyName() {
		return "name";
	}
}

class ClassExpressionSuper extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof ClassExpression)) return Maybe.empty();
		return ((ClassExpression) node)._super;
	}

	public String propertyName() {
		return "super";
	}
}

class ClassExpressionElements extends IndexedBranch {
	protected ClassExpressionElements(int index) {
		super(index);
	}

	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof ClassExpression)) return Maybe.empty();
		return ((ClassExpression) node).elements.index(index);
	}

	public String propertyName() {
		return "elements[" + Integer.toString(index) + "]";
	}
}

class CompoundAssignmentExpressionBinding extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof CompoundAssignmentExpression)) return Maybe.empty();
		return Maybe.of(((CompoundAssignmentExpression) node).binding);
	}

	public String propertyName() {
		return "binding";
	}
}

class CompoundAssignmentExpressionExpression extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof CompoundAssignmentExpression)) return Maybe.empty();
		return Maybe.of(((CompoundAssignmentExpression) node).expression);
	}

	public String propertyName() {
		return "expression";
	}
}

class ComputedMemberAssignmentTargetObject extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof ComputedMemberAssignmentTarget)) return Maybe.empty();
		return Maybe.of(((ComputedMemberAssignmentTarget) node).object);
	}

	public String propertyName() {
		return "object";
	}
}

class ComputedMemberAssignmentTargetExpression extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof ComputedMemberAssignmentTarget)) return Maybe.empty();
		return Maybe.of(((ComputedMemberAssignmentTarget) node).expression);
	}

	public String propertyName() {
		return "expression";
	}
}

class ComputedMemberExpressionObject extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof ComputedMemberExpression)) return Maybe.empty();
		return Maybe.of(((ComputedMemberExpression) node).object);
	}

	public String propertyName() {
		return "object";
	}
}

class ComputedMemberExpressionExpression extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof ComputedMemberExpression)) return Maybe.empty();
		return Maybe.of(((ComputedMemberExpression) node).expression);
	}

	public String propertyName() {
		return "expression";
	}
}

class ComputedPropertyNameExpression extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof ComputedPropertyName)) return Maybe.empty();
		return Maybe.of(((ComputedPropertyName) node).expression);
	}

	public String propertyName() {
		return "expression";
	}
}

class ConditionalExpressionTest extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof ConditionalExpression)) return Maybe.empty();
		return Maybe.of(((ConditionalExpression) node).test);
	}

	public String propertyName() {
		return "test";
	}
}

class ConditionalExpressionConsequent extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof ConditionalExpression)) return Maybe.empty();
		return Maybe.of(((ConditionalExpression) node).consequent);
	}

	public String propertyName() {
		return "consequent";
	}
}

class ConditionalExpressionAlternate extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof ConditionalExpression)) return Maybe.empty();
		return Maybe.of(((ConditionalExpression) node).alternate);
	}

	public String propertyName() {
		return "alternate";
	}
}

class DataPropertyName extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof DataProperty)) return Maybe.empty();
		return Maybe.of(((DataProperty) node).name);
	}

	public String propertyName() {
		return "name";
	}
}

class DataPropertyExpression extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof DataProperty)) return Maybe.empty();
		return Maybe.of(((DataProperty) node).expression);
	}

	public String propertyName() {
		return "expression";
	}
}

class DoWhileStatementBody extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof DoWhileStatement)) return Maybe.empty();
		return Maybe.of(((DoWhileStatement) node).body);
	}

	public String propertyName() {
		return "body";
	}
}

class DoWhileStatementTest extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof DoWhileStatement)) return Maybe.empty();
		return Maybe.of(((DoWhileStatement) node).test);
	}

	public String propertyName() {
		return "test";
	}
}

class ExportDeclaration extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof Export)) return Maybe.empty();
		return Maybe.of(((Export) node).declaration);
	}

	public String propertyName() {
		return "declaration";
	}
}

class ExportDefaultBody extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof ExportDefault)) return Maybe.empty();
		return Maybe.of(((ExportDefault) node).body);
	}

	public String propertyName() {
		return "body";
	}
}

class ExportFromNamedExports extends IndexedBranch {
	protected ExportFromNamedExports(int index) {
		super(index);
	}

	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof ExportFrom)) return Maybe.empty();
		return ((ExportFrom) node).namedExports.index(index);
	}

	public String propertyName() {
		return "namedExports[" + Integer.toString(index) + "]";
	}
}

class ExportLocalSpecifierName extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof ExportLocalSpecifier)) return Maybe.empty();
		return Maybe.of(((ExportLocalSpecifier) node).name);
	}

	public String propertyName() {
		return "name";
	}
}

class ExportLocalsNamedExports extends IndexedBranch {
	protected ExportLocalsNamedExports(int index) {
		super(index);
	}

	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof ExportLocals)) return Maybe.empty();
		return ((ExportLocals) node).namedExports.index(index);
	}

	public String propertyName() {
		return "namedExports[" + Integer.toString(index) + "]";
	}
}

class ExpressionStatementExpression extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof ExpressionStatement)) return Maybe.empty();
		return Maybe.of(((ExpressionStatement) node).expression);
	}

	public String propertyName() {
		return "expression";
	}
}

class ForInStatementLeft extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof ForInStatement)) return Maybe.empty();
		return Maybe.of(((ForInStatement) node).left);
	}

	public String propertyName() {
		return "left";
	}
}

class ForInStatementRight extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof ForInStatement)) return Maybe.empty();
		return Maybe.of(((ForInStatement) node).right);
	}

	public String propertyName() {
		return "right";
	}
}

class ForInStatementBody extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof ForInStatement)) return Maybe.empty();
		return Maybe.of(((ForInStatement) node).body);
	}

	public String propertyName() {
		return "body";
	}
}

class ForOfStatementLeft extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof ForOfStatement)) return Maybe.empty();
		return Maybe.of(((ForOfStatement) node).left);
	}

	public String propertyName() {
		return "left";
	}
}

class ForOfStatementRight extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof ForOfStatement)) return Maybe.empty();
		return Maybe.of(((ForOfStatement) node).right);
	}

	public String propertyName() {
		return "right";
	}
}

class ForOfStatementBody extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof ForOfStatement)) return Maybe.empty();
		return Maybe.of(((ForOfStatement) node).body);
	}

	public String propertyName() {
		return "body";
	}
}

class ForStatementInit extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof ForStatement)) return Maybe.empty();
		return ((ForStatement) node).init;
	}

	public String propertyName() {
		return "init";
	}
}

class ForStatementTest extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof ForStatement)) return Maybe.empty();
		return ((ForStatement) node).test;
	}

	public String propertyName() {
		return "test";
	}
}

class ForStatementUpdate extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof ForStatement)) return Maybe.empty();
		return ((ForStatement) node).update;
	}

	public String propertyName() {
		return "update";
	}
}

class ForStatementBody extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof ForStatement)) return Maybe.empty();
		return Maybe.of(((ForStatement) node).body);
	}

	public String propertyName() {
		return "body";
	}
}

class FormalParametersItems extends IndexedBranch {
	protected FormalParametersItems(int index) {
		super(index);
	}

	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof FormalParameters)) return Maybe.empty();
		return ((FormalParameters) node).items.index(index);
	}

	public String propertyName() {
		return "items[" + Integer.toString(index) + "]";
	}
}

class FormalParametersRest extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof FormalParameters)) return Maybe.empty();
		return ((FormalParameters) node).rest;
	}

	public String propertyName() {
		return "rest";
	}
}

class FunctionBodyDirectives extends IndexedBranch {
	protected FunctionBodyDirectives(int index) {
		super(index);
	}

	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof FunctionBody)) return Maybe.empty();
		return ((FunctionBody) node).directives.index(index);
	}

	public String propertyName() {
		return "directives[" + Integer.toString(index) + "]";
	}
}

class FunctionBodyStatements extends IndexedBranch {
	protected FunctionBodyStatements(int index) {
		super(index);
	}

	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof FunctionBody)) return Maybe.empty();
		return ((FunctionBody) node).statements.index(index);
	}

	public String propertyName() {
		return "statements[" + Integer.toString(index) + "]";
	}
}

class FunctionDeclarationName extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof FunctionDeclaration)) return Maybe.empty();
		return Maybe.of(((FunctionDeclaration) node).name);
	}

	public String propertyName() {
		return "name";
	}
}

class FunctionDeclarationParams extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof FunctionDeclaration)) return Maybe.empty();
		return Maybe.of(((FunctionDeclaration) node).params);
	}

	public String propertyName() {
		return "params";
	}
}

class FunctionDeclarationBody extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof FunctionDeclaration)) return Maybe.empty();
		return Maybe.of(((FunctionDeclaration) node).body);
	}

	public String propertyName() {
		return "body";
	}
}

class FunctionExpressionName extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof FunctionExpression)) return Maybe.empty();
		return ((FunctionExpression) node).name;
	}

	public String propertyName() {
		return "name";
	}
}

class FunctionExpressionParams extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof FunctionExpression)) return Maybe.empty();
		return Maybe.of(((FunctionExpression) node).params);
	}

	public String propertyName() {
		return "params";
	}
}

class FunctionExpressionBody extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof FunctionExpression)) return Maybe.empty();
		return Maybe.of(((FunctionExpression) node).body);
	}

	public String propertyName() {
		return "body";
	}
}

class GetterName extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof Getter)) return Maybe.empty();
		return Maybe.of(((Getter) node).name);
	}

	public String propertyName() {
		return "name";
	}
}

class GetterBody extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof Getter)) return Maybe.empty();
		return Maybe.of(((Getter) node).body);
	}

	public String propertyName() {
		return "body";
	}
}

class IfStatementTest extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof IfStatement)) return Maybe.empty();
		return Maybe.of(((IfStatement) node).test);
	}

	public String propertyName() {
		return "test";
	}
}

class IfStatementConsequent extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof IfStatement)) return Maybe.empty();
		return Maybe.of(((IfStatement) node).consequent);
	}

	public String propertyName() {
		return "consequent";
	}
}

class IfStatementAlternate extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof IfStatement)) return Maybe.empty();
		return ((IfStatement) node).alternate;
	}

	public String propertyName() {
		return "alternate";
	}
}

class ImportDefaultBinding extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof Import)) return Maybe.empty();
		return ((Import) node).defaultBinding;
	}

	public String propertyName() {
		return "defaultBinding";
	}
}

class ImportNamedImports extends IndexedBranch {
	protected ImportNamedImports(int index) {
		super(index);
	}

	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof Import)) return Maybe.empty();
		return ((Import) node).namedImports.index(index);
	}

	public String propertyName() {
		return "namedImports[" + Integer.toString(index) + "]";
	}
}

class ImportNamespaceDefaultBinding extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof ImportNamespace)) return Maybe.empty();
		return ((ImportNamespace) node).defaultBinding;
	}

	public String propertyName() {
		return "defaultBinding";
	}
}

class ImportNamespaceNamespaceBinding extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof ImportNamespace)) return Maybe.empty();
		return Maybe.of(((ImportNamespace) node).namespaceBinding);
	}

	public String propertyName() {
		return "namespaceBinding";
	}
}

class ImportSpecifierBinding extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof ImportSpecifier)) return Maybe.empty();
		return Maybe.of(((ImportSpecifier) node).binding);
	}

	public String propertyName() {
		return "binding";
	}
}

class LabeledStatementBody extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof LabeledStatement)) return Maybe.empty();
		return Maybe.of(((LabeledStatement) node).body);
	}

	public String propertyName() {
		return "body";
	}
}

class MethodName extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof Method)) return Maybe.empty();
		return Maybe.of(((Method) node).name);
	}

	public String propertyName() {
		return "name";
	}
}

class MethodParams extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof Method)) return Maybe.empty();
		return Maybe.of(((Method) node).params);
	}

	public String propertyName() {
		return "params";
	}
}

class MethodBody extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof Method)) return Maybe.empty();
		return Maybe.of(((Method) node).body);
	}

	public String propertyName() {
		return "body";
	}
}

class ModuleDirectives extends IndexedBranch {
	protected ModuleDirectives(int index) {
		super(index);
	}

	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof Module)) return Maybe.empty();
		return ((Module) node).directives.index(index);
	}

	public String propertyName() {
		return "directives[" + Integer.toString(index) + "]";
	}
}

class ModuleItems extends IndexedBranch {
	protected ModuleItems(int index) {
		super(index);
	}

	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof Module)) return Maybe.empty();
		return ((Module) node).items.index(index);
	}

	public String propertyName() {
		return "items[" + Integer.toString(index) + "]";
	}
}

class NewExpressionCallee extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof NewExpression)) return Maybe.empty();
		return Maybe.of(((NewExpression) node).callee);
	}

	public String propertyName() {
		return "callee";
	}
}

class NewExpressionArguments extends IndexedBranch {
	protected NewExpressionArguments(int index) {
		super(index);
	}

	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof NewExpression)) return Maybe.empty();
		return ((NewExpression) node).arguments.index(index);
	}

	public String propertyName() {
		return "arguments[" + Integer.toString(index) + "]";
	}
}

class ObjectAssignmentTargetProperties extends IndexedBranch {
	protected ObjectAssignmentTargetProperties(int index) {
		super(index);
	}

	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof ObjectAssignmentTarget)) return Maybe.empty();
		return ((ObjectAssignmentTarget) node).properties.index(index);
	}

	public String propertyName() {
		return "properties[" + Integer.toString(index) + "]";
	}
}

class ObjectBindingProperties extends IndexedBranch {
	protected ObjectBindingProperties(int index) {
		super(index);
	}

	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof ObjectBinding)) return Maybe.empty();
		return ((ObjectBinding) node).properties.index(index);
	}

	public String propertyName() {
		return "properties[" + Integer.toString(index) + "]";
	}
}

class ObjectExpressionProperties extends IndexedBranch {
	protected ObjectExpressionProperties(int index) {
		super(index);
	}

	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof ObjectExpression)) return Maybe.empty();
		return ((ObjectExpression) node).properties.index(index);
	}

	public String propertyName() {
		return "properties[" + Integer.toString(index) + "]";
	}
}

class ReturnStatementExpression extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof ReturnStatement)) return Maybe.empty();
		return ((ReturnStatement) node).expression;
	}

	public String propertyName() {
		return "expression";
	}
}

class ScriptDirectives extends IndexedBranch {
	protected ScriptDirectives(int index) {
		super(index);
	}

	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof Script)) return Maybe.empty();
		return ((Script) node).directives.index(index);
	}

	public String propertyName() {
		return "directives[" + Integer.toString(index) + "]";
	}
}

class ScriptStatements extends IndexedBranch {
	protected ScriptStatements(int index) {
		super(index);
	}

	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof Script)) return Maybe.empty();
		return ((Script) node).statements.index(index);
	}

	public String propertyName() {
		return "statements[" + Integer.toString(index) + "]";
	}
}

class SetterName extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof Setter)) return Maybe.empty();
		return Maybe.of(((Setter) node).name);
	}

	public String propertyName() {
		return "name";
	}
}

class SetterParam extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof Setter)) return Maybe.empty();
		return Maybe.of(((Setter) node).param);
	}

	public String propertyName() {
		return "param";
	}
}

class SetterBody extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof Setter)) return Maybe.empty();
		return Maybe.of(((Setter) node).body);
	}

	public String propertyName() {
		return "body";
	}
}

class ShorthandPropertyName extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof ShorthandProperty)) return Maybe.empty();
		return Maybe.of(((ShorthandProperty) node).name);
	}

	public String propertyName() {
		return "name";
	}
}

class SpreadElementExpression extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof SpreadElement)) return Maybe.empty();
		return Maybe.of(((SpreadElement) node).expression);
	}

	public String propertyName() {
		return "expression";
	}
}

class StaticMemberAssignmentTargetObject extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof StaticMemberAssignmentTarget)) return Maybe.empty();
		return Maybe.of(((StaticMemberAssignmentTarget) node).object);
	}

	public String propertyName() {
		return "object";
	}
}

class StaticMemberExpressionObject extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof StaticMemberExpression)) return Maybe.empty();
		return Maybe.of(((StaticMemberExpression) node).object);
	}

	public String propertyName() {
		return "object";
	}
}

class SwitchCaseTest extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof SwitchCase)) return Maybe.empty();
		return Maybe.of(((SwitchCase) node).test);
	}

	public String propertyName() {
		return "test";
	}
}

class SwitchCaseConsequent extends IndexedBranch {
	protected SwitchCaseConsequent(int index) {
		super(index);
	}

	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof SwitchCase)) return Maybe.empty();
		return ((SwitchCase) node).consequent.index(index);
	}

	public String propertyName() {
		return "consequent[" + Integer.toString(index) + "]";
	}
}

class SwitchDefaultConsequent extends IndexedBranch {
	protected SwitchDefaultConsequent(int index) {
		super(index);
	}

	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof SwitchDefault)) return Maybe.empty();
		return ((SwitchDefault) node).consequent.index(index);
	}

	public String propertyName() {
		return "consequent[" + Integer.toString(index) + "]";
	}
}

class SwitchStatementDiscriminant extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof SwitchStatement)) return Maybe.empty();
		return Maybe.of(((SwitchStatement) node).discriminant);
	}

	public String propertyName() {
		return "discriminant";
	}
}

class SwitchStatementCases extends IndexedBranch {
	protected SwitchStatementCases(int index) {
		super(index);
	}

	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof SwitchStatement)) return Maybe.empty();
		return ((SwitchStatement) node).cases.index(index);
	}

	public String propertyName() {
		return "cases[" + Integer.toString(index) + "]";
	}
}

class SwitchStatementWithDefaultDiscriminant extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof SwitchStatementWithDefault)) return Maybe.empty();
		return Maybe.of(((SwitchStatementWithDefault) node).discriminant);
	}

	public String propertyName() {
		return "discriminant";
	}
}

class SwitchStatementWithDefaultPreDefaultCases extends IndexedBranch {
	protected SwitchStatementWithDefaultPreDefaultCases(int index) {
		super(index);
	}

	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof SwitchStatementWithDefault)) return Maybe.empty();
		return ((SwitchStatementWithDefault) node).preDefaultCases.index(index);
	}

	public String propertyName() {
		return "preDefaultCases[" + Integer.toString(index) + "]";
	}
}

class SwitchStatementWithDefaultDefaultCase extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof SwitchStatementWithDefault)) return Maybe.empty();
		return Maybe.of(((SwitchStatementWithDefault) node).defaultCase);
	}

	public String propertyName() {
		return "defaultCase";
	}
}

class SwitchStatementWithDefaultPostDefaultCases extends IndexedBranch {
	protected SwitchStatementWithDefaultPostDefaultCases(int index) {
		super(index);
	}

	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof SwitchStatementWithDefault)) return Maybe.empty();
		return ((SwitchStatementWithDefault) node).postDefaultCases.index(index);
	}

	public String propertyName() {
		return "postDefaultCases[" + Integer.toString(index) + "]";
	}
}

class TemplateExpressionTag extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof TemplateExpression)) return Maybe.empty();
		return ((TemplateExpression) node).tag;
	}

	public String propertyName() {
		return "tag";
	}
}

class TemplateExpressionElements extends IndexedBranch {
	protected TemplateExpressionElements(int index) {
		super(index);
	}

	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof TemplateExpression)) return Maybe.empty();
		return ((TemplateExpression) node).elements.index(index);
	}

	public String propertyName() {
		return "elements[" + Integer.toString(index) + "]";
	}
}

class ThrowStatementExpression extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof ThrowStatement)) return Maybe.empty();
		return Maybe.of(((ThrowStatement) node).expression);
	}

	public String propertyName() {
		return "expression";
	}
}

class TryCatchStatementBody extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof TryCatchStatement)) return Maybe.empty();
		return Maybe.of(((TryCatchStatement) node).body);
	}

	public String propertyName() {
		return "body";
	}
}

class TryCatchStatementCatchClause extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof TryCatchStatement)) return Maybe.empty();
		return Maybe.of(((TryCatchStatement) node).catchClause);
	}

	public String propertyName() {
		return "catchClause";
	}
}

class TryFinallyStatementBody extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof TryFinallyStatement)) return Maybe.empty();
		return Maybe.of(((TryFinallyStatement) node).body);
	}

	public String propertyName() {
		return "body";
	}
}

class TryFinallyStatementCatchClause extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof TryFinallyStatement)) return Maybe.empty();
		return ((TryFinallyStatement) node).catchClause;
	}

	public String propertyName() {
		return "catchClause";
	}
}

class TryFinallyStatementFinalizer extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof TryFinallyStatement)) return Maybe.empty();
		return Maybe.of(((TryFinallyStatement) node).finalizer);
	}

	public String propertyName() {
		return "finalizer";
	}
}

class UnaryExpressionOperand extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof UnaryExpression)) return Maybe.empty();
		return Maybe.of(((UnaryExpression) node).operand);
	}

	public String propertyName() {
		return "operand";
	}
}

class UpdateExpressionOperand extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof UpdateExpression)) return Maybe.empty();
		return Maybe.of(((UpdateExpression) node).operand);
	}

	public String propertyName() {
		return "operand";
	}
}

class VariableDeclarationDeclarators extends IndexedBranch {
	protected VariableDeclarationDeclarators(int index) {
		super(index);
	}

	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof VariableDeclaration)) return Maybe.empty();
		return ((VariableDeclaration) node).declarators.index(index);
	}

	public String propertyName() {
		return "declarators[" + Integer.toString(index) + "]";
	}
}

class VariableDeclarationStatementDeclaration extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof VariableDeclarationStatement)) return Maybe.empty();
		return Maybe.of(((VariableDeclarationStatement) node).declaration);
	}

	public String propertyName() {
		return "declaration";
	}
}

class VariableDeclaratorBinding extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof VariableDeclarator)) return Maybe.empty();
		return Maybe.of(((VariableDeclarator) node).binding);
	}

	public String propertyName() {
		return "binding";
	}
}

class VariableDeclaratorInit extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof VariableDeclarator)) return Maybe.empty();
		return ((VariableDeclarator) node).init;
	}

	public String propertyName() {
		return "init";
	}
}

class WhileStatementTest extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof WhileStatement)) return Maybe.empty();
		return Maybe.of(((WhileStatement) node).test);
	}

	public String propertyName() {
		return "test";
	}
}

class WhileStatementBody extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof WhileStatement)) return Maybe.empty();
		return Maybe.of(((WhileStatement) node).body);
	}

	public String propertyName() {
		return "body";
	}
}

class WithStatementObject extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof WithStatement)) return Maybe.empty();
		return Maybe.of(((WithStatement) node).object);
	}

	public String propertyName() {
		return "object";
	}
}

class WithStatementBody extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof WithStatement)) return Maybe.empty();
		return Maybe.of(((WithStatement) node).body);
	}

	public String propertyName() {
		return "body";
	}
}

class YieldExpressionExpression extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof YieldExpression)) return Maybe.empty();
		return ((YieldExpression) node).expression;
	}

	public String propertyName() {
		return "expression";
	}
}

class YieldGeneratorExpressionExpression extends Branch {
	@Override
	public Maybe<? extends Node> step(Node node) {
		if (!(node instanceof YieldGeneratorExpression)) return Maybe.empty();
		return Maybe.of(((YieldGeneratorExpression) node).expression);
	}

	public String propertyName() {
		return "expression";
	}
}
